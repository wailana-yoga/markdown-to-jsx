{
  "version": 3,
  "sources": ["src/constants.ts", "src/types.ts", "src/utils.ts", "src/parse.ts", "src/html.ts"],
  "sourcesContent": [
    "// Character codes\nexport const CHAR_SPACE = 32\nexport const CHAR_TAB = 9\nexport const CHAR_CR = 13\nexport const CHAR_NEWLINE = 10\nexport const CHAR_BACKTICK = 96\nexport const CHAR_TILDE = 126\nexport const CHAR_BRACKET_OPEN = 91\nexport const CHAR_CARET = 94\nexport const CHAR_GT = 62\nexport const CHAR_HASH = 35\nexport const CHAR_DOLLAR = 36\nexport const CHAR_PERCENT = 37\nexport const CHAR_DASH = 45\nexport const CHAR_EQ = 61\nexport const CHAR_BACKSLASH = 92\nexport const CHAR_ASTERISK = 42\nexport const CHAR_UNDERSCORE = 95\nexport const CHAR_LT = 60\nexport const CHAR_AT = 64\nexport const CHAR_BRACKET_CLOSE = 93\nexport const CHAR_EXCLAMATION = 33\nexport const CHAR_AMPERSAND = 38\nexport const CHAR_COLON = 58\nexport const CHAR_F = 70\nexport const CHAR_f = 102\nexport const CHAR_H = 104\nexport const CHAR_W = 119\nexport const CHAR_t = 116\nexport const CHAR_p = 112\nexport const CHAR_s = 115\nexport const CHAR_NBSP = 160\nexport const CHAR_FF = 12\nexport const CHAR_COMMA = 44\nexport const CHAR_SEMICOLON = 59\nexport const CHAR_QUESTION = 63\nexport const CHAR_PERIOD = 46\nexport const CHAR_SLASH = 47\nexport const CHAR_SINGLE_QUOTE = 39\nexport const CHAR_DOUBLE_QUOTE = 34\nexport const CHAR_PLUS = 43\nexport const CHAR_PIPE = 124\nexport const CHAR_BRACE_OPEN = 123 // {\nexport const CHAR_BRACE_CLOSE = 125 // }\nexport const CHAR_PAREN_OPEN = 40 // (\nexport const CHAR_PAREN_CLOSE = 41 // )\nexport const CHAR_d = 100\nexport const CHAR_x = 120\nexport const CHAR_X = 88\nexport const CHAR_RECORD_SEP = 0x1E // Internal: lazy continuation marker\nexport const CHAR_UNIT_SEP = 0x1F // Internal: hard break marker\n// Character code ranges for common character classes\nexport const CHAR_DIGIT_0 = 48\nexport const CHAR_DIGIT_9 = 57\nexport const CHAR_A = 65\nexport const CHAR_Z = 90\nexport const CHAR_a = 97\nexport const CHAR_z = 122\nexport const CHAR_ASCII_BOUNDARY = 128\n// Case conversion offset: difference between uppercase and lowercase ASCII letters\nexport const CHAR_CASE_OFFSET = 32 // 'A' (65) to 'a' (97) = 32\n",
    "// Re-export React for convenience since types reference it\nimport * as React from 'react'\n\n/**\n * Analogous to `node.type`. Please note that the values here may change at any time,\n * so do not hard code against the value directly.\n */\nconst RuleTypeConst = {\n  blockQuote: 0,\n  breakLine: 1,\n  breakThematic: 2,\n  codeBlock: 3,\n  codeInline: 4,\n  footnote: 5,\n  footnoteReference: 6,\n  frontmatter: 7,\n  gfmTask: 8,\n  heading: 9,\n  htmlBlock: 10,\n  htmlComment: 11,\n  htmlSelfClosing: 12,\n  image: 13,\n  link: 14,\n  orderedList: 15,\n  paragraph: 16,\n  ref: 17,\n  refCollection: 18,\n  table: 19,\n  text: 20,\n  textFormatted: 21,\n  unorderedList: 22,\n} as const\n\nif (process.env.NODE_ENV === 'test') {\n  // In test mode, use strings for better debugging\n  Object.keys(RuleTypeConst).forEach(key => (RuleTypeConst[key] = key))\n}\n\ntype RuleTypeValue = (typeof RuleTypeConst)[keyof typeof RuleTypeConst]\n\n/**\n * markdown-to-jsx types and interfaces\n * @lang zh markdown-to-jsx 类型和接口\n * @lang hi markdown-to-jsx प्रकार और इंटरफ़ेस\n */\ndeclare namespace MarkdownToJSX {\n  /**\n   * RequireAtLeastOne<{ ... }> <- only requires at least one key\n   * @lang zh RequireAtLeastOne<{ ... }> <- 只需要至少一个键\n   * @lang hi RequireAtLeastOne<{ ... }> <- केवल कम से कम एक कुंजी की आवश्यकता है\n   */\n  type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<\n    T,\n    Exclude<keyof T, Keys>\n  > &\n    {\n      [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>\n    }[Keys]\n\n  /**\n   * React.createElement function type\n   * @lang zh React.createElement 函数类型\n   * @lang hi React.createElement फ़ंक्शन प्रकार\n   */\n  export type CreateElement = typeof React.createElement\n\n  /**\n   * HTML tag names that can be used in JSX\n   * @lang zh 可在 JSX 中使用的 HTML 标签名称\n   * @lang hi HTML टैग नाम जो JSX में उपयोग किए जा सकते हैं\n   */\n  export type HTMLTags = keyof React.JSX.IntrinsicElements & (string & {})\n\n  /**\n   * Parser and renderer state\n   * @lang zh 解析器和渲染器状态\n   * @lang hi पार्सर और रेंडरर स्थिति\n   */\n  export type State = {\n    /** true if the current content is inside anchor link grammar */\n    /** @lang zh 如果当前内容在锚点链接语法内，则为 true */\n    /** @lang hi true यदि वर्तमान सामग्री एंकर लिंक व्याकरण के अंदर है */\n    inAnchor?: boolean\n    /** true if inside a blockquote */\n    /** @lang zh 如果在引用块内，则为 true */\n    /** @lang hi true यदि ब्लॉककोट के अंदर है */\n    inBlockQuote?: boolean\n    /** true if parsing in an HTML context */\n    /** @lang zh 如果在 HTML 上下文中解析，则为 true */\n    /** @lang hi true यदि HTML संदर्भ में पार्स कर रहे हैं */\n    inHTML?: boolean\n    /** true if in a list */\n    /** @lang zh 如果在列表中，则为 true */\n    /** @lang hi true यदि सूची में है */\n    inList?: boolean\n    /** true if parsing in an inline context (subset of rules around formatting and links) */\n    /** @lang zh 如果在内联上下文中解析（围绕格式和链接的规则子集），则为 true */\n    /** @lang hi true यदि इनलाइन संदर्भ में पार्स कर रहे हैं (फ़ॉर्मेटिंग और लिंक के आसपास के नियमों का उपसमुच्चय) */\n    inline?: boolean\n\n    /** use this for the `key` prop */\n    /** @lang zh 用于 `key` 属性 */\n    /** @lang hi `key` prop के लिए इसका उपयोग करें */\n    key?: string | number\n    /** reference definitions (footnotes are stored with '^' prefix) */\n    /** @lang zh 引用定义（脚注以 '^' 前缀存储） */\n    /** @lang hi संदर्भ परिभाषाएं (फ़ुटनोट्स '^' उपसर्ग के साथ संग्रहीत हैं) */\n    refs?: { [key: string]: { target: string; title: string } }\n    /** current recursion depth during rendering */\n    /** @lang zh 渲染期间的当前递归深度 */\n    /** @lang hi रेंडरिंग के दौरान वर्तमान पुनरावृत्ति गहराई */\n    renderDepth?: number\n    /** internal: block parse recursion depth */\n    _depth?: number\n    /** internal: disable setext heading detection (lazy blockquote continuation) */\n    _noSetext?: boolean\n    /** internal: HTML nesting depth for stack overflow protection */\n    _htmlDepth?: number\n  }\n\n  /**\n   * Blockquote node in the AST\n   * @lang zh AST 中的引用块节点\n   * @lang hi AST में ब्लॉककोट नोड\n   */\n  export interface BlockQuoteNode {\n    /** Optional alert type (Note, Tip, Warning, etc.) */\n    /** @lang zh 可选的警告类型 (Note, Tip, Warning 等) */\n    /** @lang hi वैकल्पिक अलर्ट प्रकार (Note, Tip, Warning, आदि) */\n    alert?: string\n    /** Child nodes within the blockquote */\n    /** @lang zh 引用块中的子节点 */\n    /** @lang hi ब्लॉककोट के भीतर चाइल्ड नोड्स */\n    children: MarkdownToJSX.ASTNode[]\n    type: typeof RuleType.blockQuote\n  }\n\n  /**\n   * Hard line break node\n   * @lang zh 硬换行节点\n   * @lang hi हार्ड लाइन ब्रेक नोड\n   */\n  export interface BreakLineNode {\n    type: typeof RuleType.breakLine\n  }\n\n  /**\n   * Thematic break (horizontal rule) node\n   * @lang zh 分隔线（水平线）节点\n   * @lang hi थीमैटिक ब्रेक (क्षैतिज नियम) नोड\n   */\n  export interface BreakThematicNode {\n    type: typeof RuleType.breakThematic\n  }\n\n  /**\n   * Code block node (fenced code blocks)\n   * @lang zh 代码块节点（围栏代码块）\n   * @lang hi कोड ब्लॉक नोड (फ़ेंस्ड कोड ब्लॉक्स)\n   */\n  export interface CodeBlockNode {\n    type: typeof RuleType.codeBlock\n    /** HTML attributes for the code block */\n    /** @lang zh 代码块的 HTML 属性 */\n    /** @lang hi कोड ब्लॉक के लिए HTML एट्रिब्यूट्स */\n    attrs?: React.JSX.IntrinsicAttributes\n    /** Programming language identifier */\n    /** @lang zh 编程语言标识符 */\n    /** @lang hi प्रोग्रामिंग भाषा पहचानकर्ता */\n    lang?: string\n    /** Code content */\n    /** @lang zh 代码内容 */\n    /** @lang hi कोड सामग्री */\n    text: string\n  }\n\n  /**\n   * Inline code node\n   * @lang zh 内联代码节点\n   * @lang hi इनलाइन कोड नोड\n   */\n  export interface CodeInlineNode {\n    type: typeof RuleType.codeInline\n    /** Code text */\n    /** @lang zh 代码文本 */\n    /** @lang hi कोड टेक्स्ट */\n    text: string\n  }\n\n  /**\n   * Footnote definition node (not rendered, stored in refCollection)\n   * @lang zh 脚注定义节点（不渲染，存储在 refCollection 中）\n   * @lang hi फ़ुटनोट परिभाषा नोड (रेंडर नहीं किया गया, refCollection में संग्रहीत)\n   */\n  export interface FootnoteNode {\n    type: typeof RuleType.footnote\n  }\n\n  /**\n   * Footnote reference node\n   * @lang zh 脚注引用节点\n   * @lang hi फ़ुटनोट संदर्भ नोड\n   */\n  export interface FootnoteReferenceNode {\n    type: typeof RuleType.footnoteReference\n    /** Link target (anchor) */\n    /** @lang zh 链接目标（锚点） */\n    /** @lang hi लिंक लक्ष्य (एंकर) */\n    target: string\n    /** Display text */\n    /** @lang zh 显示文本 */\n    /** @lang hi प्रदर्शन टेक्स्ट */\n    text: string\n  }\n\n  /**\n   * YAML frontmatter node\n   * @lang zh YAML 前置元数据节点\n   * @lang hi YAML फ्रंटमैटर नोड\n   */\n  export interface FrontmatterNode {\n    type: typeof RuleType.frontmatter\n    /** Frontmatter content */\n    /** @lang zh 前置元数据内容 */\n    /** @lang hi फ्रंटमैटर सामग्री */\n    text: string\n  }\n\n  /**\n   * GFM task list item node\n   * @lang zh GFM 任务列表项节点\n   * @lang hi GFM टास्क लिस्ट आइटम नोड\n   */\n  export interface GFMTaskNode {\n    type: typeof RuleType.gfmTask\n    /** Whether the task is completed */\n    /** @lang zh 任务是否已完成 */\n    /** @lang hi क्या टास्क पूर्ण है */\n    completed: boolean\n  }\n\n  /**\n   * Heading node\n   * @lang zh 标题节点\n   * @lang hi हेडिंग नोड\n   */\n  export interface HeadingNode {\n    type: typeof RuleType.heading\n    /** Child nodes (text content) */\n    /** @lang zh 子节点（文本内容） */\n    /** @lang hi चाइल्ड नोड्स (टेक्स्ट सामग्री) */\n    children: MarkdownToJSX.ASTNode[]\n    /** Generated HTML ID for anchor linking */\n    /** @lang zh 用于锚点链接的生成的 HTML ID */\n    /** @lang hi एंकर लिंकिंग के लिए जेनरेट किया गया HTML ID */\n    id: string\n    /** Heading level (1-6) */\n    /** @lang zh 标题级别 (1-6) */\n    /** @lang hi हेडिंग स्तर (1-6) */\n    level: 1 | 2 | 3 | 4 | 5 | 6\n  }\n\n  /**\n   * HTML comment node\n   * @lang zh HTML 注释节点\n   * @lang hi HTML कमेंट नोड\n   */\n  export interface HTMLCommentNode {\n    type: typeof RuleType.htmlComment\n    /** Comment text */\n    /** @lang zh 注释文本 */\n    /** @lang hi कमेंट टेक्स्ट */\n    text: string\n  }\n\n  /**\n   * Image node\n   * @lang zh 图像节点\n   * @lang hi छवि नोड\n   */\n  export interface ImageNode {\n    type: typeof RuleType.image\n    /** Alt text */\n    /** @lang zh 替代文本 */\n    /** @lang hi Alt टेक्स्ट */\n    alt?: string\n    /** Image URL */\n    /** @lang zh 图像 URL */\n    /** @lang hi छवि URL */\n    target: string\n    /** Title attribute */\n    /** @lang zh 标题属性 */\n    /** @lang hi शीर्षक एट्रिब्यूट */\n    title?: string\n  }\n\n  /**\n   * Link node\n   * @lang zh 链接节点\n   * @lang hi लिंक नोड\n   */\n  export interface LinkNode {\n    type: typeof RuleType.link\n    /** Child nodes (link text) */\n    /** @lang zh 子节点（链接文本） */\n    /** @lang hi चाइल्ड नोड्स (लिंक टेक्स्ट) */\n    children: MarkdownToJSX.ASTNode[]\n    /** Link URL (null for reference links without definition) */\n    /** @lang zh 链接 URL（对于没有定义的引用链接为 null） */\n    /** @lang hi लिंक URL (परिभाषा के बिना संदर्भ लिंक के लिए null) */\n    target: string | null\n    /** Title attribute */\n    /** @lang zh 标题属性 */\n    /** @lang hi शीर्षक एट्रिब्यूट */\n    title?: string\n  }\n\n  /**\n   * Ordered list node\n   * @lang zh 有序列表节点\n   * @lang hi क्रमबद्ध सूची नोड\n   */\n  export interface OrderedListNode {\n    type: typeof RuleType.orderedList\n    /** Array of list items, each item is an array of nodes */\n    /** @lang zh 列表项数组，每个项是节点数组 */\n    /** @lang hi सूची आइटम्स की सरणी, प्रत्येक आइटम नोड्स की एक सरणी है */\n    items: MarkdownToJSX.ASTNode[][]\n    /** Starting number for the list */\n    /** @lang zh 列表的起始编号 */\n    /** @lang hi सूची के लिए प्रारंभिक संख्या */\n    start?: number\n  }\n\n  /**\n   * Unordered list node\n   * @lang zh 无序列表节点\n   * @lang hi अक्रमबद्ध सूची नोड\n   */\n  export interface UnorderedListNode {\n    type: typeof RuleType.unorderedList\n    /** Array of list items, each item is an array of nodes */\n    /** @lang zh 列表项数组，每个项是节点数组 */\n    /** @lang hi सूची आइटम्स की सरणी, प्रत्येक आइटम नोड्स की एक सरणी है */\n    items: MarkdownToJSX.ASTNode[][]\n  }\n\n  /**\n   * Paragraph node\n   * @lang zh 段落节点\n   * @lang hi पैराग्राफ नोड\n   */\n  export interface ParagraphNode {\n    type: typeof RuleType.paragraph\n    /** Child nodes */\n    /** @lang zh 子节点 */\n    /** @lang hi चाइल्ड नोड्स */\n    children: MarkdownToJSX.ASTNode[]\n  }\n\n  /**\n   * Reference definition node (not rendered, stored in refCollection)\n   * @lang zh 引用定义节点（不渲染，存储在 refCollection 中）\n   * @lang hi संदर्भ परिभाषा नोड (रेंडर नहीं किया गया, refCollection में संग्रहीत)\n   */\n  export interface ReferenceNode {\n    type: typeof RuleType.ref\n  }\n\n  /**\n   * Reference collection node (appears at AST root, includes footnotes with '^' prefix)\n   * @lang zh 引用集合节点（出现在 AST 根部，包括以 '^' 前缀的脚注）\n   * @lang hi संदर्भ संग्रह नोड (AST रूट पर दिखाई देता है, '^' उपसर्ग के साथ फ़ुटनोट्स शामिल हैं)\n   */\n  export interface ReferenceCollectionNode {\n    type: typeof RuleType.refCollection\n    /** Map of reference labels to their definitions */\n    /** @lang zh 引用标签到其定义的映射 */\n    /** @lang hi संदर्भ लेबल्स से उनकी परिभाषाओं का मैप */\n    refs: { [key: string]: { target: string; title: string } }\n  }\n\n  /**\n   * Table node\n   * @lang zh 表格节点\n   * @lang hi टेबल नोड\n   */\n  export interface TableNode {\n    type: typeof RuleType.table\n    /**\n     * alignment for each table column\n     * @lang zh 每个表格列的对齐方式\n     * @lang hi प्रत्येक टेबल कॉलम के लिए संरेखण\n     */\n    align: ('left' | 'right' | 'center')[]\n    /** Table cells (3D array: rows -> cells -> nodes) */\n    /** @lang zh 表格单元格（三维数组：行 -> 单元格 -> 节点） */\n    /** @lang hi टेबल सेल्स (3D सरणी: पंक्तियाँ -> सेल्स -> नोड्स) */\n    cells: MarkdownToJSX.ASTNode[][][]\n    /** Table header row */\n    /** @lang zh 表格标题行 */\n    /** @lang hi टेबल हेडर पंक्ति */\n    header: MarkdownToJSX.ASTNode[][]\n  }\n\n  /**\n   * Plain text node\n   * @lang zh 纯文本节点\n   * @lang hi सादा टेक्स्ट नोड\n   */\n  export interface TextNode {\n    type: typeof RuleType.text\n    /** Text content */\n    /** @lang zh 文本内容 */\n    /** @lang hi टेक्स्ट सामग्री */\n    text: string\n  }\n\n  /**\n   * Formatted text node (bold, italic, etc.)\n   * @lang zh 格式化文本节点（加粗、斜体等）\n   * @lang hi फ़ॉर्मेट किया गया टेक्स्ट नोड (बोल्ड, इटैलिक, आदि)\n   */\n  export interface FormattedTextNode {\n    type: typeof RuleType.textFormatted\n    /**\n     * the corresponding html tag\n     * @lang zh 对应的 HTML 标签\n     * @lang hi संबंधित HTML टैग\n     */\n    tag: string\n    /** Child nodes */\n    /** @lang zh 子节点 */\n    /** @lang hi चाइल्ड नोड्स */\n    children: MarkdownToJSX.ASTNode[]\n  }\n\n  /** @deprecated Use `FormattedTextNode` instead. */\n  export type TextFormattedNode = FormattedTextNode\n\n  /**\n   * HTML block node (includes JSX components)\n   * @lang zh HTML 块节点（包括 JSX 组件）\n   * @lang hi HTML ब्लॉक नोड (JSX कंपोनेंट्स शामिल हैं)\n   */\n  export interface HTMLNode {\n    type: typeof RuleType.htmlBlock\n    /** Parsed HTML attributes */\n    /** @lang zh 解析后的 HTML 属性 */\n    /** @lang hi पार्स किए गए HTML एट्रिब्यूट्स */\n    attrs?: Record<string, any>\n    /** Parsed child nodes (always parsed, even for verbatim blocks) */\n    /** @lang zh 解析后的子节点（始终解析，即使是逐字块） */\n    /** @lang hi पार्स किए गए चाइल्ड नोड्स (हमेशा पार्स किए जाते हैं, यहां तक कि verbatim ब्लॉक्स के लिए भी) */\n    children?: ASTNode[] | undefined\n    /** @internal Whether this is a closing tag */\n    _isClosingTag?: boolean\n    /** @internal Whether this is a verbatim block (script, style, pre, etc.) */\n    _verbatim?: boolean\n    /** @internal Original raw attribute string */\n    _rawAttrs?: string\n    /** @internal Original raw HTML content (for verbatim blocks) */\n    _rawText?: string | undefined\n    /** @deprecated Use `_rawText` instead. This property will be removed in a future major version. */\n    text?: string | undefined\n    /** HTML tag name */\n    /** @lang zh HTML 标签名称 */\n    /** @lang hi HTML टैग नाम */\n    tag: string\n  }\n\n  /**\n   * Self-closing HTML tag node\n   * @lang zh 自闭合 HTML 标签节点\n   * @lang hi स्व-बंद होने वाला HTML टैग नोड\n   */\n  export interface HTMLSelfClosingNode {\n    type: typeof RuleType.htmlSelfClosing\n    /** Parsed HTML attributes */\n    /** @lang zh 解析后的 HTML 属性 */\n    /** @lang hi पार्स किए गए HTML एट्रिब्यूट्स */\n    attrs?: Record<string, any>\n    /** @internal Whether this is a closing tag */\n    _isClosingTag?: boolean\n    /** HTML tag name */\n    /** @lang zh HTML 标签名称 */\n    /** @lang hi HTML टैग नाम */\n    tag: string\n    /** @internal Original raw HTML content */\n    _rawText?: string\n  }\n\n  /**\n   * Union type of all possible AST node types\n   * @lang zh 所有可能的 AST 节点类型的联合类型\n   * @lang hi सभी संभावित AST नोड प्रकारों का संघ प्रकार\n   */\n  export type ASTNode =\n    | BlockQuoteNode\n    | BreakLineNode\n    | BreakThematicNode\n    | CodeBlockNode\n    | CodeInlineNode\n    | FootnoteNode\n    | FootnoteReferenceNode\n    | FrontmatterNode\n    | GFMTaskNode\n    | HeadingNode\n    | HTMLCommentNode\n    | ImageNode\n    | LinkNode\n    | OrderedListNode\n    | UnorderedListNode\n    | ParagraphNode\n    | ReferenceNode\n    | ReferenceCollectionNode\n    | TableNode\n    | TextNode\n    | FormattedTextNode\n    | HTMLNode\n    | HTMLSelfClosingNode\n\n  /**\n   * Function type for rendering AST nodes\n   * @lang zh 用于渲染 AST 节点的函数类型\n   * @lang hi AST नोड्स को रेंडर करने के लिए फ़ंक्शन प्रकार\n   */\n  export type ASTRender = (\n    ast: MarkdownToJSX.ASTNode | MarkdownToJSX.ASTNode[],\n    state: MarkdownToJSX.State\n  ) => React.ReactNode\n\n  /**\n   * Override configuration for HTML tags or custom components\n   * @lang zh HTML 标签或自定义组件的覆盖配置\n   * @lang hi HTML टैग्स या कस्टम कंपोनेंट्स के लिए ओवरराइड कॉन्फ़िगरेशन\n   */\n  export type Override =\n    | RequireAtLeastOne<{\n        component: React.ElementType\n        props: Object\n      }>\n    | React.ElementType\n\n  /**\n   * Map of HTML tags and custom components to their override configurations\n   * @lang zh HTML 标签和自定义组件到其覆盖配置的映射\n   * @lang hi HTML टैग्स और कस्टम कंपोनेंट्स से उनकी ओवरराइड कॉन्फ़िगरेशन का मैप\n   */\n  export type Overrides = {\n    [tag in HTMLTags]?: Override\n  } & {\n    [customComponent: string]: Override\n  }\n\n  /**\n   * Compiler options\n   * @lang zh 编译器选项\n   * @lang hi कंपाइलर विकल्प\n   */\n  export type Options = Partial<{\n    /**\n     * Ultimate control over the output of all rendered JSX.\n     * @lang zh 对所有渲染的 JSX 输出的最终控制。\n     * @lang hi सभी रेंडर किए गए JSX आउटपुट पर अंतिम नियंत्रण।\n     */\n    createElement: (\n      tag: Parameters<CreateElement>[0],\n      props: React.JSX.IntrinsicAttributes,\n      ...children: React.ReactNode[]\n    ) => React.ReactNode\n\n    /**\n     * The library automatically generates an anchor tag for bare URLs included in the markdown\n     * document, but this behavior can be disabled if desired.\n     * @lang zh 库会自动为 Markdown 文档中包含的裸 URL 生成锚点标签，但可以根据需要禁用此行为。\n     * @lang hi लाइब्रेरी markdown दस्तावेज़ में शामिल नंगे URLs के लिए स्वचालित रूप से एक एंकर टैग जेनरेट करती है, लेकिन यदि वांछित हो तो इस व्यवहार को अक्षम किया जा सकता है।\n     */\n    disableAutoLink: boolean\n\n    /**\n     * Disable the compiler's best-effort transcription of provided raw HTML\n     * into JSX-equivalent. This is the functionality that prevents the need to\n     * use `dangerouslySetInnerHTML` in React.\n     * @lang zh 禁用编译器将提供的原始 HTML 转换为 JSX 等效项的最佳努力。此功能可避免在 React 中使用 `dangerouslySetInnerHTML`。\n     * @lang hi कंपाइलर के प्रदान किए गए raw HTML को JSX-समतुल्य में ट्रांसक्राइब करने के सर्वोत्तम प्रयास को अक्षम करें। यह वह कार्यक्षमता है जो React में `dangerouslySetInnerHTML` का उपयोग करने की आवश्यकता को रोकती है।\n     */\n    disableParsingRawHTML: boolean\n\n    /**\n     * Disable the compiler's parsing of HTML blocks.\n     * @lang zh 禁用编译器对 HTML 块的解析。\n     * @lang hi HTML ब्लॉक्स के कंपाइलर के पार्सिंग को अक्षम करें।\n     */\n    ignoreHTMLBlocks?: boolean\n\n    /**\n     * Enable GFM tagfilter extension to filter potentially dangerous HTML tags.\n     * When enabled, the following tags are escaped: title, textarea, style, xmp,\n     * iframe, noembed, noframes, script, plaintext.\n     * https://github.github.com/gfm/#disallowed-raw-html-extension-\n     * @lang zh 启用 GFM tagfilter 扩展以过滤潜在危险的 HTML 标签。启用后，以下标签将被转义：title、textarea、style、xmp、iframe、noembed、noframes、script、plaintext。\n     * @lang hi संभावित खतरनाक HTML टैग्स को फ़िल्टर करने के लिए GFM tagfilter एक्सटेंशन सक्षम करें। सक्षम होने पर, निम्नलिखित टैग्स एस्केप किए जाते हैं: title, textarea, style, xmp, iframe, noembed, noframes, script, plaintext।\n     * @default true\n     */\n    tagfilter?: boolean\n\n    /**\n     * Forces the compiler to have space between hash sign and the header text which\n     * is explicitly stated in the most of the markdown specs.\n     * https://github.github.com/gfm/#atx-heading\n     * `The opening sequence of # characters must be followed by a space or by the end of line.`\n     * @lang zh 强制编译器在井号和标题文本之间有空格，这在大多数 Markdown 规范中都有明确规定。\n     * @lang hi कंपाइलर को हैश चिह्न और हेडर टेक्स्ट के बीच स्थान रखने के लिए बाध्य करता है, जो अधिकांश markdown विनिर्देशों में स्पष्ट रूप से कहा गया है。\n     */\n    enforceAtxHeadings: boolean\n\n    /**\n     * **⚠️ SECURITY WARNING: STRONGLY DISCOURAGED FOR USER INPUTS**\n     *\n     * When enabled, attempts to eval expressions in JSX props that cannot be serialized\n     * as JSON (functions, variables, complex expressions). This uses `eval()` which can\n     * execute arbitrary code.\n     *\n     * **ONLY use this option when:**\n     * - The markdown source is completely trusted (e.g., your own documentation)\n     * - You control all JSX components and their props\n     * - The content is NOT user-generated or user-editable\n     *\n     * **DO NOT use this option when:**\n     * - Processing user-submitted markdown\n     * - Rendering untrusted content\n     * - Building public-facing applications with user content\n     *\n     * Example unsafe input: `<Component onClick={() => fetch('/admin/delete-all')} />`\n     *\n     * When disabled (default), unserializable expressions remain as strings that can be\n     * safely inspected or handled on a case-by-case basis via custom renderRule logic.\n     *\n     * @lang zh **⚠️ 安全警告：强烈建议不要用于用户输入**\n     *\n     * 启用后，尝试计算 JSX 属性中无法序列化为 JSON 的表达式（函数、变量、复杂表达式）。这使用 `eval()`，可能会执行任意代码。\n     *\n     * **仅在以下情况下使用此选项：**\n     * - Markdown 源完全可信（例如，您自己的文档）\n     * - 您控制所有 JSX 组件及其属性\n     * - 内容不是用户生成或用户可编辑的\n     *\n     * **在以下情况下不要使用此选项：**\n     * - 处理用户提交的 Markdown\n     * - 渲染不可信内容\n     * - 构建面向公众的用户内容应用程序\n     *\n     * 不安全的输入示例：`<Component onClick={() => fetch('/admin/delete-all')} />`\n     *\n     * 禁用时（默认），不可序列化的表达式保持为字符串，可以通过自定义 renderRule 逻辑安全地检查或逐例处理。\n     *\n     * @lang hi **⚠️ सुरक्षा चेतावनी: उपयोगकर्ता इनपुट के लिए अत्यधिक हतोत्साहित**\n     *\n     * सक्षम होने पर, JSX props में expressions को eval करने का प्रयास करता है जिन्हें JSON के रूप में सीरियलाइज़ नहीं किया जा सकता है (फ़ंक्शन, वेरिएबल, जटिल expressions)। यह `eval()` का उपयोग करता है जो मनमाने कोड को निष्पादित कर सकता है।\n     *\n     * **केवल निम्नलिखित स्थितियों में इस विकल्प का उपयोग करें:**\n     * - Markdown स्रोत पूरी तरह से विश्वसनीय है (उदाहरण के लिए, आपका अपना दस्तावेज़ीकरण)\n     * - आप सभी JSX कंपोनेंट्स और उनके props को नियंत्रित करते हैं\n     * - सामग्री उपयोगकर्ता-जनित या उपयोगकर्ता-संपादन योग्य नहीं है\n     *\n     * **निम्नलिखित स्थितियों में इस विकल्प का उपयोग न करें:**\n     * - उपयोगकर्ता-सबमिट किए गए markdown को प्रोसेस कर रहे हों\n     * - अविश्वसनीय सामग्री रेंडर कर रहे हों\n     * - उपयोगकर्ता सामग्री वाले सार्वजनिक-सामना करने वाले एप्लिकेशन बना रहे हों\n     *\n     * असुरक्षित इनपुट उदाहरण: `<Component onClick={() => fetch('/admin/delete-all')} />`\n     *\n     * अक्षम होने पर (डिफ़ॉल्ट), अनसीरियलाइज़ेबल expressions स्ट्रिंग्स के रूप में रहते हैं जिन्हें कस्टम renderRule लॉजिक के माध्यम से सुरक्षित रूप से जांचा जा सकता है या केस-बाई-केस हैंडल किया जा सकता है।\n     *\n     * @default false\n     */\n    evalUnserializableExpressions?: boolean\n\n    /**\n     * Forces the compiler to always output content with a block-level wrapper\n     * (`<p>` or any block-level syntax your markdown already contains.)\n     * @lang zh 强制编译器始终使用块级包装器输出内容（`<p>` 或您的 Markdown 已包含的任何块级语法）。\n     * @lang hi कंपाइलर को हमेशा ब्लॉक-स्तरीय रैपर के साथ सामग्री आउटपुट करने के लिए बाध्य करता है (`<p>` या आपके markdown में पहले से मौजूद कोई भी ब्लॉक-स्तरीय सिंटैक्स)।\n     */\n    forceBlock: boolean\n\n    /**\n     * Forces the compiler to always output content with an inline wrapper (`<span>`)\n     * @lang zh 强制编译器始终使用内联包装器（`<span>`）输出内容\n     * @lang hi कंपाइलर को हमेशा इनलाइन रैपर (`<span>`) के साथ सामग्री आउटपुट करने के लिए बाध्य करता है\n     */\n    forceInline: boolean\n\n    /**\n     * Forces the compiler to wrap results, even if there is only a single\n     * child or no children.\n     * @lang zh 强制编译器包装结果，即使只有一个子元素或没有子元素。\n     * @lang hi कंपाइलर को परिणामों को रैप करने के लिए बाध्य करता है, भले ही केवल एक चाइल्ड हो या कोई चाइल्ड न हो।\n     */\n    forceWrapper: boolean\n\n    /**\n     * Selectively control the output of particular HTML tags as they would be\n     * emitted by the compiler.\n     * @lang zh 选择性地控制特定 HTML 标签的输出，就像编译器会发出的一样。\n     * @lang hi चुनिंदा रूप से विशिष्ट HTML टैग्स के आउटपुट को नियंत्रित करें जैसा कि कंपाइलर द्वारा उत्सर्जित किया जाएगा।\n     */\n    overrides: Overrides\n\n    /**\n     * Allows for full control over rendering of particular rules.\n     * For example, to implement a LaTeX renderer such as `react-katex`:\n     *\n     * ```\n     * renderRule(next, node, renderChildren, state) {\n     *   if (node.type === RuleType.codeBlock && node.lang === 'latex') {\n     *     return (\n     *       <TeX as=\"div\" key={state.key}>\n     *         {String.raw`${node.text}`}\n     *       </TeX>\n     *     )\n     *   }\n     *\n     *   return next();\n     * }\n     * ```\n     *\n     * Thar be dragons obviously, but you can do a lot with this\n     * (have fun!) To see how things work internally, check the `render`\n     * method in source for a particular rule.\n     * @lang zh 允许完全控制特定规则的渲染。例如，要实现像 `react-katex` 这样的 LaTeX 渲染器：\n     *\n     * 显然有风险，但您可以用它做很多事情（玩得开心！）要了解内部工作原理，请查看源代码中特定规则的 `render` 方法。\n     * @lang hi विशिष्ट नियमों के रेंडरिंग पर पूर्ण नियंत्रण की अनुमति देता है। उदाहरण के लिए, `react-katex` जैसे LaTeX रेंडरर को लागू करने के लिए:\n     *\n     * स्पष्ट रूप से जोखिम हैं, लेकिन आप इसके साथ बहुत कुछ कर सकते हैं (मज़े करें!) आंतरिक रूप से चीजें कैसे काम करती हैं यह देखने के लिए, किसी विशिष्ट नियम के लिए स्रोत में `render` विधि देखें।\n     */\n    renderRule: (\n      /** Resume normal processing, call this function as a fallback if you are not returning custom JSX. */\n      /** @lang zh 恢复正常处理，如果您不返回自定义 JSX，请调用此函数作为后备。 */\n      /** @lang hi सामान्य प्रोसेसिंग फिर से शुरू करें, यदि आप कस्टम JSX वापस नहीं कर रहे हैं तो इस फ़ंक्शन को फ़ॉलबैक के रूप में कॉल करें। */\n      next: () => React.ReactNode,\n      /** the current AST node, use `RuleType` against `node.type` for identification */\n      /** @lang zh 当前的 AST 节点，使用 `RuleType` 与 `node.type` 进行比较以进行识别 */\n      /** @lang hi वर्तमान AST नोड, पहचान के लिए `node.type` के खिलाफ `RuleType` का उपयोग करें */\n      node: ASTNode,\n      /** use as `renderChildren(node.children)` for block nodes */\n      /** @lang zh 对于块节点，使用 `renderChildren(node.children)` */\n      /** @lang hi ब्लॉक नोड्स के लिए `renderChildren(node.children)` के रूप में उपयोग करें */\n      renderChildren: ASTRender,\n      /** contains `key` which should be supplied to the topmost JSX element */\n      /** @lang zh 包含应提供给最顶层 JSX 元素的 `key` */\n      /** @lang hi `key` शामिल है जो सबसे ऊपरी JSX एलिमेंट को प्रदान किया जाना चाहिए */\n      state: State\n    ) => React.ReactNode\n\n    /**\n     * Override the built-in sanitizer function for URLs, etc if desired. The built-in version is available as a library\n     export called `sanitizer`.\n     * @lang zh 如果需要，覆盖内置的 URL 清理函数等。内置版本可作为名为 `sanitizer` 的库导出使用。\n     * @lang hi यदि वांछित हो तो URLs आदि के लिए बिल्ट-इन सैनिटाइज़र फ़ंक्शन को ओवरराइड करें। बिल्ट-इन संस्करण `sanitizer` नामक लाइब्रेरी export के रूप में उपलब्ध है।\n     */\n    sanitizer: (value: string, tag: string, attribute: string) => string | null\n\n    /**\n     * Override normalization of non-URI-safe characters for use in generating\n     * HTML IDs for anchor linking purposes.\n     * @lang zh 覆盖非 URI 安全字符的规范化，用于生成用于锚点链接的 HTML ID。\n     * @lang hi एंकर लिंकिंग उद्देश्यों के लिए HTML IDs जेनरेट करने में उपयोग के लिए गैर-URI-सुरक्षित वर्णों के सामान्यीकरण को ओवरराइड करें।\n     */\n    slugify: (input: string, defaultFn: (input: string) => string) => string\n\n    /**\n     * Declare the type of the wrapper to be used when there are multiple\n     * children to render. Set to `null` to get an array of children back\n     * without any wrapper, or use `React.Fragment` to get a React element\n     * that won't show up in the DOM.\n     * @lang zh 声明在有多个子元素要渲染时使用的包装器类型。设置为 `null` 以在没有包装器的情况下返回子元素数组，或使用 `React.Fragment` 获取不会出现在 DOM 中的 React 元素。\n     * @lang hi रैपर के प्रकार को घोषित करें जब कई children को रेंडर करना हो। बिना किसी रैपर के children की एक सरणी वापस पाने के लिए `null` पर सेट करें, या DOM में दिखाई न देने वाला React एलिमेंट प्राप्त करने के लिए `React.Fragment` का उपयोग करें।\n     */\n    wrapper: React.ElementType | null\n\n    /**\n     * Props to apply to the wrapper element.\n     * @lang zh 应用于包装元素的属性。\n     * @lang hi रैपर एलिमेंट पर लागू करने के लिए props।\n     */\n    wrapperProps?: React.JSX.IntrinsicAttributes\n\n    /**\n     * Preserve frontmatter in the output by rendering it as a <pre> element.\n     * By default, frontmatter is parsed but not rendered.\n     * @lang zh 通过将其渲染为 <pre> 元素来保留输出中的前置元数据。默认情况下，前置元数据会被解析但不会渲染。\n     * @lang hi इसे <pre> एलिमेंट के रूप में रेंडर करके आउटपुट में फ्रंटमैटर को संरक्षित करें। डिफ़ॉल्ट रूप से, फ्रंटमैटर को पार्स किया जाता है लेकिन रेंडर नहीं किया जाता है।\n     * @default false\n     */\n    preserveFrontmatter?: boolean\n\n    /**\n     * Optimize rendering for streaming scenarios where markdown content arrives\n     * incrementally (e.g., from LLM APIs). When enabled, incomplete inline syntax\n     * is suppressed to avoid displaying raw markdown characters while waiting\n     * for the closing delimiter to arrive.\n     *\n     * Fenced code blocks render normally with content visible as it streams.\n     *\n     * @lang zh 优化流式场景下的渲染，适用于 Markdown 内容增量到达的情况（如 LLM API）。启用时，不完整的行内语法将被抑制，避免在等待闭合分隔符时显示原始 Markdown 字符。\n     *\n     * 围栏代码块正常渲染，内容在流式传输时可见。\n     *\n     * @lang hi स्ट्रीमिंग परिदृश्यों के लिए रेंडरिंग को अनुकूलित करता है जहाँ markdown सामग्री क्रमिक रूप से आती है (जैसे, LLM API से)। सक्षम होने पर, अपूर्ण इनलाइन सिंटैक्स को दबा दिया जाता है ताकि बंद करने वाले डेलिमीटर की प्रतीक्षा करते समय कच्चे markdown वर्ण प्रदर्शित न हों।\n     *\n     * फ़ेंस्ड कोड ब्लॉक्स सामान्य रूप से रेंडर होते हैं और स्ट्रीमिंग के दौरान सामग्री दिखाई देती है।\n     *\n     * @default false\n     *\n     * @example\n     * ```tsx\n     * // Streaming markdown example\n     * function StreamingMarkdown({ content }) {\n     *   return (\n     *     <Markdown options={{ optimizeForStreaming: true }}>\n     *       {content}\n     *     </Markdown>\n     *   )\n     * }\n     * ```\n     */\n    optimizeForStreaming?: boolean\n  }>\n}\n\nexport const RuleType: typeof RuleTypeConst = RuleTypeConst\nexport type RuleType = RuleTypeValue\n\nexport type RequireAtLeastOne<\n  T,\n  Keys extends keyof T = keyof T,\n> = MarkdownToJSX.RequireAtLeastOne<T, Keys>\n\nexport { MarkdownToJSX }\n",
    "import { NAMED_CODES_TO_UNICODE as util, decodeEntity } from 'markdown-to-jsx/entities'\nimport * as $ from './constants'\n\n/**\n * Parse frontmatter bounds and validate YAML\n *\n * @param input - Input string to parse\n * @returns Object with end position and YAML validity, or null if no frontmatter\n */\nexport function parseFrontmatterBounds(\n  input: string\n): { endPos: number; hasValidYaml: boolean } | null {\n  if (!startsWith(input, '---')) return null\n  let pos = 3\n  while (pos < input.length && (input[pos] === ' ' || input[pos] === '\\t'))\n    pos++\n  // Handle both LF and CRLF line endings\n  if (pos < input.length && input[pos] === '\\r') pos++\n  if (pos >= input.length || input[pos] !== '\\n') return null\n  pos++\n\n  let hasValidYaml = false\n  while (pos < input.length) {\n    const lineStart = pos\n    // Find line end, handling CRLF\n    while (pos < input.length && input[pos] !== '\\n' && input[pos] !== '\\r')\n      pos++\n    if (pos >= input.length) break\n    const lineEnd = pos\n    // Skip CR if present\n    if (input[pos] === '\\r') pos++\n    // Skip LF\n    if (pos < input.length && input[pos] === '\\n') pos++\n    if (startsWith(input, '---', lineStart))\n      return { endPos: pos, hasValidYaml }\n    // Check if line contains ':' anywhere\n    // OPTIMIZATION: Use indexOf directly to avoid slice allocation\n    const colonIndex = input.indexOf(':', lineStart)\n    if (colonIndex !== -1 && colonIndex < lineEnd) hasValidYaml = true\n  }\n  return null\n}\n\n/**\n * Named HTML entity codes to unicode character mapping\n * Pre-computed from generated entity set\n * Numeric references (&#123; and &#xAB;) are fully supported without any mapping.\n * Unknown named entities pass through as literal text (CommonMark-compliant).\n * @lang zh 命名的 HTML 实体代码到 Unicode 字符的映射\n * 从生成的实体集预计算\n * 数字引用（&#123; 和 &#xAB;）完全支持，无需映射。\n * 未知的命名实体作为字面文本传递（符合 CommonMark）。\n * @lang hi नामित HTML एंटिटी कोड से Unicode वर्णों का मैपिंग\n * जेनरेट किए गए एंटिटी सेट से पूर्व-गणना की गई\n * संख्यात्मक संदर्भ (&#123; और &#xAB;) बिना किसी मैपिंग के पूरी तरह से समर्थित हैं।\n * अज्ञात नामित एंटिटीज़ शाब्दिक टेक्स्ट के रूप में पास होती हैं (CommonMark-अनुरूप)।\n */\nexport const NAMED_CODES_TO_UNICODE: Record<string, string> = util\n\n/**\n * Regex for matching HTML character references (&entity; or &#123; or &#xAB;)\n * Matches: & followed by entity name or # followed by decimal or hex digits, ending with ;\n * @lang zh 用于匹配 HTML 字符引用的正则表达式（&entity; 或 &#123; 或 &#xAB;）\n * 匹配：& 后跟实体名称或 # 后跟十进制或十六进制数字，以 ; 结尾\n * @lang hi HTML वर्ण संदर्भों से मिलान करने के लिए रेगेक्स (&entity; या &#123; या &#xAB;)\n * मैच: & के बाद एंटिटी नाम या # के बाद दशमलव या हेक्स अंक, ; के साथ समाप्त होता है\n */\nexport const HTML_CHAR_CODE_R: RegExp =\n  /&([a-zA-Z0-9]+|#[0-9]{1,7}|#x[0-9a-fA-F]{1,6});/gi\n\n/**\n * Regex for determining if markdown content should be rendered as block-level\n * Matches: newlines, list items, headings, indented content, thematic breaks, blockquotes\n * @lang zh 用于确定 Markdown 内容是否应渲染为块级的正则表达式\n * 匹配：换行符、列表项、标题、缩进内容、分隔线、引用块\n * @lang hi यह निर्धारित करने के लिए रेगेक्स कि markdown सामग्री को ब्लॉक-स्तरीय के रूप में रेंडर किया जाना चाहिए\n * मैच: नई लाइनें, सूची आइटम्स, हेडिंग्स, इंडेंटेड सामग्री, थीमैटिक ब्रेक्स, ब्लॉककोट्स\n */\n// Mapping of lowercase HTML attributes to JSX prop names\n// Shared between React and Solid renderers (Vue uses HTML attributes directly)\nexport const HTML_TO_JSX_MAP: Record<string, string> = {\n  class: 'className',\n  for: 'htmlFor',\n  allowfullscreen: 'allowFullScreen',\n  allowtransparency: 'allowTransparency',\n  autocomplete: 'autoComplete',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  charset: 'charSet',\n  classid: 'classId',\n  colspan: 'colSpan',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  crossorigin: 'crossOrigin',\n  enctype: 'encType',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formmethod: 'formMethod',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  hreflang: 'hrefLang',\n  inputmode: 'inputMode',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  marginheight: 'marginHeight',\n  marginwidth: 'marginWidth',\n  maxlength: 'maxLength',\n  mediagroup: 'mediaGroup',\n  minlength: 'minLength',\n  novalidate: 'noValidate',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  rowspan: 'rowSpan',\n  spellcheck: 'spellCheck',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  tabindex: 'tabIndex',\n  usemap: 'useMap',\n  viewbox: 'viewBox',\n}\n\n/**\n * Convert HTML attributes to JSX props\n * Maps HTML attribute names (e.g., \"class\", \"for\") to JSX prop names (e.g., \"className\", \"htmlFor\")\n *\n * @param attrs - HTML attributes object\n * @returns JSX props object\n */\nexport function htmlAttrsToJSXProps(\n  attrs: Record<string, any>\n): Record<string, any> {\n  var jsxProps: Record<string, any> = {}\n\n  for (var key in attrs) {\n    var keyLower = key.toLowerCase()\n    var mappedKey = HTML_TO_JSX_MAP[keyLower]\n    if (mappedKey) {\n      jsxProps[mappedKey] = attrs[key]\n    } else {\n      var colonIdx = key.indexOf(':')\n      if (colonIdx !== -1) {\n        // xml:lang -> xmlLang, xlink:href -> xlinkHref\n        jsxProps[key.slice(0, colonIdx) + key[colonIdx + 1].toUpperCase() + key.slice(colonIdx + 2)] = attrs[key]\n      } else {\n        jsxProps[key] = attrs[key]\n      }\n    }\n  }\n\n  return jsxProps\n}\n\nexport const SHOULD_RENDER_AS_BLOCK_R: RegExp =\n  /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s|^<(div|p|h[1-6]|ul|ol|li|blockquote|pre|table|thead|tbody|tr|td|th|dl|dt|dd|hr|address|article|aside|details|dialog|figure|figcaption|footer|form|header|main|menu|nav|section|summary|textarea|fieldset|legend|center|dir|hgroup|marquee|search|output|template)\\b)/i\n\n/**\n * Decode HTML entity references to Unicode characters\n *\n * @param text - The text containing HTML entities\n * @returns The decoded text\n */\nexport function decodeEntityReferences(text: string): string {\n  if (text.indexOf('&') === -1) return text\n\n  return text.replace(HTML_CHAR_CODE_R, (full, inner) => {\n    // Named entity lookup via swappable decoder\n    // In browser builds, this uses DOM; in Node, uses lookup table\n    var entity = decodeEntity(inner)\n    if (entity) return entity\n\n    // Numeric entities (always computed, no lookup needed)\n    if (inner[0] === '#') {\n      var code =\n        inner[1] === 'x' || inner[1] === 'X'\n          ? parseInt(inner.slice(2), 16)\n          : parseInt(inner.slice(1), 10)\n\n      if (code === 0 || (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff) {\n        return '\\uFFFD'\n      }\n      return code <= 0xffff\n        ? String.fromCharCode(code)\n        : String.fromCharCode(\n            0xd800 + ((code - 0x10000) >> 10),\n            0xdc00 + ((code - 0x10000) & 0x3ff)\n          )\n    }\n\n    return full\n  })\n}\n\nexport const SANITIZE_R: RegExp = /(javascript|vbscript|data(?!:image)):/i\n\n/**\n * Sanitize URLs and other input values to prevent XSS attacks.\n * Filters out javascript:, vbscript:, and data: URLs (except data:image).\n *\n * @lang zh 清理 URL 和其他输入值以防止 XSS 攻击。过滤掉 javascript:、vbscript: 和 data: URL（data:image 除外）。\n * @lang hi XSS हमलों को रोकने के लिए URLs और अन्य इनपुट मानों को सैनिटाइज़ करता है। javascript:, vbscript:, और data: URLs को फ़िल्टर करता है (data:image को छोड़कर)।\n *\n * @param input - The URL or value to sanitize\n * @lang zh @param input - 要清理的 URL 或值\n * @lang hi @param input - सैनिटाइज़ करने के लिए URL या मान\n * @returns Sanitized value, or null if unsafe\n * @lang zh @returns 清理后的值，如果不安全则返回 null\n * @lang hi @returns सैनिटाइज़ किया गया मान, या असुरक्षित होने पर null\n */\nexport function sanitizer(input: string): string | null {\n  if (SANITIZE_R.test(input)) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\n        'Input contains an unsafe JavaScript/VBScript/data expression, it will not be rendered.',\n        input\n      )\n    }\n    return null\n  }\n\n  if (input.indexOf('%') === -1) return input\n\n  try {\n    const decoded = decodeURIComponent(input).replace(/[^A-Za-z0-9/:]/g, '')\n    if (SANITIZE_R.test(decoded)) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\n          'Input contains an unsafe JavaScript/VBScript/data expression, it will not be rendered.',\n          decoded\n        )\n      }\n      return null\n    }\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\n        'Input could not be decoded due to malformed syntax or characters, it will not be rendered.',\n        input\n      )\n    }\n    return null\n  }\n\n  return input\n}\n\n// Character replacement lookup table for slugify (Unicode to ASCII)\nvar slugifyReplaceTable: Record<number, string> = {}\nvar codes: number[], i: number\ncodes = [192, 193, 194, 195, 196, 197, 224, 225, 226, 227, 228, 229, 230, 198]\nfor (i = 0; i < codes.length; i++) slugifyReplaceTable[codes[i]] = 'a'\nslugifyReplaceTable[231] = slugifyReplaceTable[199] = 'c'\nslugifyReplaceTable[240] = slugifyReplaceTable[208] = 'd'\ncodes = [200, 201, 202, 203, 233, 232, 234, 235]\nfor (i = 0; i < codes.length; i++) slugifyReplaceTable[codes[i]] = 'e'\ncodes = [207, 239, 206, 238, 205, 237, 204, 236]\nfor (i = 0; i < codes.length; i++) slugifyReplaceTable[codes[i]] = 'i'\nslugifyReplaceTable[209] = slugifyReplaceTable[241] = 'n'\ncodes = [248, 216, 339, 338, 213, 245, 212, 244, 211, 243, 210, 242]\nfor (i = 0; i < codes.length; i++) slugifyReplaceTable[codes[i]] = 'o'\ncodes = [220, 252, 219, 251, 218, 250, 217, 249]\nfor (i = 0; i < codes.length; i++) slugifyReplaceTable[codes[i]] = 'u'\nslugifyReplaceTable[376] =\n  slugifyReplaceTable[255] =\n  slugifyReplaceTable[221] =\n  slugifyReplaceTable[253] =\n    'y'\n\n/**\n * Check if a character code is alphanumeric (0-9, A-Z, a-z)\n * Uses optimized table lookup for ASCII characters\n *\n * @param code - Character code to check\n * @returns True if alphanumeric\n */\nexport function isAlnumCode(code: number): boolean {\n  return code < $.CHAR_ASCII_BOUNDARY && (charClassTable[code] & (CC_ALPHA | CC_DIGIT)) !== 0\n}\n\n/**\n * Convert a string to a URL-safe slug by normalizing characters and replacing spaces with hyphens.\n * Based on https://stackoverflow.com/a/18123682/1141611\n * Not complete, but probably good enough.\n *\n * @lang zh 通过规范化字符并用连字符替换空格，将字符串转换为 URL 安全的别名。不完整，但可能足够好。\n * @lang hi वर्णों को सामान्यीकृत करके और रिक्त स्थान को हाइफ़न से बदलकर स्ट्रिंग को URL-सुरक्षित slug में बदलता है। पूर्ण नहीं है, लेकिन शायद पर्याप्त है।\n *\n * @param str - String to slugify\n * @lang zh @param str - 要转换为别名的字符串\n * @lang hi @param str - slugify करने के लिए स्ट्रिंग\n * @returns URL-safe slug\n * @lang zh @returns URL 安全的别名\n * @lang hi @returns URL-सुरक्षित slug\n */\nexport function slugify(str: string): string {\n  var out = ''\n  var segStart = -1\n  for (var i = 0; i < str.length; i++) {\n    var code = str.charCodeAt(i)\n    if (isAlnumCode(code)) {\n      if (code >= $.CHAR_A && code <= $.CHAR_Z) {\n        // Uppercase: flush segment, emit lowercase char\n        if (segStart >= 0) {\n          out += str.slice(segStart, i)\n          segStart = -1\n        }\n        out += String.fromCharCode(code + $.CHAR_CASE_OFFSET)\n      } else {\n        // Lowercase alnum: extend current segment\n        if (segStart < 0) segStart = i\n      }\n    } else if (code === $.CHAR_SPACE || code === $.CHAR_DASH) {\n      if (segStart >= 0) {\n        out += str.slice(segStart, i)\n        segStart = -1\n      }\n      out += '-'\n    } else {\n      if (segStart >= 0) {\n        out += str.slice(segStart, i)\n        segStart = -1\n      }\n      var replacement = slugifyReplaceTable[code]\n      if (replacement) out += replacement\n    }\n  }\n  if (segStart >= 0) out += str.slice(segStart)\n  return out\n}\n\n/**\n * Check if a string starts with a prefix\n *\n * @param str - String to check\n * @param prefix - Prefix to check for\n * @param pos - Optional starting position\n * @returns True if string starts with prefix\n */\nexport function startsWith(str: string, prefix: string, pos?: number): boolean {\n  return str.startsWith(prefix, pos)\n}\n\n/**\n * Check if a string ends with a suffix\n *\n * @param str - String to check\n * @param suffix - Suffix to check for\n * @param pos - Optional ending position\n * @returns True if string ends with suffix\n */\nexport function endsWith(str: string, suffix: string, pos?: number): boolean {\n  return str.startsWith(\n    suffix,\n    (pos === undefined ? str.length : pos) - suffix.length\n  )\n}\n\n// Known void elements (HTML5 and SVG) that don't require closing tag or />\n// Use Set for O(1) lookups instead of O(n) array.includes()\nexport const VOID_ELEMENTS: Set<string> = new Set([\n  // HTML5 void elements\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n  // SVG void elements\n  'circle',\n  'ellipse',\n  'line',\n  'path',\n  'polygon',\n  'polyline',\n  'rect',\n  'use',\n  'stop',\n  'animate',\n  'set',\n])\n\n/**\n * Check if an element is a void element (doesn't require closing tag)\n *\n * @param tagName - HTML tag name\n * @returns True if void element\n */\nexport function isVoidElement(tagName: string): boolean {\n  let lowerTag = tagName.toLowerCase()\n  if (VOID_ELEMENTS.has(lowerTag)) return true\n  // Handle SVG namespace prefixes like svg:circle\n  const colonIndex = lowerTag.indexOf(':')\n  if (colonIndex !== -1) {\n    lowerTag = lowerTag.slice(colonIndex + 1)\n    return VOID_ELEMENTS.has(lowerTag)\n  }\n  return false\n}\n\n/** Attributes that should be sanitized for security */\nexport const ATTRIBUTES_TO_SANITIZE: readonly string[] = [\n  'src',\n  'href',\n  'data',\n  'formAction',\n  'srcDoc',\n  'action',\n]\n\n// Character classification flags (bitfield) - optimized for fast lookup\n// These flags allow multiple classifications per character with bitwise AND/OR\nexport const CC_WHITESPACE = 1 // space, tab, newline, cr, ff\nexport const CC_PUNCTUATION = 2 // punctuation characters\nexport const CC_ALPHA = 4 // a-z, A-Z\nexport const CC_DIGIT = 8 // 0-9\nexport const CC_NEWLINE = 16 // \\n, \\r\nexport const CC_SPACE_TAB = 32 // space or tab only\nexport const CC_ALPHA_UPPER = 64 // A-Z only\n\n// Inline character type constants\n// const INLINE_CHAR_TYPE_NORMAL = 0\nconst INLINE_CHAR_TYPE_SPECIAL = 1\nconst INLINE_CHAR_TYPE_ESCAPE = 2\nconst INLINE_CHAR_TYPE_DELIMITER = 3\nconst INLINE_CHAR_TYPE_LINK = 4\n\n// Lookup table for ASCII characters (0-127)\n// Combines multiple flags for efficient multi-purpose lookup\nexport const charClassTable: Uint8Array = (function () {\n  const t = new Uint8Array(128)\n  let i\n  // Whitespace characters\n  t[$.CHAR_TAB] = CC_WHITESPACE | CC_SPACE_TAB\n  t[$.CHAR_NEWLINE] = CC_WHITESPACE | CC_NEWLINE\n  t[$.CHAR_FF] = CC_WHITESPACE\n  t[$.CHAR_CR] = CC_WHITESPACE | CC_NEWLINE\n  t[$.CHAR_SPACE] = CC_WHITESPACE | CC_SPACE_TAB\n  // Punctuation ranges\n  for (i = $.CHAR_EXCLAMATION; i <= $.CHAR_SLASH; i++) t[i] = CC_PUNCTUATION\n  for (i = $.CHAR_COLON; i <= $.CHAR_AT; i++) t[i] = CC_PUNCTUATION\n  for (i = $.CHAR_BRACKET_OPEN; i <= $.CHAR_BACKTICK; i++)\n    t[i] = CC_PUNCTUATION\n  for (i = $.CHAR_BRACE_OPEN; i <= $.CHAR_TILDE; i++) t[i] = CC_PUNCTUATION\n  // Digits 0-9\n  for (i = $.CHAR_DIGIT_0; i <= $.CHAR_DIGIT_9; i++) t[i] = CC_DIGIT\n  // Uppercase letters A-Z\n  for (i = $.CHAR_A; i <= $.CHAR_Z; i++) t[i] = CC_ALPHA | CC_ALPHA_UPPER\n  // Lowercase letters a-z\n  for (i = $.CHAR_a; i <= $.CHAR_z; i++) t[i] = CC_ALPHA\n  return t\n})()\n\n// Lookup table for inline character types (0-127): 0=normal, 1=special, 2=escape, 3=delimiter, 4=link\nexport const inlineCharTypeTable: Uint8Array = (function () {\n  const t = new Uint8Array(128)\n  t[$.CHAR_BACKSLASH] = INLINE_CHAR_TYPE_ESCAPE\n  t[$.CHAR_BRACKET_OPEN] = INLINE_CHAR_TYPE_LINK\n  t[$.CHAR_ASTERISK] =\n    t[$.CHAR_UNDERSCORE] =\n    t[$.CHAR_TILDE] =\n    t[$.CHAR_EQ] =\n      INLINE_CHAR_TYPE_DELIMITER\n  t[$.CHAR_BACKTICK] =\n    t[$.CHAR_LT] =\n    t[$.CHAR_AT] =\n    t[$.CHAR_BRACKET_CLOSE] =\n    t[$.CHAR_NEWLINE] =\n    t[$.CHAR_SPACE] =\n    t[$.CHAR_EXCLAMATION] =\n      INLINE_CHAR_TYPE_SPECIAL\n  t[$.CHAR_f] = t[$.CHAR_H] = t[$.CHAR_W] = INLINE_CHAR_TYPE_SPECIAL\n  return t\n})()\n\nexport function isASCIIPunctuation(code: number): boolean {\n  return (\n    code < $.CHAR_ASCII_BOUNDARY &&\n    (charClassTable[code] & CC_PUNCTUATION) !== 0\n  )\n}\n\nexport function isASCIIWhitespace(code: number): boolean {\n  return (\n    code < $.CHAR_ASCII_BOUNDARY &&\n    (charClassTable[code] & CC_WHITESPACE) !== 0\n  )\n}\n\n// Fast check for space or tab only (not newlines)\nexport function isSpaceOrTabCode(code: number): boolean {\n  return code < $.CHAR_ASCII_BOUNDARY && (charClassTable[code] & CC_SPACE_TAB) !== 0\n}\n\n// Fast check for alpha (a-z, A-Z)\nexport function isAlphaCode(code: number): boolean {\n  return code < $.CHAR_ASCII_BOUNDARY && (charClassTable[code] & CC_ALPHA) !== 0\n}\n\n// Fast check for digit (0-9)\nexport function isDigitCode(code: number): boolean {\n  return code < $.CHAR_ASCII_BOUNDARY && (charClassTable[code] & CC_DIGIT) !== 0\n}\n\n// Unicode property escapes for spec-compliant character classification\n// Per GFM spec Section 2.1: \"A punctuation character is a character in the general Unicode categories\n// Pc, Pd, Pe, Pf, Pi, Po, or Ps\" - this is \\p{P}\n// BUT also includes some currency symbols and other symbols per the spec's explicit list\nconst UNICODE_PUNCT_R = /[\\p{P}\\p{S}]/u\nconst UNICODE_WHITESPACE_R = /\\p{Zs}/u\n\nexport function isUnicodeWhitespace(c: string): boolean {\n  if (!c) return true\n  const code = c.charCodeAt(0)\n  return code < $.CHAR_ASCII_BOUNDARY\n    ? (charClassTable[code] & CC_WHITESPACE) !== 0\n    : UNICODE_WHITESPACE_R.test(c)\n}\n\nexport function isUnicodePunctuation(c: string | number): boolean {\n  if (typeof c === 'number')\n    return (\n      c < $.CHAR_ASCII_BOUNDARY && (charClassTable[c] & CC_PUNCTUATION) !== 0\n    )\n  if (!c) return false\n  const code = c.charCodeAt(0)\n  return code < $.CHAR_ASCII_BOUNDARY\n    ? (charClassTable[code] & CC_PUNCTUATION) !== 0\n    : UNICODE_PUNCT_R.test(c)\n}\n\n/**\n * Find the end of the current line\n * Optimized: Pure indexOf is faster than hybrid approach - JS engine optimizes it better\n * Handles CRLF by returning position before \\r when followed by \\n\n */\nexport function findLineEnd(source: string, startPos: number): number {\n  const newlinePos = source.indexOf('\\n', startPos)\n  if (newlinePos === -1) return source.length\n  if (newlinePos > 0 && source.charCodeAt(newlinePos - 1) === $.CHAR_CR) {\n    return newlinePos - 1\n  }\n  return newlinePos\n}\n\nvar crlfParts: string[] = []\n\n/**\n * Normalize input text for parsing:\n * - Replace CRLF and CR line endings with LF\n * - Replace null bytes (U+0000) with replacement character (U+FFFD) per CommonMark spec\n * Returns original string if no transformations needed (fast path)\n */\nexport function normalizeInput(text: string): string {\n  var firstCR = text.indexOf('\\r')\n  var firstNull = text.indexOf('\\x00')\n\n  if (firstCR === -1 && firstNull === -1) return text\n\n  var len = text.length\n  crlfParts.length = 0\n  var start = 0\n  var i = 0\n\n  if (firstCR === -1) {\n    i = firstNull\n  } else if (firstNull === -1) {\n    i = firstCR\n  } else {\n    i = firstCR < firstNull ? firstCR : firstNull\n  }\n\n  for (; i < len; i++) {\n    var code = text.charCodeAt(i)\n    if (code === $.CHAR_CR) {\n      if (start < i) crlfParts.push(text.slice(start, i))\n      if (i + 1 < len && text.charCodeAt(i + 1) === $.CHAR_NEWLINE) {\n        i++\n      }\n      crlfParts.push('\\n')\n      start = i + 1\n    } else if (code === 0) {\n      if (start < i) crlfParts.push(text.slice(start, i))\n      crlfParts.push('\\uFFFD')\n      start = i + 1\n    }\n  }\n  if (start < len) crlfParts.push(text.slice(start))\n  return crlfParts.join('')\n}\n\n/**\n * Skip whitespace characters\n */\nexport function skipWhitespace(\n  source: string,\n  pos: number,\n  maxPos?: number\n): number {\n  const end = maxPos ?? source.length\n  while (pos < end && (source[pos] === ' ' || source[pos] === '\\t')) pos++\n  return pos\n}\n\n/**\n * Fast check if object has any enumerable properties\n * Optimized alternative to Object.keys(obj).length > 0\n */\nexport function hasKeys(obj: Record<string, any> | null | undefined): boolean {\n  if (!obj) return false\n  for (var key in obj) {\n    return true\n  }\n  return false\n}\n\n/**\n * Extract plain text from AST nodes (for image alt text, heading slugs, etc.)\n * Shared between JSX and HTML renderers\n */\n/**\n * Get nested property from object using dot notation path\n */\nexport function get(source: any, path: string, fallback: any): any {\n  var result = source\n  var segments = path.split('.')\n  var i = 0\n  while (i < segments.length) {\n    result = result?.[segments[i]]\n    if (result === undefined) break\n    i++\n  }\n  return result || fallback\n}\n\n/**\n * Encode special characters in URL targets for safe rendering.\n * Preserves existing percent-encoded sequences, encodes backslash/backtick,\n * and percent-encodes non-ASCII characters.\n */\nexport function encodeUrlTarget(target: string): string {\n  // Fast path: skip encoding if URL contains only safe characters\n  // encodeURI encodes: control chars (0-31), space, \", %, <, >, [, \\, ], ^, `, {, |, }, DEL, non-ASCII\n  var needsEncoding = false\n  for (var i = 0; i < target.length; i++) {\n    var code = target.charCodeAt(i)\n    if (code <= $.CHAR_SPACE || code === $.CHAR_DOUBLE_QUOTE || code === $.CHAR_PERCENT ||\n        code === $.CHAR_LT || code === $.CHAR_GT || code === $.CHAR_BRACKET_OPEN ||\n        code === $.CHAR_BACKSLASH || code === $.CHAR_BRACKET_CLOSE || code === $.CHAR_CARET ||\n        code === $.CHAR_BACKTICK || code >= 123) {\n      needsEncoding = true\n      break\n    }\n  }\n  if (!needsEncoding) return target\n\n  var result = ''\n  for (var i = 0; i < target.length; i++) {\n    var code = target.charCodeAt(i)\n    if (code === $.CHAR_PERCENT && i + 2 < target.length) {\n      var c1 = target.charCodeAt(i + 1)\n      var c2 = target.charCodeAt(i + 2)\n      if (\n        ((c1 >= $.CHAR_DIGIT_0 && c1 <= $.CHAR_DIGIT_9) || (c1 >= $.CHAR_A && c1 <= $.CHAR_F) || (c1 >= $.CHAR_a && c1 <= $.CHAR_f)) &&\n        ((c2 >= $.CHAR_DIGIT_0 && c2 <= $.CHAR_DIGIT_9) || (c2 >= $.CHAR_A && c2 <= $.CHAR_F) || (c2 >= $.CHAR_a && c2 <= $.CHAR_f))\n      ) {\n        result += target[i] + target[i + 1] + target[i + 2]\n        i += 2\n        continue\n      }\n    }\n    result += encodeURI(target[i])\n  }\n  return result\n}\n\n/** Concatenate class names, filtering falsy values */\nexport function cx(...args: (string | undefined | null | false)[]): string {\n  return args.filter(Boolean).join(' ')\n}\n\n/**\n * Get tag name from override object, supporting both string and component object overrides\n */\nexport function getTag<\n  T extends string | { component?: string; props?: Record<string, any> },\n>(tag: string, overrides?: Record<string, T>): string {\n  if (!overrides) return tag\n  const override = get(overrides, tag, undefined)\n  if (typeof override === 'string') return override\n  if (typeof override === 'object' && override.component)\n    return override.component\n  return tag\n}\n\n/**\n * Get override props from override object\n */\nexport function getOverrideProps<\n  T extends string | { component?: string; props?: Record<string, any> },\n>(\n  tag: string,\n  overrides?: Record<string, T>\n): Record<string, string | number | boolean> {\n  if (!overrides) return {}\n  const override = get(overrides, tag, undefined)\n  return typeof override === 'object' && override.props ? override.props : {}\n}\n\nexport function extractPlainText(nodes: Array<any>, RuleType: any): string {\n  var result = ''\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    var node = nodes[i],\n      type = node.type\n    if (type === RuleType.text || type === RuleType.codeInline) {\n      var text = node.text\n      if (text) result += text\n    } else if (type === RuleType.textFormatted || type === RuleType.link) {\n      if (node.children) result += extractPlainText(node.children, RuleType)\n    } else if (type === RuleType.image) {\n      if (node.alt) {\n        result += node.alt\n      }\n    }\n  }\n  return result\n}\n\n/** GFM tagfilter extension — security-sensitive tags whose `<` gets escaped */\nvar TAGFILTER_TAGS = new Set([\n  'title', 'textarea', 'style', 'xmp', 'iframe', 'noembed', 'noframes', 'script', 'plaintext'\n])\n\n/** Matches tagfilter tags in raw HTML text (opening/closing) */\nvar TAGFILTER_R = /<(\\/?)(title|textarea|style|xmp|iframe|noembed|noframes|script|plaintext)(\\s|>|\\/)/gi\n\n/**\n * Check if tag should be filtered per GFM tagfilter extension\n */\nexport function shouldFilterTag(tagName: string): boolean {\n  return TAGFILTER_TAGS.has(tagName.toLowerCase())\n}\n\n/** Test if text contains any tagfilter tags */\nexport function containsTagfilterTag(text: string): boolean {\n  TAGFILTER_R.lastIndex = 0\n  return TAGFILTER_R.test(text)\n}\n\n/**\n * Apply tagfilter to text content - escape dangerous tags\n */\nexport function applyTagFilterToText(text: string): string {\n  TAGFILTER_R.lastIndex = 0\n  return text.replace(\n    TAGFILTER_R,\n    function (match, slash, tagName, after) {\n      return '&lt;' + slash + tagName + after\n    }\n  )\n}\n\n",
    "/**\n * Compact Table-Driven Markdown Parser\n *\n * This parser uses tables and generic scanners instead of specialized functions\n * to achieve dramatic code size reduction while maintaining CommonMark compliance.\n */\n\nimport { RuleType, type MarkdownToJSX } from './types'\nimport * as $ from './constants'\nimport * as util from './utils'\n\n// ============================================================================\n// EXPORTS FOR REACT.TSX COMPATIBILITY\n// ============================================================================\n\n// Type export\nexport type ParseOptions = Omit<MarkdownToJSX.Options, 'slugify'> & {\n  slugify: (input: string) => string\n  sanitizer: (tag: string, attr: string, value: string) => string | null\n  tagfilter?: boolean\n  forceBlock?: boolean\n  streaming?: boolean\n  inList?: boolean\n  inHTML?: boolean\n  disableBareUrls?: boolean\n}\n\n/** HTMLCommentNode with endsWithGreaterThan flag for empty/special comments */\ntype HTMLCommentNodeExt = MarkdownToJSX.HTMLCommentNode & { endsWithGreaterThan: boolean }\n\n/** Union of AST nodes that have a children array */\ntype ASTNodeWithChildren = Extract<MarkdownToJSX.ASTNode, { children: MarkdownToJSX.ASTNode[] }>\n\n// Regex exports\nexport const HTML_BLOCK_ELEMENT_START_R_ATTR: RegExp =\n  /^<([a-zA-Z][a-zA-Z0-9-]*)\\s[^>]*>/\nexport const UPPERCASE_TAG_R: RegExp = /^<[A-Z]/\n// HTML Type 1 tags (raw HTML blocks) — CommonMark §4.6\nvar TYPE1_TAG_LIST = ['script', 'pre', 'style', 'textarea']\nvar TYPE1_TAGS = new Set(TYPE1_TAG_LIST)\n\n/** Matches Type 1 tags in raw HTML text */\nvar TYPE1_R = /<(?:pre|script|style|textarea)\\b/i\n\n// Table-related tags excluded from type 6/7 block extension across blank lines\nvar TABLE_TAGS = new Set([\n  'table', 'thead', 'tbody', 'tfoot', 'tr', 'td', 'th'\n])\n\n// Inline special character lookup — true for chars that need processing in parseInline\n// ` * _ ~ = [ ! < \\ h w f \\u001F (and alphanumeric for email near @)\nvar INLINE_SPECIAL = new Uint8Array(128)\n;(function() {\n  // Characters that trigger inline scanners\n  var specials = [$.CHAR_BACKTICK, $.CHAR_ASTERISK, $.CHAR_UNDERSCORE, $.CHAR_TILDE, $.CHAR_EQ, $.CHAR_BRACKET_OPEN, $.CHAR_EXCLAMATION, $.CHAR_LT, $.CHAR_BACKSLASH, $.CHAR_UNIT_SEP, $.CHAR_H, $.CHAR_W, $.CHAR_f]\n  for (var si = 0; si < specials.length; si++) INLINE_SPECIAL[specials[si]] = 1\n})()\n\n// Fenced code block attribute regex (hoisted to avoid per-fence allocation)\nvar FENCE_ATTR_R = /([a-zA-Z_][a-zA-Z0-9_-]*)=(?:\"([^\"]*)\"|'([^']*)')/g\n\nexport function isType1Block(tagLower: string): boolean {\n  return TYPE1_TAGS.has(tagLower)\n}\n\n/** Test if text contains any Type 1 block tags */\nexport function containsType1Tag(text: string): boolean {\n  return TYPE1_R.test(text)\n}\n\n/**\n * Validate a table delimiter row without regex (avoids ReDoS from nested\n * quantifiers). Accepts: |? WS? :?-+:? WS? (| WS? :?-+:? WS?)* |? WS?\n * Single linear pass — O(n) guaranteed.\n */\nfunction isDelimiterRow(s: string, start: number, end: number): boolean {\n  var i = start, len = end\n  // skip leading whitespace\n  while (i < len && (s.charCodeAt(i) === $.CHAR_SPACE || s.charCodeAt(i) === $.CHAR_TAB)) i++\n  if (i >= len) return false\n  // optional leading pipe\n  if (s.charCodeAt(i) === $.CHAR_PIPE) i++\n  var cellCount = 0\n  while (i < len) {\n    // skip whitespace before cell\n    while (i < len && (s.charCodeAt(i) === $.CHAR_SPACE || s.charCodeAt(i) === $.CHAR_TAB)) i++\n    if (i >= len) break\n    // trailing pipe with only whitespace after — done\n    if (s.charCodeAt(i) === $.CHAR_PIPE && cellCount > 0) {\n      // check rest is whitespace\n      var j = i + 1\n      while (j < len && (s.charCodeAt(j) === $.CHAR_SPACE || s.charCodeAt(j) === $.CHAR_TAB)) j++\n      if (j >= len) return true\n      // not trailing — fall through to parse another cell\n    }\n    // optional leading colon\n    if (s.charCodeAt(i) === $.CHAR_COLON) i++\n    // require at least one dash\n    if (i >= len || s.charCodeAt(i) !== $.CHAR_DASH) return false\n    while (i < len && s.charCodeAt(i) === $.CHAR_DASH) i++\n    // optional trailing colon\n    if (i < len && s.charCodeAt(i) === $.CHAR_COLON) i++\n    cellCount++\n    // skip whitespace after cell\n    while (i < len && (s.charCodeAt(i) === $.CHAR_SPACE || s.charCodeAt(i) === $.CHAR_TAB)) i++\n    // pipe separator or end\n    if (i < len) {\n      if (s.charCodeAt(i) === $.CHAR_PIPE) {\n        i++ // consume pipe\n      } else {\n        return false // unexpected character\n      }\n    }\n  }\n  return cellCount > 0\n}\n\n// Parse an HTML tag at position\nexport function __parseHTMLTag(\n  source: string,\n  pos: number\n): {\n  tag: string\n  attrs: Record<string, string>\n  selfClosing: boolean\n  end: number\n  rawAttrs: string\n  whitespaceBeforeAttrs: string\n  isClosing: boolean\n  hasSpaceBeforeSlash: boolean\n} | null {\n  if (source.charCodeAt(pos) !== $.CHAR_LT) return null // <\n\n  let i = pos + 1\n  const len = source.length\n\n  let isClosing = false\n  if (source.charCodeAt(i) === $.CHAR_SLASH) { // /\n    i++\n    isClosing = true\n  }\n\n  const nameStart = i\n  const first = source.charCodeAt(i)\n  if (!((first >= $.CHAR_a && first <= $.CHAR_z) || (first >= $.CHAR_A && first <= $.CHAR_Z))) return null\n\n  while (i < len && ((source.charCodeAt(i) >= $.CHAR_a && source.charCodeAt(i) <= $.CHAR_z) || (source.charCodeAt(i) >= $.CHAR_A && source.charCodeAt(i) <= $.CHAR_Z) || (source.charCodeAt(i) >= $.CHAR_DIGIT_0 && source.charCodeAt(i) <= $.CHAR_DIGIT_9) || source.charCodeAt(i) === $.CHAR_DASH)) i++\n  const tag = source.slice(nameStart, i)\n  if (!tag) return null\n\n  const wsStart = i\n  while (i < len && (source.charCodeAt(i) === $.CHAR_SPACE || source.charCodeAt(i) === $.CHAR_TAB || source.charCodeAt(i) === $.CHAR_NEWLINE)) i++\n  const whitespaceBeforeAttrs = source.slice(wsStart, i)\n  // After tag name, must have whitespace before attributes, or > or />\n  if (i === wsStart && i < len) {\n    var nextC = source.charCodeAt(i)\n    if (nextC !== $.CHAR_GT && nextC !== $.CHAR_SLASH) return null // not > or /\n  }\n  const attrStartPos = i\n  const attrs: Record<string, string> = {}\n  let hasSpaceBeforeSlash = false\n\n  while (i < len) {\n    const c = source.charCodeAt(i)\n    if (c === $.CHAR_GT) { // >\n      const rawAttrs = source.slice(attrStartPos, i)\n      return { tag, attrs, selfClosing: false, end: i + 1, rawAttrs, whitespaceBeforeAttrs, isClosing, hasSpaceBeforeSlash }\n    }\n    if (c === $.CHAR_SPACE || c === $.CHAR_TAB || c === $.CHAR_NEWLINE) {\n      i++\n      continue\n    }\n    if (c === $.CHAR_SLASH && i + 1 < len && source.charCodeAt(i + 1) === $.CHAR_GT) { // />\n      const rawAttrs = source.slice(attrStartPos, i)\n      hasSpaceBeforeSlash = i > attrStartPos && source.charCodeAt(i - 1) === $.CHAR_SPACE\n      return { tag, attrs, selfClosing: true, end: i + 2, rawAttrs, whitespaceBeforeAttrs, isClosing, hasSpaceBeforeSlash }\n    }\n\n    // Parse attribute name per CommonMark: [a-zA-Z_:][a-zA-Z0-9_.:-]*\n    // Parse attribute name per CommonMark: [a-zA-Z_:][a-zA-Z0-9_.:-]*\n    var attrStart = i\n    var fc = source.charCodeAt(i)\n    if (!((fc >= $.CHAR_a && fc <= $.CHAR_z) || (fc >= $.CHAR_A && fc <= $.CHAR_Z) || fc === $.CHAR_UNDERSCORE || fc === $.CHAR_COLON)) {\n      // Invalid attribute name start character - invalid tag\n      return null\n    }\n    i++\n    while (i < len) {\n      var ac = source.charCodeAt(i)\n      if ((ac >= $.CHAR_a && ac <= $.CHAR_z) || (ac >= $.CHAR_A && ac <= $.CHAR_Z) || (ac >= $.CHAR_DIGIT_0 && ac <= $.CHAR_DIGIT_9) || ac === $.CHAR_UNDERSCORE || ac === $.CHAR_PERIOD || ac === $.CHAR_COLON || ac === $.CHAR_DASH) {\n        i++\n      } else break\n    }\n    var attrName = source.slice(attrStart, i)\n\n    // Skip whitespace\n    while (i < len && (source.charCodeAt(i) === $.CHAR_SPACE || source.charCodeAt(i) === $.CHAR_TAB)) i++\n\n    // Check for =\n    if (source.charCodeAt(i) !== $.CHAR_EQ) {\n      attrs[attrName] = ''\n      continue\n    }\n    i++ // skip =\n\n    // Skip whitespace\n    while (i < len && (source.charCodeAt(i) === $.CHAR_SPACE || source.charCodeAt(i) === $.CHAR_TAB)) i++\n\n    // Parse value\n    var quote = source.charCodeAt(i)\n    if (quote === $.CHAR_DOUBLE_QUOTE || quote === $.CHAR_SINGLE_QUOTE) { // \" or '\n      i++\n      var valueStart = i\n      // Newlines are allowed in quoted attribute values per CommonMark\n      while (i < len && source.charCodeAt(i) !== quote) i++\n      if (i >= len) return null // unclosed quote\n      attrs[attrName] = source.slice(valueStart, i)\n      i++ // skip closing quote\n      // After a quoted value, next must be whitespace, >, or />\n      if (i < len) {\n        var afterQuote = source.charCodeAt(i)\n        if (afterQuote !== $.CHAR_SPACE && afterQuote !== $.CHAR_TAB && afterQuote !== $.CHAR_NEWLINE &&\n            afterQuote !== $.CHAR_GT && afterQuote !== $.CHAR_SLASH) return null\n      }\n    } else if (quote === $.CHAR_BRACE_OPEN) { // {\n      var depth = 1\n      var valueStart = i\n      i++\n      while (i < len && depth > 0) {\n        var ac = source.charCodeAt(i)\n        if (ac === $.CHAR_BRACE_OPEN) depth++\n        else if (ac === $.CHAR_BRACE_CLOSE) depth--\n        i++\n      }\n      attrs[attrName] = source.slice(valueStart, i)\n    } else {\n      // Unquoted value: can't contain \" ' = < > ` or whitespace\n      var valueStart = i\n      while (i < len) {\n        var vc = source.charCodeAt(i)\n        if (vc === $.CHAR_SPACE || vc === $.CHAR_TAB || vc === $.CHAR_GT || vc === $.CHAR_NEWLINE ||\n            vc === $.CHAR_DOUBLE_QUOTE || vc === $.CHAR_SINGLE_QUOTE || vc === $.CHAR_EQ || vc === $.CHAR_LT || vc === $.CHAR_BACKTICK) break\n        i++\n      }\n      if (i === valueStart) return null // empty unquoted value\n      attrs[attrName] = source.slice(valueStart, i)\n    }\n  }\n\n  return null\n}\n\n// Collect reference definitions in first pass\nexport function collectReferenceDefinitions(\n  input: string,\n  refs: { [key: string]: { target: string; title: string } },\n  _options: ParseOptions\n): void {\n  var pos = 0\n  var len = input.length\n  // Track whether prev line was paragraph content — ref defs can't interrupt paragraphs\n  var prevWasContent = false\n\n  while (pos < len) {\n    var lineEnd = input.indexOf('\\n', pos)\n    var end = lineEnd < 0 ? len : lineEnd\n\n    // Skip leading whitespace (up to 3 spaces)\n    var i = pos\n    var spaces = 0\n    while (i < end && spaces < 4) {\n      if (input.charCodeAt(i) === $.CHAR_SPACE) { spaces++; i++ }\n      else if (input.charCodeAt(i) === $.CHAR_TAB) { spaces += 4; i++ }\n      else break\n    }\n\n    // Check for blank line\n    if (i >= end) {\n      prevWasContent = false\n      pos = lineEnd < 0 ? len : lineEnd + 1\n      continue\n    }\n\n    // Skip fenced code blocks (``` or ~~~)\n    if (spaces < 4) {\n      var fc = input.charCodeAt(i)\n      if (fc === $.CHAR_BACKTICK || fc === $.CHAR_TILDE) {\n        var fenceChar = fc\n        var fenceCount = 0\n        var fi = i\n        while (fi < end && input.charCodeAt(fi) === fenceChar) { fenceCount++; fi++ }\n        if (fenceCount >= 3) {\n          prevWasContent = false\n          // Skip fenced block: scan for close fence using direct charCode walk\n          // Avoids per-line indexOf('\\n') overhead for 5000+ fenced lines in large docs\n          var scanPos = lineEnd < 0 ? len : lineEnd + 1\n          while (scanPos < len) {\n            // Skip indent (up to 3 spaces)\n            var ci = scanPos, cSp = 0\n            while (ci < len && cSp < 4) {\n              var cc = input.charCodeAt(ci)\n              if (cc === $.CHAR_SPACE) { cSp++; ci++ }\n              else if (cc === $.CHAR_TAB) { cSp += 4; ci++ }\n              else break\n            }\n            // Check for fence chars\n            if (cSp < 4 && ci < len && input.charCodeAt(ci) === fenceChar) {\n              var cf = 0\n              while (ci < len && input.charCodeAt(ci) === fenceChar) { cf++; ci++ }\n              if (cf >= fenceCount) {\n                // Check rest of line is whitespace\n                while (ci < len && (input.charCodeAt(ci) === $.CHAR_SPACE || input.charCodeAt(ci) === $.CHAR_TAB)) ci++\n                if (ci >= len || input.charCodeAt(ci) === $.CHAR_NEWLINE) {\n                  pos = ci >= len ? len : ci + 1\n                  break\n                }\n              }\n            }\n            // Skip to next line\n            while (scanPos < len && input.charCodeAt(scanPos) !== $.CHAR_NEWLINE) scanPos++\n            if (scanPos < len) scanPos++ // skip past \\n\n          }\n          if (scanPos >= len) pos = len\n          continue\n        }\n      }\n    }\n\n    // Strip blockquote markers to find ref defs inside blockquotes\n    var ri = i\n    while (ri < end && input.charCodeAt(ri) === $.CHAR_GT) { // >\n      ri++\n      if (ri < end && input.charCodeAt(ri) === $.CHAR_SPACE) ri++ // optional space after >\n      // Re-check leading whitespace after >\n      var bqSpaces = 0\n      while (ri < end && bqSpaces < 4) {\n        if (input.charCodeAt(ri) === $.CHAR_SPACE) { bqSpaces++; ri++ }\n        else if (input.charCodeAt(ri) === $.CHAR_TAB) { bqSpaces += 4; ri++ }\n        else break\n      }\n      if (bqSpaces >= 4) break // indented code block inside blockquote\n      prevWasContent = false // blockquote marker resets paragraph context\n    }\n\n    // Check for [ (potential reference definition, not footnote [^)\n    // Link ref defs cannot interrupt paragraphs\n    if (!prevWasContent && spaces < 4 && ri < end && input.charCodeAt(ri) === $.CHAR_BRACKET_OPEN && !(ri + 1 < len && input.charCodeAt(ri + 1) === $.CHAR_CARET)) {\n      var result = parseRefDef(input, ri, refs)\n      if (result) {\n        pos = result\n        prevWasContent = false\n        continue\n      }\n    }\n\n    // Determine if this line is paragraph-like content or a self-contained block\n    // Headings, thematic breaks, and HTML block openers don't create paragraph context\n    var lineC = input.charCodeAt(i)\n    if (lineC === $.CHAR_HASH && spaces < 4) { // # heading\n      prevWasContent = false\n    } else if (spaces < 4 && (lineC === $.CHAR_DASH || lineC === $.CHAR_ASTERISK || lineC === $.CHAR_UNDERSCORE)) {\n      // Could be thematic break — check\n      var tbp = i, tbCount = 0\n      while (tbp < end) {\n        var tbc = input.charCodeAt(tbp)\n        if (tbc === lineC) tbCount++\n        else if (tbc !== $.CHAR_SPACE && tbc !== $.CHAR_TAB) break\n        tbp++\n      }\n      prevWasContent = !(tbCount >= 3 && tbp >= end)\n    } else {\n      prevWasContent = true\n    }\n    // Move to next line\n    pos = lineEnd < 0 ? len : lineEnd + 1\n  }\n}\n\n// Parse a reference definition [label]: url \"title\" or footnote [^id]: content\nexport function parseRefDef(\n  s: string,\n  p: number,\n  refs: { [key: string]: { target: string; title: string | undefined } }\n): number | null {\n  const len = s.length\n  if (s.charCodeAt(p) !== $.CHAR_BRACKET_OPEN) return null // [\n\n  // Check for footnote definition [^\n  const isFootnote = p + 1 < len && s.charCodeAt(p + 1) === $.CHAR_CARET\n\n  // Find label end - per CommonMark, labels cannot contain unescaped brackets\n  let i = p + 1\n  while (i < len) {\n    var c = s.charCodeAt(i)\n    if (c === $.CHAR_BRACKET_CLOSE) { i++; break } // ]\n    if (c === $.CHAR_BRACKET_OPEN) return null // unescaped [ in label\n    if (c === $.CHAR_BACKSLASH && i + 1 < len) i++ // escape\n    i++\n  }\n  if (i > len || s.charCodeAt(i - 1) !== $.CHAR_BRACKET_CLOSE) return null\n\n  const rawLabel = s.slice(p + 1, i - 1)\n  // Label must not exceed 999 chars per CommonMark spec\n  if (rawLabel.length > 999) return null\n  const label = normalizeLabel(rawLabel)\n  if (!label) return null\n\n  // Expect :\n  if (i >= len || s.charCodeAt(i) !== $.CHAR_COLON) return null\n  i++\n\n  // Skip whitespace (including one optional newline)\n  let hasNewline = false\n  while (i < len) {\n    const c = s.charCodeAt(i)\n    if (c === $.CHAR_SPACE || c === $.CHAR_TAB) i++\n    else if (c === $.CHAR_NEWLINE && !hasNewline) { hasNewline = true; i++ }\n    else break\n  }\n\n  if (isFootnote) {\n    // Footnote: collect content to end of line (simplified)\n    const lineEnd = s.indexOf('\\n', i)\n    const contentEnd = lineEnd < 0 ? len : lineEnd\n    const content = s.slice(i, contentEnd).trim()\n    refs[label] = { target: content, title: undefined }\n    return lineEnd < 0 ? len : lineEnd + 1\n  }\n\n  // Regular ref: parse URL\n  var url: string\n  if (i < len && s.charCodeAt(i) === $.CHAR_LT) { // <url>\n    i++\n    var urlStart = i\n    while (i < len && s.charCodeAt(i) !== $.CHAR_GT && s.charCodeAt(i) !== $.CHAR_NEWLINE) {\n      if (s.charCodeAt(i) === $.CHAR_BACKSLASH && i + 1 < len) i++ // escape\n      i++\n    }\n    if (i >= len || s.charCodeAt(i) !== $.CHAR_GT) return null\n    url = s.slice(urlStart, i)\n    i++\n    // Check that nothing follows the > on this line except whitespace or a title\n    var afterUrlEnd = s.indexOf('\\n', i)\n    var afterUrlEol = afterUrlEnd < 0 ? len : afterUrlEnd\n    var ai = i\n    while (ai < afterUrlEol && (s.charCodeAt(ai) === $.CHAR_SPACE || s.charCodeAt(ai) === $.CHAR_TAB)) ai++\n    if (ai < afterUrlEol) {\n      // Content after > — must be whitespace-separated title\n      if (ai === i) return null // no whitespace before title = invalid\n      var tc2 = s.charCodeAt(ai)\n      if (tc2 !== $.CHAR_DOUBLE_QUOTE && tc2 !== $.CHAR_SINGLE_QUOTE && tc2 !== $.CHAR_PAREN_OPEN) return null // not a title char\n    }\n  } else {\n    var urlStart = i\n    var parens = 0\n    while (i < len) {\n      var c = s.charCodeAt(i)\n      if (c === $.CHAR_PAREN_OPEN) parens++\n      else if (c === $.CHAR_PAREN_CLOSE) { if (parens === 0) break; parens-- }\n      else if (c === $.CHAR_SPACE || c === $.CHAR_TAB || c === $.CHAR_NEWLINE) break\n      else if (c === $.CHAR_BACKSLASH && i + 1 < len) i++ // escape\n      i++\n    }\n    url = s.slice(urlStart, i)\n    if (!url) return null // URL required for non-angle-bracket form\n  }\n\n  // Skip whitespace\n  while (i < len && (s.charCodeAt(i) === $.CHAR_SPACE || s.charCodeAt(i) === $.CHAR_TAB)) i++\n\n  var lineEndPos = s.indexOf('\\n', i)\n  var eol = lineEndPos < 0 ? len : lineEndPos\n\n  // Try to parse title (can be on same line or next line)\n  var title: string | undefined\n  var titleParsed = false\n  var titleEnd = i\n\n  // Check if at end of line - title might be on next line\n  var tryTitleAt = i\n  if (i === eol && i < len) {\n    tryTitleAt = i + 1\n    while (tryTitleAt < len && (s.charCodeAt(tryTitleAt) === $.CHAR_SPACE || s.charCodeAt(tryTitleAt) === $.CHAR_TAB)) tryTitleAt++\n  }\n\n  if (tryTitleAt < len) {\n    var tc = s.charCodeAt(tryTitleAt)\n    if (tc === $.CHAR_DOUBLE_QUOTE || tc === $.CHAR_SINGLE_QUOTE || tc === $.CHAR_PAREN_OPEN) { // \" ' (\n      var closeChar = tc === $.CHAR_PAREN_OPEN ? 41 : tc\n      var ti = tryTitleAt + 1\n      var titleStart = ti\n      // Title can span multiple lines, but not contain blank lines\n      while (ti < len) {\n        var tch = s.charCodeAt(ti)\n        if (tch === closeChar) {\n          // Found closing - check rest of line is blank\n          var afterTitle = ti + 1\n          while (afterTitle < len && (s.charCodeAt(afterTitle) === $.CHAR_SPACE || s.charCodeAt(afterTitle) === $.CHAR_TAB)) afterTitle++\n          if (afterTitle >= len || s.charCodeAt(afterTitle) === $.CHAR_NEWLINE) {\n            title = s.slice(titleStart, ti)\n            titleParsed = true\n            titleEnd = afterTitle < len ? afterTitle + 1 : len\n          }\n          break\n        }\n        if (tch === $.CHAR_BACKSLASH && ti + 1 < len) { ti += 2; continue } // escape\n        // Check for blank line (title can't span blank lines)\n        if (tch === $.CHAR_NEWLINE && ti + 1 < len && s.charCodeAt(ti + 1) === $.CHAR_NEWLINE) break\n        ti++\n      }\n\n      if (!titleParsed) {\n        // Title didn't parse properly\n        if (tryTitleAt !== i) {\n          // Title was on next line - just use URL-only form\n        } else {\n          // Title on same line that didn't close - not valid\n          return null\n        }\n      }\n    }\n  }\n\n  if (titleParsed) {\n    if (!refs[label]) refs[label] = { target: unescapeString(url), title: title !== undefined ? util.decodeEntityReferences(unescapeString(title)) : title }\n    return titleEnd\n  }\n\n  // No title - check that rest of line is blank\n  while (i < eol && (s.charCodeAt(i) === $.CHAR_SPACE || s.charCodeAt(i) === $.CHAR_TAB)) i++\n  if (i < eol) return null\n\n  // First definition wins\n  if (!refs[label]) {\n    refs[label] = { target: unescapeString(url), title }\n  }\n  return lineEndPos < 0 ? len : lineEndPos + 1\n}\n\n// ============================================================================\n// CHARACTER CLASSIFICATION TABLE\n// ============================================================================\n// Bitfield flags for character classification\nconst C_WS = 1        // Whitespace (space, tab, newline)\nconst C_NL = 2        // Newline\nconst C_PUNCT = 4     // Punctuation\nconst C_ALPHA = 8     // Letter\nconst C_DIGIT = 16    // Digit\nconst C_BLOCK = 32    // Can start a block\nconst C_INLINE = 64   // Can start inline syntax\n\n// Character class lookup table (ASCII 0-127)\nconst CC = new Uint8Array(128)\n\n// Initialize character classes\n// Whitespace\nCC[$.CHAR_SPACE] = C_WS                          // space\nCC[$.CHAR_TAB] = C_WS                           // tab\nCC[$.CHAR_NEWLINE] = C_WS | C_NL                   // newline\nCC[$.CHAR_CR] = C_WS | C_NL                   // carriage return\n\n// Block starters\nCC[$.CHAR_HASH] = C_BLOCK | C_PUNCT             // # (heading)\nCC[$.CHAR_GT] = C_BLOCK | C_PUNCT             // > (blockquote)\nCC[$.CHAR_DASH] = C_BLOCK | C_INLINE | C_PUNCT  // - (list, thematic, strikethrough)\nCC[$.CHAR_PLUS] = C_BLOCK | C_PUNCT             // + (list)\nCC[$.CHAR_ASTERISK] = C_BLOCK | C_INLINE | C_PUNCT  // * (list, thematic, emphasis)\nCC[$.CHAR_UNDERSCORE] = C_BLOCK | C_INLINE | C_PUNCT  // _ (thematic, emphasis)\nCC[$.CHAR_BACKTICK] = C_BLOCK | C_INLINE | C_PUNCT  // ` (code fence, code span)\nCC[$.CHAR_TILDE] = C_BLOCK | C_INLINE | C_PUNCT // ~ (code fence, strikethrough)\nCC[$.CHAR_LT] = C_BLOCK | C_INLINE | C_PUNCT  // < (HTML, autolink)\nCC[$.CHAR_BRACKET_OPEN] = C_INLINE | C_PUNCT            // [ (link, image, footnote)\nCC[$.CHAR_EXCLAMATION] = C_INLINE | C_PUNCT            // ! (image)\nCC[$.CHAR_PIPE] = C_BLOCK | C_PUNCT            // | (table)\n\n// Digits\nfor (let i = $.CHAR_DIGIT_0; i <= $.CHAR_DIGIT_9; i++) CC[i] = C_DIGIT | C_BLOCK  // 0-9 (ordered list)\n\n// Letters\nfor (let i = $.CHAR_A; i <= $.CHAR_Z; i++) CC[i] = C_ALPHA   // A-Z\nfor (let i = $.CHAR_a; i <= $.CHAR_z; i++) CC[i] = C_ALPHA  // a-z\n\n// Other punctuation - all ASCII punctuation must be classified for CommonMark escape handling\nCC[$.CHAR_BACKSLASH] = C_PUNCT   // \\ (escape)\nCC[$.CHAR_BRACKET_CLOSE] = C_PUNCT   // ]\nCC[$.CHAR_PAREN_OPEN] = C_PUNCT   // (\nCC[$.CHAR_PAREN_CLOSE] = C_PUNCT   // )\nCC[$.CHAR_COLON] = C_PUNCT   // :\nCC[$.CHAR_DOUBLE_QUOTE] = C_PUNCT   // \"\nCC[$.CHAR_SINGLE_QUOTE] = C_PUNCT   // '\nCC[$.CHAR_AMPERSAND] = C_PUNCT   // &\nCC[$.CHAR_EQ] = C_PUNCT   // =\nCC[$.CHAR_DOLLAR] = C_PUNCT   // $\nCC[$.CHAR_PERCENT] = C_PUNCT   // %\nCC[$.CHAR_COMMA] = C_PUNCT   // ,\nCC[$.CHAR_PERIOD] = C_PUNCT   // .\nCC[$.CHAR_SLASH] = C_PUNCT   // /\nCC[$.CHAR_SEMICOLON] = C_PUNCT   // ;\nCC[$.CHAR_QUESTION] = C_PUNCT   // ?\nCC[$.CHAR_AT] = C_PUNCT   // @\nCC[$.CHAR_CARET] = C_PUNCT   // ^\nCC[$.CHAR_BRACE_OPEN] = C_PUNCT  // {\nCC[$.CHAR_BRACE_CLOSE] = C_PUNCT  // }\n\n/** Check if string contains unescaped [ or ] */\nfunction hasUnescapedBracket(s: string): boolean {\n  // Fast rejection: if no brackets at all, skip the escaping check\n  if (s.indexOf('[') < 0 && s.indexOf(']') < 0) return false\n  for (var i = 0; i < s.length; i++) {\n    if (s.charCodeAt(i) === $.CHAR_BACKSLASH) { i++; continue } // skip escaped char\n    if (s.charCodeAt(i) === $.CHAR_BRACKET_OPEN || s.charCodeAt(i) === $.CHAR_BRACKET_CLOSE) return true\n  }\n  return false\n}\n\n/** Normalize a reference label for case-insensitive matching */\nfunction normalizeLabel(label: string): string {\n  var normalized = label.replace(/\\s+/g, ' ').trim()\n  // Handle Unicode case folding: ẞ (U+1E9E, capital sharp S) → ss\n  if (normalized.indexOf('\\u1E9E') !== -1) {\n    return normalized.replace(/\\u1E9E/g, 'ss').toLowerCase()\n  }\n  return normalized.toLowerCase()\n}\n\n// ============================================================================\n// GENERIC SCANNING PRIMITIVES\n// ============================================================================\n\n/** Get character class for a character code */\nfunction cc(code: number): number {\n  return code < $.CHAR_ASCII_BOUNDARY ? CC[code] : (code === $.CHAR_NBSP ? C_WS : 0)\n}\n\n/** Unescape backslash escapes in a string */\nfunction unescapeString(s: string): string {\n  // Replace \\X with X when X is an ASCII punctuation character\n  return s.replace(/\\\\([!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~])/g, '$1')\n}\n\n/** Find end of current line (position of \\n or end of string) */\nfunction lineEnd(s: string, p: number): number {\n  var i = s.indexOf('\\n', p)\n  return i < 0 ? s.length : i\n}\n\n/** Skip to start of next line */\nfunction nextLine(s: string, p: number): number {\n  const e = lineEnd(s, p)\n  return e < s.length ? e + 1 : e\n}\n\n/** Skip whitespace (space and tab only) */\nfunction skipWS(s: string, p: number, e: number): number {\n  while (p < e) {\n    const c = s.charCodeAt(p)\n    if (c !== $.CHAR_SPACE && c !== $.CHAR_TAB) break\n    p++\n  }\n  return p\n}\n\n/** Find start of next blank line (line with only whitespace or empty) */\nfunction findNextBlankLine(s: string, p: number): number {\n  // CommonMark Type 7 blocks continue until a truly blank line is reached.\n  // We start searching AFTER the current line.\n  let i = nextLine(s, p)\n  while (i < s.length) {\n    const e = lineEnd(s, i)\n    if (isBlank(s, i, e)) return i\n    i = nextLine(s, i)\n  }\n  return s.length\n}\n\n/** Skip all whitespace including newlines */\nfunction skipAllWS(s: string, p: number, e: number): number {\n  while (p < e && (cc(s.charCodeAt(p)) & C_WS)) p++\n  return p\n}\n\n/** Count consecutive occurrences of a character */\nfunction countChar(s: string, p: number, e: number, ch: number): number {\n  let n = 0\n  while (p + n < e && s.charCodeAt(p + n) === ch) n++\n  return n\n}\n\n// Reusable indent result to avoid allocations\nexport var _indentSpaces = 0, _indentChars = 0\n\n/** Calculate indentation (spaces, with tabs = 4 spaces). Results in _indentSpaces and _indentChars */\nexport function indent(s: string, p: number, e: number): void {\n  _indentSpaces = 0\n  _indentChars = 0\n  while (p + _indentChars < e) {\n    const c = s.charCodeAt(p + _indentChars)\n    if (c === $.CHAR_TAB) _indentSpaces += 4 - (_indentSpaces % 4)\n    else if (c === $.CHAR_SPACE) _indentSpaces++\n    else break\n    _indentChars++\n  }\n}\n\n/** Check if line is blank (only whitespace) */\nfunction isBlank(s: string, p: number, e: number): boolean {\n  return skipWS(s, p, e) >= e\n}\n\n\n// ============================================================================\n// RESULT TYPES\n// ============================================================================\n\ntype ScanResult = { node: MarkdownToJSX.ASTNode; end: number } | null\n\n// ============================================================================\n// BLOCK SCANNERS\n// ============================================================================\n\n/** Scan ATX heading (# ... #) */\nfunction scanHeading(s: string, p: number, state: MarkdownToJSX.State, opts: ParseOptions): ScanResult {\n  const e = lineEnd(s, p)\n  indent(s, p, e)\n  if (_indentSpaces > 3) return null\n\n  let i = p + _indentChars\n  if (s.charCodeAt(i) !== $.CHAR_HASH) return null // #\n\n  // Count # characters (1-6)\n  const level = countChar(s, i, e, 35)\n  if (level < 1 || level > 6) return null\n  i += level\n\n  // Must be followed by space or end of line\n  if (i < e && s.charCodeAt(i) !== $.CHAR_SPACE && s.charCodeAt(i) !== $.CHAR_TAB) return null\n\n  // Skip whitespace after #\n  i = skipWS(s, i, e)\n\n  // Find content end (strip trailing # and spaces per CommonMark)\n  var contentEnd = e\n  // Strip trailing whitespace\n  while (contentEnd > i && s.charCodeAt(contentEnd - 1) === $.CHAR_SPACE) contentEnd--\n  // Strip trailing # characters\n  var beforeHash = contentEnd\n  while (contentEnd > i && s.charCodeAt(contentEnd - 1) === $.CHAR_HASH) contentEnd--\n  if (contentEnd < beforeHash) {\n    // We stripped some #s - check if preceded by space or at beginning\n    if (contentEnd === i || s.charCodeAt(contentEnd - 1) === $.CHAR_SPACE) {\n      // Valid closing sequence - strip trailing spaces before the #s\n      while (contentEnd > i && s.charCodeAt(contentEnd - 1) === $.CHAR_SPACE) contentEnd--\n    } else {\n      // Trailing # not preceded by space - keep them\n      contentEnd = beforeHash\n    }\n  }\n\n  const text = s.slice(i, contentEnd)\n  const children = parseInline(text, 0, text.length, state, opts)\n\n  // Generate heading ID (slug)\n  const slugify = opts?.slugify || util.slugify\n  const id = slugify(text)\n\n  return {\n    node: {\n      type: RuleType.heading,\n      level,\n      children,\n      id,\n    } as MarkdownToJSX.HeadingNode,\n    end: nextLine(s, e)\n  }\n}\n\n/** Check if a line is a setext heading underline (=== or ---) */\nfunction isSetextUnderline(s: string, p: number, e: number): boolean {\n  var c = s.charCodeAt(p)\n  if (c !== $.CHAR_EQ && c !== $.CHAR_DASH) return false // = or -\n  var i = p\n  while (i < e && s.charCodeAt(i) === c) i++\n  while (i < e && (s.charCodeAt(i) === $.CHAR_SPACE || s.charCodeAt(i) === $.CHAR_TAB)) i++\n  return i >= e\n}\n\n/** Scan thematic break (---, ***, ___) */\nfunction scanThematic(s: string, p: number): ScanResult {\n  const e = lineEnd(s, p)\n  indent(s, p, e)\n  if (_indentSpaces > 3) return null\n\n  let i = p + _indentChars\n  const ch = s.charCodeAt(i)\n  if (ch !== $.CHAR_DASH && ch !== $.CHAR_ASTERISK && ch !== $.CHAR_UNDERSCORE) return null // - * _\n\n  let count = 0\n  while (i < e) {\n    const c = s.charCodeAt(i)\n    if (c === ch) count++\n    else if (c !== $.CHAR_SPACE && c !== $.CHAR_TAB) return null\n    i++\n  }\n\n  if (count < 3) return null\n\n  return {\n    node: { type: RuleType.breakThematic } as MarkdownToJSX.BreakThematicNode,\n    end: nextLine(s, e)\n  }\n}\n\n/** Scan fenced code block */\nfunction scanFenced(s: string, p: number, state: MarkdownToJSX.State): ScanResult {\n  const e = lineEnd(s, p)\n  indent(s, p, e)\n  if (_indentSpaces > 3) return null\n\n  // Save fence indentation - we'll remove this many spaces from each content line\n  const fenceIndent = _indentSpaces\n  const fenceIndentChars = _indentChars\n\n  let i = p + _indentChars\n  const fence = s.charCodeAt(i)\n  if (fence !== $.CHAR_BACKTICK && fence !== $.CHAR_TILDE) return null // ` or ~\n\n  const fenceLen = countChar(s, i, e, fence)\n  if (fenceLen < 3) return null\n  i += fenceLen\n\n  // Parse info string - extract language (first word) and optional attributes\n  const infoStart = skipWS(s, i, e)\n  let infoEnd = e\n  // Backtick fences can't have backticks in info\n  if (fence === $.CHAR_BACKTICK) {\n    for (let j = infoStart; j < e; j++) {\n      if (s.charCodeAt(j) === $.CHAR_BACKTICK) return null\n    }\n  }\n  while (infoEnd > infoStart && (s.charCodeAt(infoEnd - 1) === $.CHAR_SPACE || s.charCodeAt(infoEnd - 1) === $.CHAR_TAB)) {\n    infoEnd--\n  }\n  const infoStr = s.slice(infoStart, infoEnd)\n\n  // Split into language (first word) and attributes (rest)\n  let lang = ''\n  let attrsStr = ''\n  const spaceIdx = infoStr.indexOf(' ')\n  if (spaceIdx === -1) {\n    lang = infoStr\n  } else {\n    lang = infoStr.slice(0, spaceIdx)\n    attrsStr = infoStr.slice(spaceIdx + 1).trim()\n  }\n\n  // Per CommonMark, only the first word of the info string is used as language.\n  // Parse key=value attributes from the rest (library extension, not CommonMark).\n  // Unescape backslash sequences in language name\n  lang = unescapeString(lang)\n\n  // Parse attributes if present (only proper key=\"value\" or key='value' pairs)\n  var attrs: Record<string, string> | undefined = undefined\n  if (attrsStr) {\n    FENCE_ATTR_R.lastIndex = 0\n    var match\n    while ((match = FENCE_ATTR_R.exec(attrsStr)) !== null) {\n      if (!attrs) attrs = {}\n      attrs[match[1]] = match[2] !== undefined ? match[2] : match[3]\n    }\n  }\n\n  // Find closing fence\n  let contentStart = nextLine(s, e)\n  let contentEnd = contentStart\n  let closeEnd = s.length\n\n  while (contentEnd < s.length) {\n    const le = lineEnd(s, contentEnd)\n    indent(s, contentEnd, le)\n    if (_indentSpaces < 4) {\n      const fp = contentEnd + _indentChars\n      var fcount = countChar(s, fp, le, fence)\n      if (fcount >= fenceLen) {\n        const afterFence = fp + fcount\n        if (isBlank(s, afterFence, le)) {\n          closeEnd = nextLine(s, le)\n          break\n        }\n      }\n    }\n    contentEnd = nextLine(s, le)\n  }\n\n  // Extract content, removing up to fenceIndent spaces from each line\n  var content: string\n  if (fenceIndent === 0) {\n    // Fast path: no indent stripping needed — content is contiguous in source\n    // Strip trailing newline: contentEnd points to start of closing fence line,\n    // so the last char before it is '\\n' from the last content line\n    content = contentEnd > contentStart && s.charCodeAt(contentEnd - 1) === $.CHAR_NEWLINE\n      ? s.slice(contentStart, contentEnd - 1)\n      : s.slice(contentStart, contentEnd)\n  } else {\n    content = ''\n    var cp = contentStart\n    while (cp < contentEnd) {\n      var le = lineEnd(s, cp)\n      indent(s, cp, le)\n      var remove = Math.min(_indentChars, fenceIndent)\n      content += s.slice(cp + remove, le) + '\\n'\n      cp = nextLine(s, le)\n    }\n    // Remove trailing newline\n    if (content.length > 0 && content.charCodeAt(content.length - 1) === $.CHAR_NEWLINE) content = content.slice(0, -1)\n  }\n\n  return {\n    node: {\n      type: RuleType.codeBlock,\n      lang: lang || undefined,\n      text: content,\n      infoString: attrsStr || undefined,\n      attrs: attrs,\n    } as MarkdownToJSX.CodeBlockNode,\n    end: closeEnd\n  }\n}\n\n/** Scan indented code block */\nfunction scanIndented(s: string, p: number): ScanResult {\n  const e = lineEnd(s, p)\n  indent(s, p, e)\n  if (_indentSpaces < 4) return null\n\n  let content = ''\n  let end = p\n\n  while (end < s.length) {\n    const le = lineEnd(s, end)\n    indent(s, end, le)\n\n    if (isBlank(s, end, le)) {\n      // Blank line(s) - include if code continues after them\n      var blankCount = 0\n      var scanPos = nextLine(s, le)\n      while (scanPos < s.length) {\n        var scanLe = lineEnd(s, scanPos)\n        if (isBlank(s, scanPos, scanLe)) {\n          blankCount++\n          scanPos = nextLine(s, scanLe)\n          continue\n        }\n        indent(s, scanPos, scanLe)\n        if (_indentSpaces >= 4) {\n          // Code continues after blank(s): add the blank lines\n          for (var bi = 0; bi <= blankCount; bi++) content += '\\n'\n          end = scanPos\n          break\n        }\n        break\n      }\n      if (end !== scanPos) break\n      continue\n    }\n\n    if (_indentSpaces < 4) break\n\n    // Remove 4 spaces of indentation, expanding tabs to spaces\n    let remove = 0, spaces = 0\n    var extraSpaces = 0\n    for (let i = end; i < le && spaces < 4; i++) {\n      const c = s.charCodeAt(i)\n      if (c === $.CHAR_TAB) {\n        var tabW = 4 - (spaces % 4)\n        if (spaces + tabW > 4) {\n          extraSpaces = spaces + tabW - 4\n        }\n        spaces += tabW\n      }\n      else spaces++\n      remove++\n    }\n\n    // Add any leftover spaces from partial tab consumption, then literal content\n    var lineContent = ''\n    if (extraSpaces > 0) {\n      for (var si = 0; si < extraSpaces; si++) lineContent += ' '\n    }\n    lineContent += s.slice(end + remove, le)\n    content += lineContent + '\\n'\n    end = nextLine(s, le)\n  }\n\n  // Trim trailing blank lines\n  while (content.length > 0 && content.charCodeAt(content.length - 1) === $.CHAR_NEWLINE) content = content.slice(0, -1)\n  while (content.length > 0 && content.charCodeAt(content.length - 1) === $.CHAR_NEWLINE) content = content.slice(0, -1)\n\n  if (!content) return null\n\n  return {\n    node: {\n      type: RuleType.codeBlock,\n      text: content,\n    } as MarkdownToJSX.CodeBlockNode,\n    end\n  }\n}\n\n/** Scan blockquote */\nfunction scanBlockquote(s: string, p: number, state: MarkdownToJSX.State, opts: ParseOptions): ScanResult {\n  const e = lineEnd(s, p)\n  indent(s, p, e)\n  if (_indentSpaces > 3) return null\n\n  let i = p + _indentChars\n  if (s.charCodeAt(i) !== $.CHAR_GT) return null // >\n\n  // Collect blockquote content\n  let content = ''\n  let end = p\n  let alertType: string | undefined\n  let hasLazyContinuation = false\n  let lastLineWasQuoted = false\n  let contentHasOpenBlock = false\n\n  while (end < s.length) {\n    const le = lineEnd(s, end)\n    indent(s, end, le)\n\n    const qi = end + _indentChars\n    if (s.charCodeAt(qi) === $.CHAR_GT) {\n      // > marker\n      let ci = qi + 1\n      // Calculate absolute column after > marker\n      var bqAbsCol = _indentSpaces + 1 // indent cols + > itself\n      var bqStripOne = false\n      if (ci < le) {\n        var bqNextChar = s.charCodeAt(ci)\n        if (bqNextChar === $.CHAR_SPACE) {\n          ci++; bqAbsCol++; bqStripOne = true\n        } else if (bqNextChar === $.CHAR_TAB) {\n          // Tab after >: consume 1 col as optional space, expand rest\n          bqStripOne = true\n        }\n      }\n      // Build lineContent with tab expansion using absolute columns\n      var lineContent = ''\n      var hasTabInLine = false\n      for (var bci = ci; bci < le; bci++) {\n        if (s.charCodeAt(bci) === $.CHAR_TAB) { hasTabInLine = true; break }\n      }\n      if (hasTabInLine) {\n        // Expand tabs to spaces using absolute column tracking\n        var bqCol = bqAbsCol\n        if (bqStripOne && ci < le && s.charCodeAt(ci) === $.CHAR_TAB) {\n          // First char is a tab — consume 1 col, expand rest\n          var tw = 4 - (bqCol % 4)\n          for (var bi = 0; bi < tw - 1; bi++) lineContent += ' '\n          bqCol += tw\n          ci++\n        }\n        for (var bci2 = ci; bci2 < le; bci2++) {\n          if (s.charCodeAt(bci2) === $.CHAR_TAB) {\n            var tw2 = 4 - (bqCol % 4)\n            for (var bi2 = 0; bi2 < tw2; bi2++) lineContent += ' '\n            bqCol += tw2\n          } else { lineContent += s[bci2]; bqCol++ }\n        }\n      } else {\n        lineContent = s.slice(ci, le)\n      }\n\n      // Check for alert syntax [!TYPE] on first line\n      if (!content && !alertType) {\n        const alertMatch = lineContent.match(/^\\[!([A-Za-z]+)\\]\\s*$/)\n        if (alertMatch) {\n          alertType = alertMatch[1].toUpperCase()\n          end = nextLine(s, le)\n          continue // Don't add alert marker to content\n        }\n      }\n\n      content += lineContent + '\\n'\n      // Track if content has open fenced code block or indented code\n      var trimLine = lineContent.trimStart()\n      if (trimLine.startsWith('```') || trimLine.startsWith('~~~')) {\n        contentHasOpenBlock = !contentHasOpenBlock\n      } else if (lineContent.startsWith('    ') || lineContent.startsWith('\\t')) {\n        contentHasOpenBlock = true\n      } else if (trimLine.length > 0 && !contentHasOpenBlock) {\n        contentHasOpenBlock = false\n      }\n      // After a blank quoted line (e.g. \">\\n\"), no lazy continuation allowed\n      lastLineWasQuoted = trimLine.length > 0\n      end = nextLine(s, le)\n    } else if (content && !isBlank(s, end, le) && lastLineWasQuoted) {\n      // Lazy continuation - only continues paragraphs, not block elements\n      // Per CommonMark, lazy continuation can only continue a paragraph\n      // Block-level checks only apply when indent < 4 (otherwise it's\n      // an indented code block candidate which can lazy-continue a paragraph)\n      if (_indentSpaces < 4) {\n        var lazyI = end + _indentChars\n        var lazyC = lazyI < le ? s.charCodeAt(lazyI) : 0\n        // Don't continue if line starts a block element\n        if (lazyC === $.CHAR_HASH || lazyC === $.CHAR_GT || lazyC === $.CHAR_BACKTICK || lazyC === $.CHAR_TILDE || lazyC === $.CHAR_LT) break\n        if ((lazyC === $.CHAR_DASH || lazyC === $.CHAR_ASTERISK || lazyC === $.CHAR_UNDERSCORE) && scanThematic(s, end)) break\n        if ((lazyC === $.CHAR_DASH || lazyC === $.CHAR_ASTERISK || lazyC === $.CHAR_PLUS) && lazyI + 1 < le && (s.charCodeAt(lazyI + 1) === $.CHAR_SPACE || s.charCodeAt(lazyI + 1) === $.CHAR_TAB)) break\n        if (lazyC >= $.CHAR_DIGIT_0 && lazyC <= $.CHAR_DIGIT_9) {\n          var oi = lazyI\n          while (oi < le && s.charCodeAt(oi) >= $.CHAR_DIGIT_0 && s.charCodeAt(oi) <= $.CHAR_DIGIT_9) oi++\n          if (oi < le && (s.charCodeAt(oi) === $.CHAR_PERIOD || s.charCodeAt(oi) === $.CHAR_PAREN_CLOSE)) break\n        }\n      }\n      // Don't allow lazy continuation if blockquote content has unclosed block elements\n      if (contentHasOpenBlock) break\n      content += s.slice(end, le) + '\\n'\n      hasLazyContinuation = true\n      end = nextLine(s, le)\n    } else {\n      break\n    }\n  }\n\n  if (!content && !alertType) return null\n\n  // Parse blockquote content recursively\n  // If lazy continuation was used, disable setext heading detection\n  // (per CommonMark, setext underlines can't be lazy continuation lines)\n  var savedBQ = state.inBlockQuote, savedNoSetext = state._noSetext\n  state.inBlockQuote = true\n  if (hasLazyContinuation) state._noSetext = true\n  const children = parseBlocks(content || '', state, opts)\n  state.inBlockQuote = savedBQ; state._noSetext = savedNoSetext\n\n  const node: MarkdownToJSX.BlockQuoteNode = {\n    type: RuleType.blockQuote,\n    children,\n  }\n  if (alertType) {\n    node.alert = alertType\n  }\n\n  return { node, end }\n}\n\n/** Calculate column position at offset p accounting for tabs */\nfunction columnAt(s: string, lineStart: number, p: number): number {\n  var col = 0\n  for (var i = lineStart; i < p; i++) {\n    if (s.charCodeAt(i) === $.CHAR_TAB) col += 4 - (col % 4)\n    else col++\n  }\n  return col\n}\n\n/** Check if line starts a list item, return marker info */\nfunction checkListMarker(s: string, p: number, e: number): {\n  ordered: boolean; marker: string; start?: number;\n  contentStart: number; contentCol: number; markerCol: number;\n  isEmpty: boolean\n} | null {\n  indent(s, p, e)\n  if (_indentSpaces > 3) return null\n\n  var i = p + _indentChars\n  if (i >= e) return null\n\n  var c = s.charCodeAt(i)\n  var markerCol = _indentSpaces\n  var markerEnd = i\n\n  // Unordered: - * +\n  if (c === $.CHAR_DASH || c === $.CHAR_ASTERISK || c === $.CHAR_PLUS) {\n    markerEnd = i + 1\n    if (markerEnd < e && s.charCodeAt(markerEnd) !== $.CHAR_SPACE && s.charCodeAt(markerEnd) !== $.CHAR_TAB && s.charCodeAt(markerEnd) !== $.CHAR_NEWLINE) {\n      return null\n    }\n  }\n  // Ordered: 1. or 1)\n  else if (c >= $.CHAR_DIGIT_0 && c <= $.CHAR_DIGIT_9) {\n    var numEnd = i\n    while (numEnd < e && numEnd - i < 9) {\n      var nc = s.charCodeAt(numEnd)\n      if (nc < $.CHAR_DIGIT_0 || nc > $.CHAR_DIGIT_9) break\n      numEnd++\n    }\n    if (numEnd > i && numEnd < e) {\n      var delim = s.charCodeAt(numEnd)\n      if (delim === $.CHAR_PERIOD || delim === $.CHAR_PAREN_CLOSE) {\n        markerEnd = numEnd + 1\n        if (markerEnd < e && s.charCodeAt(markerEnd) !== $.CHAR_SPACE && s.charCodeAt(markerEnd) !== $.CHAR_TAB && s.charCodeAt(markerEnd) !== $.CHAR_NEWLINE) {\n          return null\n        }\n      } else return null\n    } else return null\n  } else return null\n\n  // Calculate content start column (1-4 spaces after marker)\n  var afterMarker = markerEnd\n  var afterMarkerCol = columnAt(s, p, markerEnd)\n  var spacesAfter = 0\n  var contentPos = afterMarker\n  var contentCol = afterMarkerCol\n\n  if (afterMarker >= e) {\n    // Empty item (marker at end of line)\n    return {\n      ordered: c >= $.CHAR_DIGIT_0 && c <= $.CHAR_DIGIT_9,\n      marker: c >= $.CHAR_DIGIT_0 && c <= $.CHAR_DIGIT_9 ? s[numEnd!] : s[i],\n      start: c >= $.CHAR_DIGIT_0 && c <= $.CHAR_DIGIT_9 ? parseInt(s.slice(i, numEnd!), 10) : undefined,\n      contentStart: afterMarker,\n      contentCol: afterMarkerCol + 1,\n      markerCol: markerCol,\n      isEmpty: true\n    }\n  }\n\n  // Count spaces after marker (1-4; if 5+, only 1 counts)\n  while (contentPos < e && (s.charCodeAt(contentPos) === $.CHAR_SPACE || s.charCodeAt(contentPos) === $.CHAR_TAB)) {\n    if (s.charCodeAt(contentPos) === $.CHAR_TAB) {\n      var tabWidth = 4 - (contentCol % 4)\n      contentCol += tabWidth\n    } else {\n      contentCol++\n    }\n    contentPos++\n    spacesAfter++\n  }\n\n  var isEmpty = contentPos >= e\n  // Use column-equivalent width for the 5+ spaces check (not char count)\n  var colsAfterMarker = contentCol - afterMarkerCol\n  if (isEmpty) {\n    contentCol = afterMarkerCol + 1\n    contentPos = afterMarker + 1\n    spacesAfter = 1\n  } else if (colsAfterMarker > 4) {\n    // If 5+ column-equivalent spaces after marker, only 1 space counts\n    contentCol = afterMarkerCol + 1\n    contentPos = afterMarker + 1\n    spacesAfter = 1\n  } else if (spacesAfter === 0) {\n    contentCol = afterMarkerCol + 1\n    contentPos = afterMarker\n    spacesAfter = 1\n  }\n\n  return {\n    ordered: c >= $.CHAR_DIGIT_0 && c <= $.CHAR_DIGIT_9,\n    marker: c >= $.CHAR_DIGIT_0 && c <= $.CHAR_DIGIT_9 ? s[numEnd!] : s[i],\n    start: c >= $.CHAR_DIGIT_0 && c <= $.CHAR_DIGIT_9 ? parseInt(s.slice(i, numEnd!), 10) : undefined,\n    contentStart: contentPos,\n    contentCol: contentCol,\n    markerCol: markerCol,\n    isEmpty: isEmpty\n  }\n}\n\n/**\n * Strip leading indentation from a line, removing up to `cols` columns.\n * Returns the position in `s` after stripping.\n */\nvar _stripRemaining = 0 // leftover spaces from partial tab after stripIndent\nfunction stripIndent(s: string, p: number, e: number, cols: number): number {\n  var col = 0\n  var i = p\n  _stripRemaining = 0\n  while (i < e && col < cols) {\n    var c = s.charCodeAt(i)\n    if (c === $.CHAR_TAB) {\n      var tabW = 4 - (col % 4)\n      if (col + tabW > cols) {\n        // Partial tab: consume only part, remainder becomes spaces\n        _stripRemaining = col + tabW - cols\n        i++\n        col = cols\n        break\n      }\n      col += tabW\n    } else if (c === $.CHAR_SPACE) {\n      col++\n    } else break\n    i++\n  }\n  return i\n}\n\n/** Scan list (ordered or unordered) */\nfunction scanList(s: string, p: number, state: MarkdownToJSX.State, opts: ParseOptions): ScanResult {\n  var firstLine = lineEnd(s, p)\n  var firstMarker = checkListMarker(s, p, firstLine)\n  if (!firstMarker) return null\n\n  // Collect items: each item is { contentCol, raw, hasBlankAfter, isEmpty }\n  var itemData: { contentCol: number; raw: string; hasBlankAfter: boolean; isEmpty: boolean }[] = []\n  var end = p\n  var curContentCol = firstMarker.contentCol\n  var curRaw = ''\n  var curIsEmpty = firstMarker.isEmpty\n  var curHasBlankAfter = false\n  var hadBlankLine = false\n\n  // First item's first line content\n  if (!firstMarker.isEmpty) {\n    // Check if first line content has tabs that need absolute column expansion\n    var firstHasTab = false\n    for (var fti = firstMarker.contentStart; fti < firstLine; fti++) {\n      if (s.charCodeAt(fti) === $.CHAR_TAB) { firstHasTab = true; break }\n    }\n    if (firstHasTab) {\n      var firstExpanded = ''\n      var firstAbsCol = columnAt(s, p, firstMarker.contentStart)\n      // Prepend virtual spaces for the gap between contentCol and absCol\n      // (occurs when colsAfterMarker > 4 resets contentCol)\n      var virtualGap = firstAbsCol - firstMarker.contentCol\n      if (virtualGap > 0) {\n        for (var vgi = 0; vgi < virtualGap; vgi++) firstExpanded += ' '\n      }\n      for (var fei = firstMarker.contentStart; fei < firstLine; fei++) {\n        if (s.charCodeAt(fei) === $.CHAR_TAB) {\n          var ftw = 4 - (firstAbsCol % 4)\n          for (var fsi = 0; fsi < ftw; fsi++) firstExpanded += ' '\n          firstAbsCol += ftw\n        } else { firstExpanded += s[fei]; firstAbsCol++ }\n      }\n      curRaw = firstExpanded + '\\n'\n    } else {\n      curRaw = s.slice(firstMarker.contentStart, firstLine) + '\\n'\n    }\n  }\n  end = nextLine(s, firstLine)\n\n  while (end < s.length) {\n    var le = lineEnd(s, end)\n    indent(s, end, le)\n\n    // Check for thematic break — but only if not indented enough for continuation\n    var c0 = s.charCodeAt(end + _indentChars)\n    if (_indentSpaces < curContentCol &&\n        (c0 === $.CHAR_DASH || c0 === $.CHAR_ASTERISK || c0 === $.CHAR_UNDERSCORE) &&\n        _indentSpaces <= 3 && scanThematic(s, end)) {\n      break\n    }\n\n    // Check for new list item — sibling when markerCol < current item's contentCol\n    var lineMarker = checkListMarker(s, end, le)\n    if (lineMarker && lineMarker.ordered === firstMarker.ordered &&\n        lineMarker.marker === firstMarker.marker &&\n        lineMarker.markerCol < curContentCol) {\n      // Save current item\n      itemData.push({ contentCol: curContentCol, raw: curRaw, hasBlankAfter: curHasBlankAfter, isEmpty: curIsEmpty })\n      if (curHasBlankAfter) hadBlankLine = true\n      // Start new item\n      curContentCol = lineMarker.contentCol\n      curIsEmpty = lineMarker.isEmpty\n      curHasBlankAfter = false\n      curRaw = lineMarker.isEmpty ? '' : (s.slice(lineMarker.contentStart, le) + '\\n')\n      end = nextLine(s, le)\n      continue\n    }\n\n    // Blank line\n    if (isBlank(s, end, le)) {\n      curRaw += '\\n'\n      end = nextLine(s, le)\n      // After blank in empty item, check if list continues — charCode check avoids .trim()\n      var curRawHasContent = false\n      for (var cri = 0; cri < curRaw.length; cri++) {\n        var crc = curRaw.charCodeAt(cri)\n        if (crc !== $.CHAR_NEWLINE && crc !== $.CHAR_CR && crc !== $.CHAR_SPACE && crc !== $.CHAR_TAB) { curRawHasContent = true; break }\n      }\n      if (curIsEmpty && !curRawHasContent) {\n        // List continues if next non-blank line is a matching list item\n        if (end < s.length) {\n          var peekLe = lineEnd(s, end)\n          var peekMarker = checkListMarker(s, end, peekLe)\n          if (!peekMarker || peekMarker.ordered !== firstMarker.ordered ||\n              peekMarker.marker !== firstMarker.marker) {\n            break\n          }\n          // Next is a matching item — blank before it counts as between-items\n          curHasBlankAfter = true\n        } else {\n          break\n        }\n      }\n      // Check what follows the blank\n      if (end < s.length) {\n        var nextLe = lineEnd(s, end)\n        indent(s, end, nextLe)\n        // Thematic break after blank\n        var nc = s.charCodeAt(end + _indentChars)\n        if ((nc === $.CHAR_DASH || nc === $.CHAR_ASTERISK || nc === $.CHAR_UNDERSCORE) && _indentSpaces <= 3 && scanThematic(s, end)) {\n          break\n        }\n        // Check if next line is a new item in the same list\n        var nextMarker = checkListMarker(s, end, nextLe)\n        if (nextMarker && nextMarker.ordered === firstMarker.ordered &&\n            nextMarker.marker === firstMarker.marker &&\n            nextMarker.markerCol < curContentCol) {\n          // Blank before new item = between items\n          curHasBlankAfter = true\n          continue\n        }\n        // After blank, non-item content must be indented to contentCol\n        if (!isBlank(s, end, nextLe) && _indentSpaces < curContentCol) {\n          break\n        }\n        // Blank followed by continuation content = within item (not between items)\n      }\n      continue\n    }\n\n    // Continuation line: must be indented >= contentCol\n    if (_indentSpaces >= curContentCol) {\n      var stripped = stripIndent(s, end, le, curContentCol)\n      // If partial tab was consumed, expand remaining content using ABSOLUTE columns\n      // Tab stops are fixed at 0,4,8,12... regardless of stripping\n      if (_stripRemaining > 0) {\n        var expanded = ''\n        // absCol = curContentCol because we stripped exactly curContentCol columns\n        var absCol = curContentCol\n        for (var ri = 0; ri < _stripRemaining; ri++) { expanded += ' '; absCol++ }\n        for (var ei = stripped; ei < le; ei++) {\n          if (s.charCodeAt(ei) === $.CHAR_TAB) {\n            var etw = 4 - (absCol % 4)\n            for (var eti = 0; eti < etw; eti++) expanded += ' '\n            absCol += etw\n          } else { expanded += s[ei]; absCol++ }\n        }\n        curRaw += expanded + '\\n'\n      } else {\n        curRaw += s.slice(stripped, le) + '\\n'\n      }\n      end = nextLine(s, le)\n      continue\n    }\n\n    // Lazy continuation: text with < contentCol indent that isn't a new block\n    // Only allowed if current item has an open paragraph (non-empty, no blank after)\n    // Lazy continuation — check if curRaw has non-whitespace without .trim() allocation\n    var lazyHasContent = false\n    for (var lci = 0; lci < curRaw.length; lci++) {\n      var lcc = curRaw.charCodeAt(lci)\n      if (lcc !== $.CHAR_NEWLINE && lcc !== $.CHAR_CR && lcc !== $.CHAR_SPACE && lcc !== $.CHAR_TAB) { lazyHasContent = true; break }\n    }\n    if (!curHasBlankAfter && lazyHasContent && !curIsEmpty) {\n      var lineStart = end + _indentChars\n      var lc = s.charCodeAt(lineStart)\n      var isNewBlock =\n        lc === $.CHAR_HASH ||\n        lc === $.CHAR_GT ||\n        lc === $.CHAR_LT ||\n        (lc === $.CHAR_BACKTICK || lc === $.CHAR_TILDE) ||\n        ((lc === $.CHAR_DASH || lc === $.CHAR_ASTERISK || lc === $.CHAR_UNDERSCORE || lc === $.CHAR_PLUS) &&\n          (scanThematic(s, end) !== null || checkListMarker(s, end, le) !== null)) ||\n        (lc >= $.CHAR_DIGIT_0 && lc <= $.CHAR_DIGIT_9 && checkListMarker(s, end, le) !== null)\n\n      if (!isNewBlock) {\n        // Mark lazy continuation with \\u001E so it won't be parsed as block element\n        curRaw += '\\u001E' + s.slice(lineStart, le) + '\\n'\n        end = nextLine(s, le)\n        continue\n      }\n    }\n\n    break\n  }\n\n  // Save last item\n  itemData.push({ contentCol: curContentCol, raw: curRaw, hasBlankAfter: curHasBlankAfter, isEmpty: curIsEmpty })\n\n  if (itemData.length === 0) return null\n\n  // Determine loose: blank lines between items, or within items between top-level blocks\n  // Scan each item's raw content, skipping nested containers (fenced code, nested lists, blockquotes)\n  var isLoose = hadBlankLine\n  if (!isLoose) {\n    for (var di = 0; di < itemData.length; di++) {\n      if (itemData[di].hasBlankAfter && di < itemData.length - 1) {\n        isLoose = true\n        break\n      }\n      if (!itemData[di].isEmpty) {\n        var raw = itemData[di].raw\n        var rLen = raw.length\n        var rp = 0\n        var sawDirectContent = false\n        var sawDirectBlank = false\n        var hadNestedBlank = false // blank seen while inside nested block\n        // Track containers: fenced code blocks, nested lists\n        var fenced = false, fenceChar2 = 0, fenceLen2 = 0\n        var nestedListCol = -1 // -1 = no active nested list\n        while (rp < rLen) {\n          var rle = raw.indexOf('\\n', rp)\n          if (rle < 0) rle = rLen\n          // Inside fenced code block — skip until closing fence\n          if (fenced) {\n            indent(raw, rp, rle)\n            var cl = raw.slice(rp + _indentChars, rle)\n            var cc = 0\n            while (cc < cl.length && cl.charCodeAt(cc) === fenceChar2) cc++\n            if (cc >= fenceLen2 && cl.slice(cc).trim() === '') fenced = false\n            rp = rle < rLen ? rle + 1 : rLen\n            continue\n          }\n          if (isBlank(raw, rp, rle)) {\n            if (nestedListCol >= 0) {\n              hadNestedBlank = true\n            } else if (sawDirectContent) {\n              sawDirectBlank = true\n            }\n            rp = rle < rLen ? rle + 1 : rLen\n            continue\n          }\n          indent(raw, rp, rle)\n          // If inside nested list, check if line is still part of it\n          if (nestedListCol >= 0) {\n            if (_indentSpaces >= nestedListCol) {\n              rp = rle < rLen ? rle + 1 : rLen\n              continue\n            }\n            // Check for sibling item in nested list\n            var nlm = checkListMarker(raw, rp, rle)\n            if (nlm && nlm.markerCol < nestedListCol) {\n              // Could be a new nested list item at same or shallower level\n              // If at same level, continue in nested list\n              if (nlm.contentCol <= nestedListCol) {\n                rp = rle < rLen ? rle + 1 : rLen\n                continue\n              }\n            }\n            if (nlm) {\n              rp = rle < rLen ? rle + 1 : rLen\n              continue\n            }\n            // Line is back at top level — nested list ended\n            nestedListCol = -1\n            // If there was a blank while in the nested block, and now we're\n            // back at top level with content, that's a blank between top-level blocks\n            if (hadNestedBlank) {\n              sawDirectBlank = true\n              hadNestedBlank = false\n            }\n          }\n          var lineText = raw.slice(rp + _indentChars, rle)\n          // Check for fenced code opener\n          var fc = lineText.charCodeAt(0)\n          if ((fc === $.CHAR_BACKTICK || fc === $.CHAR_TILDE) && _indentSpaces <= 3) {\n            var fn = 0\n            while (fn < lineText.length && lineText.charCodeAt(fn) === fc) fn++\n            if (fn >= 3) {\n              if (sawDirectBlank && sawDirectContent) { isLoose = true; break }\n              fenced = true; fenceChar2 = fc; fenceLen2 = fn; sawDirectContent = true; rp = rle < rLen ? rle + 1 : rLen; continue\n            }\n          }\n          // Check for list marker (starts a nested list)\n          var lm = _indentSpaces <= 3 ? checkListMarker(raw, rp, rle) : null\n          if (lm && sawDirectContent) {\n            // If there was a blank before this nested block, it's between top-level blocks\n            if (sawDirectBlank) { isLoose = true; break }\n            nestedListCol = lm.contentCol\n            hadNestedBlank = false\n            rp = rle < rLen ? rle + 1 : rLen\n            sawDirectContent = true\n            continue\n          }\n          // Regular content at top level\n          if (sawDirectBlank) {\n            isLoose = true\n            break\n          }\n          sawDirectContent = true\n          rp = rle < rLen ? rle + 1 : rLen\n        }\n        if (isLoose) break\n      }\n    }\n  }\n\n  // Parse items\n  var items: MarkdownToJSX.ASTNode[][] = []\n  for (var ii = 0; ii < itemData.length; ii++) {\n    var item = itemData[ii]\n    // Strip trailing newlines without regex (avoids ReDoS on repeated \\n)\n    var itemRaw = item.raw\n    var itemEnd = itemRaw.length\n    while (itemEnd > 0 && itemRaw.charCodeAt(itemEnd - 1) === $.CHAR_NEWLINE) itemEnd--\n    var itemContent = itemEnd < itemRaw.length ? itemRaw.slice(0, itemEnd) : itemRaw\n    var taskNode: MarkdownToJSX.GFMTaskNode | null = null\n\n    // Check for GFM task list item [ ] or [x]\n    if (itemContent.length >= 3 && itemContent.charCodeAt(0) === $.CHAR_BRACKET_OPEN) { // [\n      var tm = itemContent[1]\n      if ((tm === ' ' || tm === 'x' || tm === 'X') && itemContent.charCodeAt(2) === $.CHAR_BRACKET_CLOSE) { // ]\n        taskNode = {\n          type: RuleType.gfmTask,\n          completed: tm === 'x' || tm === 'X',\n        } as MarkdownToJSX.GFMTaskNode\n        itemContent = itemContent.slice(3)\n      }\n    }\n\n    // \\u001E markers on lazy continuation lines prevent block-level parsing\n    // These lines are paragraph continuation text, not block starters\n\n    var itemNodes: MarkdownToJSX.ASTNode[]\n    if (item.isEmpty && itemContent.trim() === '') {\n      // Empty list item\n      itemNodes = []\n    } else if (isLoose) {\n      // Loose: parse as blocks — content is already indent-stripped\n      var savedInList = state.inList; state.inList = true\n      itemNodes = parseBlocks(itemContent, state, opts)\n      state.inList = savedInList\n    } else {\n      // Tight: parse as blocks then unwrap paragraphs\n      var savedInList2 = state.inList; state.inList = true\n      itemNodes = parseBlocks(itemContent, state, opts)\n      state.inList = savedInList2\n      // Unwrap: if result is single paragraph, unwrap its children\n      if (itemNodes.length === 1 && itemNodes[0].type === RuleType.paragraph) {\n        itemNodes = (itemNodes[0] as MarkdownToJSX.ParagraphNode).children\n      } else {\n        // Unwrap paragraphs that are at top level (tight lists don't wrap in <p>)\n        var unwrapped: MarkdownToJSX.ASTNode[] = []\n        for (var ui = 0; ui < itemNodes.length; ui++) {\n          if (itemNodes[ui].type === RuleType.paragraph) {\n            var pChildren = (itemNodes[ui] as MarkdownToJSX.ParagraphNode).children\n            for (var ci = 0; ci < pChildren.length; ci++) unwrapped.push(pChildren[ci])\n          } else {\n            unwrapped.push(itemNodes[ui])\n          }\n        }\n        itemNodes = unwrapped\n      }\n    }\n\n    if (taskNode) {\n      // Add space between checkbox and content\n      items.push([taskNode, { type: RuleType.text, text: ' ' } as MarkdownToJSX.TextNode, ...itemNodes])\n    } else {\n      items.push(itemNodes)\n    }\n  }\n\n  return {\n    node: {\n      type: firstMarker.ordered ? RuleType.orderedList : RuleType.unorderedList,\n      start: firstMarker.ordered ? firstMarker.start : undefined,\n      items,\n    } as MarkdownToJSX.OrderedListNode | MarkdownToJSX.UnorderedListNode,\n    end\n  }\n}\n\n// HTML block-level tag names (CommonMark spec)\nconst BLOCK_TAGS = new Set([\n  'address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body',\n  'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir',\n  'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form',\n  'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header',\n  'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem',\n  'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'search',\n  'section', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead',\n  'title', 'tr', 'track', 'ul'\n])\n\n/** Process raw attributes object - convert names, parse styles, sanitize URLs */\nfunction processHTMLAttributes(rawAttrs: Record<string, string>, tagName: string, opts: ParseOptions): Record<string, any> {\n  const attrs: Record<string, any> = {}\n\n  for (const [rawName, value] of Object.entries(rawAttrs)) {\n    const name = rawName\n    const nameLower = rawName.toLowerCase()\n\n    if (nameLower === 'style' && typeof value === 'string') {\n      // Parse inline styles - handle url() values properly\n      const styles: Record<string, string> = {}\n      let decls: string[] = []\n      let depth = 0\n      let start = 0\n      for (let j = 0; j < value.length; j++) {\n        const c = value.charCodeAt(j)\n        if (c === $.CHAR_PAREN_OPEN) depth++ // (\n        else if (c === $.CHAR_PAREN_CLOSE) depth-- // )\n        else if (c === $.CHAR_SEMICOLON && depth === 0) { // ;\n          decls.push(value.slice(start, j))\n          start = j + 1\n        }\n      }\n      if (start < value.length) decls.push(value.slice(start))\n\n      let hasXSS = false\n      decls.forEach(decl => {\n        const colonIdx = decl.indexOf(':')\n        if (colonIdx === -1) return\n        const prop = decl.slice(0, colonIdx).trim()\n        const val = decl.slice(colonIdx + 1).trim()\n        if (prop && val) {\n          if (/url\\s*\\(\\s*(javascript|vbscript|data:(?!image\\/))/i.test(val)) {\n            hasXSS = true\n            if (process.env.NODE_ENV !== 'production') {\n              console.warn('Style attribute contains an unsafe URL expression, it will not be rendered.', val)\n            }\n            return\n          }\n          const camelProp = prop.indexOf('-') !== -1\n            ? prop.replace(/-([a-z])/g, (_, ch) => ch.toUpperCase())\n            : prop\n          styles[camelProp] = val\n        }\n      })\n      if (!hasXSS && Object.keys(styles).length > 0) {\n        attrs[name] = styles\n      }\n    } else if ((nameLower === 'href' || nameLower === 'src') && opts?.sanitizer) {\n      const sanitized = opts.sanitizer(value, tagName, nameLower)\n      if (sanitized !== null) {\n        attrs[name] = sanitized\n      }\n    } else if (value === '') {\n      attrs[name] = true\n    } else {\n      // Handle JSX interpolation: {expression} -> expression\n      if (value.length >= 2 && value.charCodeAt(0) === $.CHAR_BRACE_OPEN && value.charCodeAt(value.length - 1) === $.CHAR_BRACE_CLOSE) {\n        var inner = value.slice(1, -1)\n        // Try JSON.parse for arrays/objects\n        if (inner.length > 0) {\n          var fc = inner.charCodeAt(0)\n          if (fc === $.CHAR_BRACKET_OPEN || fc === $.CHAR_BRACE_OPEN) { // [ or {\n            try {\n              attrs[name] = JSON.parse(inner)\n              continue\n            } catch (e) { /* not valid JSON, fall through */ }\n          }\n        }\n        // Check boolean literals\n        if (inner === 'true') { attrs[name] = true; continue }\n        if (inner === 'false') { attrs[name] = false; continue }\n        // Eval unserializable expressions if opted in\n        if (opts?.evalUnserializableExpressions) {\n          try {\n            attrs[name] = (0, eval)('(' + inner + ')')\n            continue\n          } catch (e) { /* eval failed, keep as string */ }\n        }\n        attrs[name] = inner\n      } else {\n        attrs[name] = value\n      }\n    }\n  }\n\n  return attrs\n}\n\n/** Parse HTML attributes from a string */\nexport function parseHTMLAttributes(attrStr: string, tagName: string, opts: ParseOptions): Record<string, any> {\n  const attrs: Record<string, any> = {}\n  let i = 0\n  const len = attrStr.length\n\n  while (i < len) {\n    // Skip whitespace (space, tab, newline, carriage return)\n    var c = attrStr.charCodeAt(i)\n    while (i < len && (c === $.CHAR_SPACE || c === $.CHAR_TAB || c === $.CHAR_NEWLINE || c === $.CHAR_CR)) {\n      i++\n      c = attrStr.charCodeAt(i)\n    }\n    if (i >= len) break\n\n    // Parse attribute name (not whitespace, =, /, >)\n    const nameStart = i\n    c = attrStr.charCodeAt(i)\n    while (i < len && c !== $.CHAR_SPACE && c !== $.CHAR_TAB && c !== $.CHAR_NEWLINE && c !== $.CHAR_CR && c !== $.CHAR_EQ && c !== $.CHAR_SLASH && c !== $.CHAR_GT) {\n      i++\n      c = attrStr.charCodeAt(i)\n    }\n    if (i === nameStart) break\n    var name = attrStr.slice(nameStart, i)\n    var nameLower2 = name.toLowerCase()\n\n    // Skip whitespace\n    c = attrStr.charCodeAt(i)\n    while (i < len && (c === $.CHAR_SPACE || c === $.CHAR_TAB || c === $.CHAR_NEWLINE || c === $.CHAR_CR)) {\n      i++\n      c = attrStr.charCodeAt(i)\n    }\n\n    // Check for =\n    if (attrStr.charCodeAt(i) !== $.CHAR_EQ) {\n      attrs[name] = true\n      continue\n    }\n    i++ // skip =\n\n    // Skip whitespace\n    c = attrStr.charCodeAt(i)\n    while (i < len && (c === $.CHAR_SPACE || c === $.CHAR_TAB || c === $.CHAR_NEWLINE || c === $.CHAR_CR)) {\n      i++\n      c = attrStr.charCodeAt(i)\n    }\n\n    // Parse value\n    let value: string\n    const quote = attrStr.charCodeAt(i)\n    if (quote === $.CHAR_DOUBLE_QUOTE || quote === $.CHAR_SINGLE_QUOTE) { // \" or '\n      i++\n      const valueStart = i\n      while (i < len && attrStr.charCodeAt(i) !== quote) i++\n      value = attrStr.slice(valueStart, i)\n      if (i < len) i++ // skip closing quote\n    } else {\n      const valueStart = i\n      c = attrStr.charCodeAt(i)\n      while (i < len && c !== $.CHAR_SPACE && c !== $.CHAR_TAB && c !== $.CHAR_NEWLINE && c !== $.CHAR_CR && c !== $.CHAR_GT) {\n        i++\n        c = attrStr.charCodeAt(i)\n      }\n      value = attrStr.slice(valueStart, i)\n    }\n\n    // Handle special cases\n    if (nameLower2 === 'style') {\n      // Parse inline styles - handle url() values properly\n      const styles: Record<string, string> = {}\n      // Split by ; but not inside url()\n      let decls: string[] = []\n      let depth = 0\n      let start = 0\n      for (let j = 0; j < value.length; j++) {\n        const c = value.charCodeAt(j)\n        if (c === $.CHAR_PAREN_OPEN) depth++ // (\n        else if (c === $.CHAR_PAREN_CLOSE) depth-- // )\n        else if (c === $.CHAR_SEMICOLON && depth === 0) { // ;\n          decls.push(value.slice(start, j))\n          start = j + 1\n        }\n      }\n      if (start < value.length) decls.push(value.slice(start))\n\n      let hasXSS = false\n      decls.forEach(decl => {\n        // Split property: value, but only on first colon (handle url() with colons)\n        const colonIdx = decl.indexOf(':')\n        if (colonIdx === -1) return\n        const prop = decl.slice(0, colonIdx).trim()\n        const val = decl.slice(colonIdx + 1).trim()\n        if (prop && val) {\n          // Check for XSS in url() values\n          if (/url\\s*\\(\\s*(javascript|vbscript|data:(?!image\\/))/i.test(val)) {\n            hasXSS = true\n            if (process.env.NODE_ENV !== 'production') {\n              console.warn('Style attribute contains an unsafe URL expression, it will not be rendered.', val)\n            }\n            return\n          }\n          // Convert CSS property to camelCase\n          const camelProp = prop.indexOf('-') !== -1\n            ? prop.replace(/-([a-z])/g, (_, ch) => ch.toUpperCase())\n            : prop\n          styles[camelProp] = val\n        }\n      })\n      // If XSS was detected, don't include any styles\n      if (!hasXSS && Object.keys(styles).length > 0) {\n        attrs[name] = styles\n      }\n    } else if ((nameLower2 === 'href' || nameLower2 === 'src') && opts?.sanitizer) {\n      // Sanitize href and src attributes\n      const sanitized = opts.sanitizer(value, tagName, nameLower2)\n      if (sanitized !== null) {\n        attrs[name] = sanitized\n      }\n      // if null, don't include the attribute (security)\n    } else {\n      attrs[name] = value\n    }\n  }\n\n  return attrs\n}\n\n/** Case-insensitive indexOf without allocating new string */\nfunction indexOfCI(str: string, search: string, from: number): number {\n  const searchLen = search.length\n  // Pre-compute lowercase first char for fast rejection\n  var fc = search.charCodeAt(0)\n  if (fc >= $.CHAR_A && fc <= $.CHAR_Z) fc += $.CHAR_CASE_OFFSET\n  for (let j = from; j <= str.length - searchLen; j++) {\n    // Fast first-char check before entering inner loop\n    var c0 = str.charCodeAt(j)\n    if (c0 >= $.CHAR_A && c0 <= $.CHAR_Z) c0 += $.CHAR_CASE_OFFSET\n    if (c0 !== fc) continue\n    let match = true\n    for (let k = 1; k < searchLen; k++) {\n      let c1 = str.charCodeAt(j + k)\n      let c2 = search.charCodeAt(k)\n      if (c1 >= $.CHAR_A && c1 <= $.CHAR_Z) c1 += $.CHAR_CASE_OFFSET\n      if (c2 >= $.CHAR_A && c2 <= $.CHAR_Z) c2 += $.CHAR_CASE_OFFSET\n      if (c1 !== c2) { match = false; break }\n    }\n    if (match) return j\n  }\n  return -1\n}\n\n/** Case-insensitive lastIndexOf without allocating new string */\nfunction lastIndexOfCI(str: string, search: string, from: number): number {\n  const searchLen = search.length\n  var fc = search.charCodeAt(0)\n  if (fc >= $.CHAR_A && fc <= $.CHAR_Z) fc += $.CHAR_CASE_OFFSET\n  for (let j = Math.min(from, str.length - searchLen); j >= 0; j--) {\n    var c0 = str.charCodeAt(j)\n    if (c0 >= $.CHAR_A && c0 <= $.CHAR_Z) c0 += $.CHAR_CASE_OFFSET\n    if (c0 !== fc) continue\n    let match = true\n    for (let k = 1; k < searchLen; k++) {\n      let c1 = str.charCodeAt(j + k)\n      let c2 = search.charCodeAt(k)\n      if (c1 >= $.CHAR_A && c1 <= $.CHAR_Z) c1 += $.CHAR_CASE_OFFSET\n      if (c2 >= $.CHAR_A && c2 <= $.CHAR_Z) c2 += $.CHAR_CASE_OFFSET\n      if (c1 !== c2) { match = false; break }\n    }\n    if (match) return j\n  }\n  return -1\n}\n/** Find matching closing tag (case-insensitive without allocation) */\nvar _closeTagStart = -1 // start of closing tag (e.g. position of <)\nfunction findClosingTag(s: string, start: number, tagName: string): number {\n  const tagLower = tagName.toLowerCase()\n  const openTag = '<' + tagLower\n  const closeTag = '</' + tagLower\n  let depth = 1\n  let i = start\n  const len = s.length\n  _closeTagStart = -1\n\n  while (i < len && depth > 0) {\n    const openIdx = indexOfCI(s, openTag, i)\n    const closeIdx = indexOfCI(s, closeTag, i)\n\n    if (closeIdx === -1) return -1 // No closing tag found\n\n    if (openIdx !== -1 && openIdx < closeIdx) {\n      // Use __parseHTMLTag to correctly identify if it's an opening tag and not self-closing\n      const res = __parseHTMLTag(s, openIdx)\n      if (res) {\n        // Only count as nested open if tag name matches exactly (not just a prefix like AccordionItem matching Accordion)\n        if (res.tag.toLowerCase() === tagLower && !res.isClosing && !res.selfClosing && !util.isVoidElement(res.tag)) {\n          depth++\n        }\n        i = res.end\n      } else {\n        i = openIdx + 1\n      }\n    } else {\n      // Found closing tag - verify it's the exact tag (not a prefix of a longer tag name)\n      var afterClosePos = closeIdx + closeTag.length\n      var afterClose = afterClosePos < len ? s.charCodeAt(afterClosePos) : 62 // treat EOF as >\n      if (afterClose === $.CHAR_GT || afterClose === $.CHAR_SPACE || afterClose === $.CHAR_TAB || afterClose === $.CHAR_NEWLINE) {\n        depth--\n        if (depth === 0) {\n          _closeTagStart = closeIdx\n          // Find end of closing tag\n          let j = closeIdx + closeTag.length\n          while (j < len && s.charCodeAt(j) !== $.CHAR_GT) j++\n          return j + 1\n        }\n      }\n      i = closeIdx + 1\n    }\n  }\n\n  return -1\n}\n\n/** Scan HTML block */\nfunction scanHTMLBlock(s: string, p: number, state: MarkdownToJSX.State, opts: ParseOptions): ScanResult {\n  if (opts.ignoreHTMLBlocks || opts.disableParsingRawHTML) return null\n\n  var e = lineEnd(s, p)\n  indent(s, p, e)\n  // HTML blocks can be indented up to 3 spaces (unless we are already in an HTML block)\n  if (_indentSpaces > 3 && !state.inHTML) return null\n\n  var start = p + _indentChars\n  if (s.charCodeAt(start) !== $.CHAR_LT) return null\n\n  // Check for autolink (URL or email) - these are not HTML blocks\n  var closeAngle = s.indexOf('>', start + 1)\n  if (closeAngle !== -1 && closeAngle < e) {\n    var content = s.slice(start + 1, closeAngle)\n    if (/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(content) || /^[^\\s@]+@[^\\s@]+$/.test(content)) {\n      return null\n    }\n  }\n\n  // --- CommonMark HTML block type detection ---\n  var htmlBlockType = detectHTMLBlockType(s, start)\n\n  // Types 1-5: raw HTML block ending at specific pattern\n  // Use indexOf/indexOfCI instead of per-line regex to avoid slice allocations\n  if (htmlBlockType >= 1 && htmlBlockType <= 5) {\n    var rawEnd = s.length\n    if (htmlBlockType === 1) {\n      // Search for closing tags of Type 1 elements (case-insensitive)\n      var bestPos = s.length\n      for (var ti = 0; ti < TYPE1_TAG_LIST.length; ti++) {\n        var pos = indexOfCI(s, '</' + TYPE1_TAG_LIST[ti] + '>', start)\n        if (pos >= 0 && pos < bestPos) bestPos = pos\n      }\n      if (bestPos < s.length) {\n        // Find the > that closes the tag\n        var closeGT = s.indexOf('>', bestPos)\n        rawEnd = closeGT >= 0 ? nextLine(s, closeGT + 1) : s.length\n      }\n    } else {\n      // Types 2-5: simple string search\n      var searchStr = htmlBlockType === 2 ? '-->' : htmlBlockType === 3 ? '?>' : htmlBlockType === 4 ? '>' : ']]>'\n      var foundPos = s.indexOf(searchStr, start)\n      if (foundPos >= 0) {\n        rawEnd = nextLine(s, foundPos + searchStr.length)\n      }\n    }\n    var rawText = s.slice(start, rawEnd)\n\n    // Types 2-5: comments, processing instructions, declarations, CDATA\n    // These should be htmlComment nodes, not htmlBlock\n    if (htmlBlockType >= 2) {\n      return {\n        node: {\n          type: RuleType.htmlComment,\n          text: rawText,\n          raw: true,\n          endPos: rawEnd,\n        } as MarkdownToJSX.HTMLCommentNode & { raw: boolean; endPos: number },\n        end: rawEnd\n      }\n    }\n\n    // Type 1: extract tag name, attrs, and parse children\n    var type1TagName = 'div'\n    var type1Match = rawText.match(/^<\\/?([a-zA-Z][a-zA-Z0-9-]*)/)\n    if (type1Match) type1TagName = type1Match[1]\n\n    // Parse the opening tag for attrs\n    var type1TagResult = __parseHTMLTag(s, start)\n    var type1Attrs: Record<string, any> = {}\n    var type1RawAttrs: string | undefined\n    if (type1TagResult && !type1TagResult.isClosing) {\n      type1Attrs = processHTMLAttributes(type1TagResult.attrs, type1TagName, opts)\n      type1RawAttrs = type1TagResult.whitespaceBeforeAttrs + type1TagResult.rawAttrs\n    }\n\n    // Parse children from content between opening and closing tags\n    // rawText = content after opening tag (may include closing tag) per reference parser\n    var type1Children: MarkdownToJSX.ASTNode[] = []\n    var type1TagNameLower = type1TagName.toLowerCase()\n    var type1ClosePattern = '</' + type1TagNameLower\n    var type1CloseIdx = indexOfCI(rawText, type1ClosePattern, 0)\n    var type1RawText = rawText // default: full block\n    var type1TextContent = ''\n    if (type1TagResult && type1TagResult.isClosing) {\n      // Closing tag: rawText = content after the closing tag\n      type1RawText = rawText.slice(type1TagResult.end - start)\n      while (type1RawText.length > 0 && type1RawText.charCodeAt(type1RawText.length - 1) === $.CHAR_NEWLINE)\n        type1RawText = type1RawText.slice(0, -1)\n    } else if (type1TagResult && !type1TagResult.isClosing) {\n      var type1ContentStart = type1TagResult.end - start\n      if (type1CloseIdx !== -1) {\n        // Has closing tag: rawText = content after opening tag\n        type1RawText = rawText.slice(type1ContentStart)\n        if (type1RawText.charCodeAt(0) === $.CHAR_NEWLINE) type1RawText = type1RawText.slice(1)\n        while (type1RawText.length > 0 && type1RawText.charCodeAt(type1RawText.length - 1) === $.CHAR_NEWLINE)\n          type1RawText = type1RawText.slice(0, -1)\n      } else {\n        // No closing tag: rawText = full block including opening tag\n        // (matches reference parser behavior, prevents HTML compiler from adding closing tag)\n        type1RawText = rawText\n        while (type1RawText.length > 0 && type1RawText.charCodeAt(type1RawText.length - 1) === $.CHAR_NEWLINE)\n          type1RawText = type1RawText.slice(0, -1)\n      }\n      if (type1CloseIdx !== -1) {\n        var type1Content = rawText.slice(type1ContentStart, type1CloseIdx)\n        type1TextContent = type1Content.trim()\n      }\n    }\n\n    var type1IsClosing = type1TagResult ? type1TagResult.isClosing : false\n    return {\n      node: {\n        type: RuleType.htmlBlock,\n        tag: type1TagName,\n        attrs: type1Attrs,\n        _rawAttrs: type1RawAttrs,\n        children: type1Children,\n        _rawText: type1RawText,\n        text: type1TextContent,\n        _verbatim: true,\n        _isClosingTag: type1IsClosing,\n        endPos: rawEnd,\n        canInterruptParagraph: true,\n      } as MarkdownToJSX.HTMLNode & { _isClosingTag: boolean; endPos: number; canInterruptParagraph: boolean },\n      end: rawEnd\n    }\n  }\n\n  // Types 6-7: HTML block ending at blank line\n  if (htmlBlockType === 6 || htmlBlockType === 7) {\n    var blankEnd = findNextBlankLine(s, p)\n    var rawEnd6 = blankEnd < s.length ? blankEnd : s.length\n    var rawText6 = s.slice(start, rawEnd6)\n    var end6 = blankEnd < s.length ? nextLine(s, blankEnd) : s.length\n\n    // Try structured parsing to extract tag name and attributes\n    var tagResult67 = __parseHTMLTag(s, start)\n\n    if (tagResult67) {\n      var tagName67 = tagResult67.tag\n      var tagNameLower67 = tagName67.toLowerCase()\n      var type67IsClosing = tagResult67.isClosing\n\n      // Closing tag path\n      if (type67IsClosing) {\n        var afterTag67 = s.slice(tagResult67.end, rawEnd6)\n        return {\n          node: {\n            type: RuleType.htmlBlock,\n            tag: tagName67,\n            attrs: {},\n            children: [],\n            _rawText: afterTag67,\n            text: afterTag67,\n            _verbatim: true,\n            _isClosingTag: true,\n            endPos: rawEnd6,\n            canInterruptParagraph: htmlBlockType === 6,\n          } as MarkdownToJSX.HTMLNode & { _isClosingTag: boolean; endPos: number; canInterruptParagraph: boolean },\n          end: end6\n        }\n      }\n\n      // Void/self-closing elements: return immediately with no content\n      if (tagResult67.selfClosing || util.isVoidElement(tagName67)) {\n        return {\n          node: {\n            type: RuleType.htmlBlock,\n            tag: tagName67,\n            attrs: processHTMLAttributes(tagResult67.attrs, tagName67, opts),\n            _rawAttrs: tagResult67.whitespaceBeforeAttrs + tagResult67.rawAttrs,\n            children: [],\n            _rawText: '',\n            text: '',\n            _verbatim: false,\n            _isClosingTag: false,\n            endPos: tagResult67.end,\n            canInterruptParagraph: htmlBlockType === 6,\n          } as MarkdownToJSX.HTMLNode & { _isClosingTag: boolean; endPos: number; canInterruptParagraph: boolean },\n          end: nextLine(s, tagResult67.end)\n        }\n      }\n\n      // Opening tag - search for closing tag WITHIN this block (before blank line)\n      // Limit search depth to prevent O(n²) on deeply nested same-tag structures\n      var htmlDepth67 = (state._htmlDepth || 0)\n      var blockContent67 = s.slice(start, rawEnd6)\n      var closeIdx67 = -1\n      var closeEndRel67 = -1\n      if (htmlDepth67 < 10) {\n        var closeTag67 = '</' + tagNameLower67\n        var searchStart67 = tagResult67.end - start\n        var depth67 = 1\n        var ci67 = searchStart67\n        while (ci67 < blockContent67.length && depth67 > 0) {\n          var openIdx67 = indexOfCI(blockContent67, '<' + tagNameLower67, ci67)\n          var cIdx67 = indexOfCI(blockContent67, closeTag67, ci67)\n\n          if (cIdx67 === -1) break // no closing tag in block\n\n          if (openIdx67 !== -1 && openIdx67 < cIdx67) {\n            // Check if it's a real opening tag (not a prefix match)\n            var afterOpen67 = openIdx67 + tagNameLower67.length + 1\n            if (afterOpen67 < blockContent67.length) {\n              var ac67 = blockContent67.charCodeAt(afterOpen67)\n              if (ac67 === $.CHAR_SPACE || ac67 === $.CHAR_TAB || ac67 === $.CHAR_NEWLINE || ac67 === $.CHAR_GT || ac67 === $.CHAR_SLASH) {\n                depth67++\n              }\n            }\n            ci67 = openIdx67 + 1\n          } else {\n            // Check closing tag is exact match\n            var afterClose67 = cIdx67 + closeTag67.length\n            if (afterClose67 < blockContent67.length) {\n              var ac67c = blockContent67.charCodeAt(afterClose67)\n              if (ac67c === $.CHAR_GT || ac67c === $.CHAR_SPACE || ac67c === $.CHAR_TAB || ac67c === $.CHAR_NEWLINE) {\n                depth67--\n                if (depth67 === 0) {\n                  closeIdx67 = cIdx67\n                  // Find end of closing tag (past >)\n                  var j67 = afterClose67\n                  while (j67 < blockContent67.length && blockContent67.charCodeAt(j67) !== $.CHAR_GT) j67++\n                  closeEndRel67 = j67 + 1\n                  break\n                }\n              }\n            } else {\n              // At end of block content, treat > as present\n              depth67--\n              if (depth67 === 0) {\n                closeIdx67 = cIdx67\n                closeEndRel67 = blockContent67.length\n                break\n              }\n            }\n            ci67 = cIdx67 + 1\n          }\n        }\n\n        // Block extension: when no closing tag found within block (before blank line),\n        // search beyond for the closing tag. If content between tags has blank lines\n        // (block content), extend the block to include the closing tag.\n        // This matches reference parser behavior for cases like <div>...\\n\\n</div>\n        // Exclude table-related tags to preserve inner structure across blank lines.\n        var blockWasExtended67 = false\n        if (closeIdx67 === -1 && htmlBlockType === 6 && !tagResult67.isClosing && !TABLE_TAGS.has(tagNameLower67)) {\n          var extSearchContent = s.slice(tagResult67.end)\n          var extCloseIdx = indexOfCI(extSearchContent, closeTag67, 0)\n          if (extCloseIdx !== -1) {\n            var extContent = extSearchContent.slice(0, extCloseIdx)\n            // Only extend if content has blank lines (block content)\n            if (extContent.indexOf('\\n\\n') !== -1) {\n              var extCloseAbs = tagResult67.end + extCloseIdx\n              var extAfterClose = extCloseAbs + closeTag67.length\n              while (extAfterClose < s.length && s.charCodeAt(extAfterClose) !== $.CHAR_GT) extAfterClose++\n              if (extAfterClose < s.length && s.charCodeAt(extAfterClose) === $.CHAR_GT) {\n                var extCloseEnd = extAfterClose + 1\n                var extLineEnd = lineEnd(s, extCloseEnd)\n                // Extend block boundaries\n                rawEnd6 = extLineEnd\n                end6 = nextLine(s, extLineEnd)\n                blockContent67 = s.slice(start, rawEnd6)\n                rawText6 = s.slice(start, rawEnd6)\n                closeIdx67 = extCloseAbs - start\n                closeEndRel67 = extCloseEnd - start\n                blockWasExtended67 = true\n              }\n            }\n          }\n        }\n      }\n\n      // Determine if opening tag has multi-line attributes\n      var hasMultiLineAttrs67 = tagResult67.rawAttrs.indexOf('\\n') !== -1 ||\n        tagResult67.whitespaceBeforeAttrs.indexOf('\\n') !== -1\n\n      // Check if closing tag is the last meaningful content in the block\n      var isCleanBlock67 = false\n      if (closeIdx67 !== -1) {\n        var afterCloseInBlock67 = blockContent67.slice(closeEndRel67).trim()\n        isCleanBlock67 = afterCloseInBlock67.length === 0\n      }\n\n      // When a closing tag is found, check if subsequent content starts with another\n      // HTML tag. If so, limit block to the closing tag line to allow sibling tags\n      // (e.g., <dt>...</dt>\\n<dd>...</dd>) to be parsed separately.\n      var useInHTMLBounds = false\n      var effectiveEndPos = rawEnd6\n      var effectiveEnd = end6\n      if (closeIdx67 !== -1) {\n        var closeAbsPos = start + closeEndRel67\n        var closeLineEndPos = lineEnd(s, closeAbsPos - 1)\n        // Check for same-line sibling tags after closing tag (e.g. <dt>foo</dt><dd>bar</dd>)\n        if (closeAbsPos < closeLineEndPos) {\n          var slp67 = closeAbsPos\n          while (slp67 < closeLineEndPos && (s.charCodeAt(slp67) === $.CHAR_SPACE || s.charCodeAt(slp67) === $.CHAR_TAB)) slp67++\n          if (slp67 < closeLineEndPos && s.charCodeAt(slp67) === $.CHAR_LT) { // '<'\n            var sameLineSibling67 = __parseHTMLTag(s, slp67)\n            if (sameLineSibling67 && !sameLineSibling67.isClosing) {\n              useInHTMLBounds = true\n              effectiveEndPos = closeAbsPos\n              effectiveEnd = closeAbsPos\n              isCleanBlock67 = true\n            }\n          }\n        }\n        // Check content on lines after closing tag for another HTML tag\n        if (!useInHTMLBounds) {\n          var nextLineStart67 = nextLine(s, closeLineEndPos)\n          if (nextLineStart67 < rawEnd6) {\n            // Skip leading whitespace on next line\n            var nlp67 = nextLineStart67\n            while (nlp67 < rawEnd6 && (s.charCodeAt(nlp67) === $.CHAR_SPACE || s.charCodeAt(nlp67) === $.CHAR_TAB)) nlp67++\n            if (nlp67 < rawEnd6 && s.charCodeAt(nlp67) === $.CHAR_LT) { // '<'\n              // Next line starts with HTML tag - check if it's a valid tag\n              var nextTag67 = __parseHTMLTag(s, nlp67)\n              if (nextTag67) {\n                // Stop block at closing tag line\n                useInHTMLBounds = true\n                effectiveEndPos = closeLineEndPos\n                effectiveEnd = nextLineStart67\n                isCleanBlock67 = true\n              }\n            }\n          }\n        }\n        // Also limit when inside HTML\n        if (!useInHTMLBounds && state.inHTML) {\n          useInHTMLBounds = true\n          effectiveEndPos = closeLineEndPos\n          effectiveEnd = nextLine(s, closeLineEndPos)\n          var afterCloseOnLine = s.slice(closeAbsPos, closeLineEndPos).trim()\n          isCleanBlock67 = afterCloseOnLine.length === 0\n        }\n      }\n\n      // Parse children for React/JSX renderers\n      var children67: MarkdownToJSX.ASTNode[] = []\n      var rawContent67 = ''\n      if (closeIdx67 !== -1) {\n        rawContent67 = blockContent67.slice(tagResult67.end - start, closeIdx67)\n        var trimmed67 = rawContent67.trim()\n\n        if (trimmed67) {\n          // Save state, set HTML context for recursive parsing\n          var s_inline67 = state.inline, s_inHTML67 = state.inHTML, s_htmlDepth67 = state._htmlDepth\n          state.inHTML = true; state._htmlDepth = htmlDepth67 + 1\n          // <p> can only contain inline/phrasing content per HTML spec, so always\n          // use inline parsing — avoids block rules misinterpreting HTML angle\n          // brackets (e.g. \">\" on its own line) as blockquote markers\n          var isPTag67 = tagNameLower67 === 'p'\n          if (isPTag67) {\n            state.inline = true\n            children67 = parseInline(trimmed67, 0, trimmed67.length, state, opts)\n          } else {\n            // Detect block content using raw content (before trim) to preserve blank line detection\n            var hasDoubleNewline67 = rawContent67.indexOf('\\n\\n') !== -1\n            var hasBlockSyntax67 = /^(\\s{0,3}#[#\\s]|\\s{0,3}[-*+]\\s|\\s{0,3}\\d+\\.\\s|\\s{0,3}>\\s|\\s{0,3}```)/m.test(trimmed67)\n            var hasHTMLTags67 = /^<([a-z][^ >/\\n\\r]*) ?([^>]*?)>/im.test(trimmed67)\n            var contentHasBlocks67 = hasDoubleNewline67 || hasBlockSyntax67 || (state.inHTML && hasHTMLTags67)\n\n            if (contentHasBlocks67 || hasHTMLTags67) {\n              state.inline = false\n              children67 = parseBlocks(rawContent67, state, opts)\n            } else {\n              state.inline = true\n              children67 = parseInline(trimmed67, 0, trimmed67.length, state, opts)\n            }\n          }\n          // Restore state\n          state.inline = s_inline67; state.inHTML = s_inHTML67; state._htmlDepth = s_htmlDepth67\n        }\n      }\n\n      // Decide verbatim flag:\n      // - Inside HTML (parsing children) → always verbatim\n      // - Type 7 blocks → always verbatim (generic tags, reference parser behavior)\n      // - Multi-line attributes → verbatim (rawText = content between tags)\n      // - Content after closing tag → verbatim (rawText = full block)\n      // - No closing tag → verbatim (rawText = full block)\n      // - Type 6 with closing tag + inline-only content → verbatim (reference parser behavior)\n      //   This allows the React compiler to re-parse rawText and handle sibling tags\n      // - Clean block (closing tag is last) → not verbatim (children used)\n      // Type 6 blocks with inline content containing HTML tags should be verbatim\n      // to allow React compiler to re-parse and split sibling elements (e.g., dt/dd)\n      var type6InlineVerbatim67 = false\n      if (htmlBlockType === 6 && closeIdx67 !== -1 && !state.inHTML && !hasMultiLineAttrs67) {\n        var contentBetween67 = rawContent67\n        // Only force verbatim if content has HTML tags (sibling elements to split)\n        // AND no block-level syntax (which needs children-based parsing)\n        var hasHTMLInContent67 = /<[a-zA-Z][^>]*>/.test(contentBetween67)\n        var hasBlockInContent67 = /\\n\\n/.test(contentBetween67) ||\n          /^(\\s{0,3}#[#\\s]|\\s{0,3}[-*+]\\s|\\s{0,3}\\d+\\.\\s|\\s{0,3}>\\s|\\s{0,3}```)/m.test(contentBetween67)\n        if (hasHTMLInContent67 && !hasBlockInContent67) {\n          type6InlineVerbatim67 = true\n        }\n      }\n      var useVerbatim67 = state.inHTML || htmlBlockType === 7 || hasMultiLineAttrs67 || !isCleanBlock67 || type6InlineVerbatim67\n\n      if (useVerbatim67) {\n        // Determine rawText based on context:\n        // - inHTML with close tag: content between tags (rawContent67)\n        // - Type 7 with close tag: content after opening tag including close tag\n        // - Type 6 multi-line attrs: full block text from start (HTML compiler expects this)\n        // - inHTML without close tag: block from start to effective end\n        // - Others: full block text from start (rawText6)\n        var rawText67v: string\n        if (closeIdx67 !== -1 && useInHTMLBounds) {\n          // When inside HTML with same-line siblings after closing tag,\n          // rawText includes everything from after opening tag (including closing tag\n          // and siblings). The React compiler re-parses rawText to split siblings.\n          // Only extend rawText when sibling tags exist on the SAME LINE after closing tag\n          var hasAfterClose67 = false\n          if (state.inHTML && closeEndRel67 < blockContent67.length) {\n            // Check same-line content only (stop at newline)\n            var sameLineEnd67 = closeEndRel67\n            while (sameLineEnd67 < blockContent67.length && blockContent67.charCodeAt(sameLineEnd67) !== $.CHAR_NEWLINE) sameLineEnd67++\n            var sameLineAfter67 = blockContent67.slice(closeEndRel67, sameLineEnd67).trim()\n            // Must be an opening tag (not closing tag like </div>)\n            hasAfterClose67 = sameLineAfter67.length > 1 &&\n              sameLineAfter67.charCodeAt(0) === $.CHAR_LT && // '<'\n              sameLineAfter67.charCodeAt(1) !== $.CHAR_SLASH // not '/'\n          }\n          rawText67v = hasAfterClose67\n            ? blockContent67.slice(tagResult67.end - start)\n            : rawContent67\n        } else if ((htmlBlockType === 7 || state.inHTML) && closeIdx67 !== -1) {\n          // For Type 7 and inHTML: rawText = content after opening tag including close tag\n          rawText67v = blockContent67.slice(tagResult67.end - start)\n          // Strip leading newline (reference parser behavior)\n          if (rawText67v.charCodeAt(0) === $.CHAR_NEWLINE) rawText67v = rawText67v.slice(1)\n        } else if (useInHTMLBounds) {\n          rawText67v = s.slice(start, effectiveEndPos)\n        } else if (hasMultiLineAttrs67) {\n          rawText67v = rawText6\n        } else {\n          // Content after opening tag (not including opening tag itself)\n          rawText67v = blockContent67.slice(tagResult67.end - start)\n          if (rawText67v.charCodeAt(0) === $.CHAR_NEWLINE) rawText67v = rawText67v.slice(1)\n        }\n\n        return {\n          node: {\n            type: RuleType.htmlBlock,\n            tag: tagName67,\n            attrs: processHTMLAttributes(tagResult67.attrs, tagName67, opts),\n            _rawAttrs: tagResult67.whitespaceBeforeAttrs + tagResult67.rawAttrs,\n            children: children67,\n            _rawText: rawText67v,\n            text: rawText67v,\n            _verbatim: true,\n            _isClosingTag: false,\n            endPos: effectiveEndPos,\n            canInterruptParagraph: htmlBlockType === 6,\n          } as MarkdownToJSX.HTMLNode & { _isClosingTag: boolean; endPos: number; canInterruptParagraph: boolean },\n          end: effectiveEnd\n        }\n      }\n\n      // Clean block with closing tag as last content - not verbatim\n      // For block-extended nodes (content has blank lines), clear rawText so\n      // HTML compiler uses children path instead of rawText path\n      return {\n        node: {\n          type: RuleType.htmlBlock,\n          tag: tagName67,\n          attrs: processHTMLAttributes(tagResult67.attrs, tagName67, opts),\n          _rawAttrs: tagResult67.whitespaceBeforeAttrs + tagResult67.rawAttrs,\n          children: children67,\n          _rawText: blockWasExtended67 ? '' : rawContent67,\n          text: rawContent67,\n          _verbatim: false,\n          _isClosingTag: false,\n          endPos: effectiveEndPos,\n          canInterruptParagraph: htmlBlockType === 6,\n        } as MarkdownToJSX.HTMLNode & { _isClosingTag: boolean; endPos: number; canInterruptParagraph: boolean },\n        end: effectiveEnd\n      }\n    }\n\n    // __parseHTMLTag failed - fallback to raw text extraction\n    var type67Match = rawText6.match(/^<(\\/?)([a-zA-Z][a-zA-Z0-9-]*)/)\n    var type67TagF = type67Match ? type67Match[2] : 'div'\n    var type67IsClosingF = type67Match ? type67Match[1] === '/' : false\n    var type67RawTextF = rawText6\n    if (type67IsClosingF) {\n      var closeAngle67 = rawText6.indexOf('>')\n      if (closeAngle67 !== -1) {\n        type67RawTextF = rawText6.slice(closeAngle67 + 1)\n      }\n    }\n\n    return {\n      node: {\n        type: RuleType.htmlBlock,\n        tag: type67TagF,\n        attrs: {},\n        children: [],\n        _rawText: type67RawTextF,\n        text: type67RawTextF,\n        _verbatim: true,\n        _isClosingTag: type67IsClosingF,\n        endPos: rawEnd6,\n        canInterruptParagraph: htmlBlockType === 6,\n      } as MarkdownToJSX.HTMLNode & { _isClosingTag: boolean; endPos: number; canInterruptParagraph: boolean },\n      end: end6\n    }\n  }\n\n  // Not a CommonMark HTML block - try structured parsing for JSX/React components\n  var tagResult = __parseHTMLTag(s, start)\n  if (!tagResult) return null\n\n  var tagName = tagResult.tag\n  var tagNameLower = tagName.toLowerCase()\n  var firstChar = tagName.charCodeAt(0)\n  var isJSX = firstChar >= $.CHAR_A && firstChar <= $.CHAR_Z\n  // Skip tags that aren't block-level for block parsing\n  // Known lowercase tags not in BLOCK_TAGS/TYPE1_TAGS are inline — skip them here\n  // Custom elements (contain hyphen, e.g. <my-widget>) proceed to block parsing\n  if (!isJSX && !BLOCK_TAGS.has(tagNameLower) && !TYPE1_TAGS.has(tagNameLower) &&\n      !tagNameLower.includes('-')) return null\n\n  // Closing tag\n  if (tagResult.isClosing) {\n    return {\n      node: {\n        type: RuleType.htmlSelfClosing,\n        tag: tagName,\n        attrs: {},\n        endPos: tagResult.end,\n        _isClosingTag: true,\n        _rawText: s.slice(start, tagResult.end),\n      } as MarkdownToJSX.HTMLSelfClosingNode & { endPos: number; _isClosingTag: boolean; _rawText: string },\n      end: tagResult.end\n    }\n  }\n\n  var shouldSearchForClosingTag = true\n  var closeEnd = findClosingTag(s, tagResult.end, tagName)\n\n  var children: MarkdownToJSX.ASTNode[] = []\n  if (closeEnd !== -1) {\n    var contentEnd = _closeTagStart\n    var rawContent = s.slice(tagResult.end, contentEnd)\n    var trimmed = rawContent.trim()\n    if (trimmed) {\n      // Detect block content vs inline content (same logic as Type 6/7 path)\n      var hasDoubleNL = rawContent.indexOf('\\n\\n') !== -1\n      var hasBlockSyn = /^(\\s{0,3}#[#\\s]|\\s{0,3}[-*+]\\s|\\s{0,3}\\d+\\.\\s|\\s{0,3}>\\s|\\s{0,3}```)/m.test(trimmed)\n      var hasHTMLTagsS = /^<([a-z][^ >/\\n\\r]*) ?([^>]*?)>/im.test(trimmed)\n      var s_inl = state.inline, s_htm = state.inHTML, s_hd = state._htmlDepth\n      state.inHTML = true; state._htmlDepth = (state._htmlDepth || 0) + 1\n      if (hasDoubleNL || hasBlockSyn || hasHTMLTagsS) {\n        state.inline = false\n        children = parseBlocks(rawContent, state, opts)\n      } else {\n        state.inline = true\n        children = parseInline(trimmed, 0, trimmed.length, state, opts)\n      }\n      state.inline = s_inl; state.inHTML = s_htm; state._htmlDepth = s_hd\n    }\n\n    var lineEndPos = lineEnd(s, closeEnd)\n    var afterClose = s.slice(closeEnd, lineEndPos).trim()\n    var endPos = afterClose ? closeEnd : nextLine(s, closeEnd)\n\n    // _rawText: full block from start (including opening tag) for React compiler's re-parse logic\n    var rawTextJSX = isJSX ? s.slice(start, closeEnd) : s.slice(start, endPos)\n    var nodeEndPos = isJSX ? closeEnd : endPos\n\n    return {\n      node: {\n        type: RuleType.htmlBlock,\n        tag: tagName,\n        attrs: processHTMLAttributes(tagResult.attrs, tagName, opts),\n        _rawAttrs: tagResult.whitespaceBeforeAttrs + tagResult.rawAttrs,\n        children,\n        _rawText: rawTextJSX,\n        text: isJSX ? rawContent : rawTextJSX,\n        _verbatim: true,\n        _isClosingTag: false,\n        endPos: nodeEndPos,\n        canInterruptParagraph: false,\n      } as MarkdownToJSX.HTMLNode & { _isClosingTag: boolean; endPos: number; canInterruptParagraph: boolean },\n      end: endPos\n    }\n  }\n\n  // No closing tag found - go until blank line\n  var blankLineEnd = findNextBlankLine(s, tagResult.end)\n  var endFallback = blankLineEnd < s.length ? nextLine(s, blankLineEnd) : blankLineEnd\n  var contentFallback = s.slice(tagResult.end, blankLineEnd)\n\n  if (contentFallback.trim()) {\n    var s_inlF = state.inline, s_htmF = state.inHTML, s_hdF = state._htmlDepth\n    state.inline = false; state.inHTML = true; state._htmlDepth = (state._htmlDepth || 0) + 1\n    children = parseBlocks(contentFallback, state, opts)\n    state.inline = s_inlF; state.inHTML = s_htmF; state._htmlDepth = s_hdF\n  }\n\n  var rawTextFallback = s.slice(tagResult.end, blankLineEnd)\n\n  return {\n    node: {\n      type: RuleType.htmlBlock,\n      tag: tagName,\n      attrs: processHTMLAttributes(tagResult.attrs, tagName, opts),\n      _rawAttrs: tagResult.whitespaceBeforeAttrs + tagResult.rawAttrs,\n      children,\n      _rawText: rawTextFallback,\n      text: contentFallback,\n      _verbatim: true,\n      _isClosingTag: false,\n      endPos: blankLineEnd,\n      canInterruptParagraph: false,\n    } as MarkdownToJSX.HTMLNode & { _isClosingTag: boolean; endPos: number; canInterruptParagraph: boolean },\n    end: endFallback\n  }\n}\n\n/** Detect CommonMark HTML block type (1-7) or 0 if not an HTML block */\nfunction detectHTMLBlockType(s: string, p: number): number {\n  if (s.charCodeAt(p) !== $.CHAR_LT) return 0\n  var i = p + 1\n  var len = s.length\n\n  // Type 2: <!-- comment\n  if (s.charCodeAt(i) === $.CHAR_EXCLAMATION && s.charCodeAt(i + 1) === $.CHAR_DASH && s.charCodeAt(i + 2) === $.CHAR_DASH) return 2\n\n  // Type 3: <? processing instruction\n  if (s.charCodeAt(i) === $.CHAR_QUESTION) return 3\n\n  // Type 4: <!LETTER declaration\n  if (s.charCodeAt(i) === $.CHAR_EXCLAMATION) {\n    var nc = s.charCodeAt(i + 1)\n    if (nc >= $.CHAR_A && nc <= $.CHAR_Z) return 4\n    // Type 5: <![CDATA[\n    if (s.slice(i + 1, i + 8) === '[CDATA[') return 5\n  }\n\n  // Extract tag name for types 1, 6, 7\n  var isClosing = s.charCodeAt(i) === $.CHAR_SLASH\n  var nameStart = isClosing ? i + 1 : i\n  var nameEnd = nameStart\n  while (nameEnd < len) {\n    var cc = s.charCodeAt(nameEnd)\n    if ((cc >= $.CHAR_A && cc <= $.CHAR_Z) || (cc >= $.CHAR_a && cc <= $.CHAR_z) || (cc >= $.CHAR_DIGIT_0 && cc <= $.CHAR_DIGIT_9) || cc === $.CHAR_DASH) {\n      nameEnd++\n    } else break\n  }\n  if (nameEnd === nameStart) return 0\n  var tagName = s.slice(nameStart, nameEnd)\n\n  // Type 1: <pre, <script, <style, <textarea (opening only — closing tags don't start type 1)\n  if (TYPE1_TAGS.has(tagName.toLowerCase())) {\n    if (isClosing) {\n      // Closing tags of type 1 elements do NOT start HTML blocks per CommonMark spec\n      // They serve as end conditions for already-open type 1 blocks\n      return 0\n    }\n    // Opening tag: must be followed by whitespace, >, or end of line\n    var afterOpen = s.charCodeAt(nameEnd)\n    if (afterOpen === $.CHAR_SPACE || afterOpen === $.CHAR_TAB || afterOpen === $.CHAR_GT || afterOpen === $.CHAR_NEWLINE || nameEnd >= len) return 1\n    return 0\n  }\n\n  // Type 6: block-level tag\n  if (BLOCK_TAGS.has(tagName.toLowerCase())) {\n    if (isClosing) {\n      // Closing: </tag> with optional whitespace\n      var j6 = nameEnd\n      while (j6 < len && (s.charCodeAt(j6) === $.CHAR_SPACE || s.charCodeAt(j6) === $.CHAR_TAB)) j6++\n      if (j6 < len && s.charCodeAt(j6) === $.CHAR_GT) return 6\n      return 0\n    }\n    // Opening: must be followed by whitespace, >, />, or end of line\n    var ac = nameEnd < len ? s.charCodeAt(nameEnd) : -1\n    if (ac === $.CHAR_SPACE || ac === $.CHAR_TAB || ac === $.CHAR_GT || ac === $.CHAR_NEWLINE || ac === $.CHAR_SLASH || ac === -1) return 6\n    return 0\n  }\n\n  // Type 7: complete tag on its own line - tag must end on same line\n  // Cannot be a type 1 or type 6 tag (already checked above)\n  if (!isClosing) {\n    var le = lineEnd(s, p)\n    var tagRes = __parseHTMLTag(s, p)\n    if (tagRes && tagRes.end <= le) {\n      // Must be the only thing on the line (optionally followed by whitespace)\n      var afterTag = s.slice(tagRes.end, le).trim()\n      if (afterTag === '') return 7\n    }\n  } else {\n    // Closing tag for type 7\n    var j7 = nameEnd\n    while (j7 < len && (s.charCodeAt(j7) === $.CHAR_SPACE || s.charCodeAt(j7) === $.CHAR_TAB)) j7++\n    if (j7 < len && s.charCodeAt(j7) === $.CHAR_GT) {\n      // Must be the only thing on the line\n      var le7 = lineEnd(s, p)\n      var afterTag7 = s.slice(j7 + 1, le7).trim()\n      if (afterTag7 === '') return 7\n    }\n  }\n\n  return 0\n}\n\n/** Parse table row cells */\nfunction parseTableRow(s: string, state: MarkdownToJSX.State, opts: ParseOptions): MarkdownToJSX.ASTNode[][] {\n  // Find row bounds (trim leading/trailing pipe) using indices to avoid substring allocation\n  var rStart = 0, rEnd = s.length\n  while (rStart < rEnd && (s.charCodeAt(rStart) === $.CHAR_SPACE || s.charCodeAt(rStart) === $.CHAR_TAB)) rStart++\n  while (rEnd > rStart && (s.charCodeAt(rEnd - 1) === $.CHAR_SPACE || s.charCodeAt(rEnd - 1) === $.CHAR_TAB)) rEnd--\n  if (rStart < rEnd && s.charCodeAt(rStart) === $.CHAR_PIPE) rStart++\n  if (rEnd > rStart && s.charCodeAt(rEnd - 1) === $.CHAR_PIPE && (rEnd - 2 < rStart || s.charCodeAt(rEnd - 2) !== $.CHAR_BACKSLASH)) rEnd--\n\n  // Split by | (but not \\| and not | inside code spans)\n  // Fast path: track cell start index, only build string when escapes present\n  var cells: string[] = []\n  var cellStart = rStart\n  var hasEscape = false\n  var parts: string[] = [] // only used when hasEscape\n  var i = rStart\n\n  while (i < rEnd) {\n    var ch = s.charCodeAt(i)\n    // Handle escape — \\| is table-level pipe escape\n    if (ch === $.CHAR_BACKSLASH && i + 1 < rEnd) { // backslash\n      if (s.charCodeAt(i + 1) === $.CHAR_PIPE) { // \\|\n        if (!hasEscape) {\n          hasEscape = true\n          parts = []\n        }\n        parts.push(s.slice(cellStart, i))\n        parts.push('|')\n        i += 2\n        cellStart = i\n      } else {\n        i += 2 // skip escape pair\n      }\n      continue\n    }\n    // Handle code span — skip to closing backticks\n    if (ch === $.CHAR_BACKTICK) { // `\n      var backticks = 0\n      while (i < rEnd && s.charCodeAt(i) === $.CHAR_BACKTICK) { backticks++; i++ }\n      var found = false\n      while (i < rEnd && !found) {\n        var closeBackticks = 0\n        while (i < rEnd && s.charCodeAt(i) === $.CHAR_BACKTICK) { closeBackticks++; i++ }\n        if (closeBackticks === backticks) {\n          found = true\n        } else if (closeBackticks === 0) {\n          i++\n        }\n      }\n      continue\n    }\n    // Handle cell separator\n    if (ch === $.CHAR_PIPE) { // |\n      var cellText = hasEscape\n        ? (parts.push(s.slice(cellStart, i)), parts.join(''))\n        : s.slice(cellStart, i)\n      cells.push(cellText.trim())\n      i++\n      cellStart = i\n      hasEscape = false\n      parts = []\n      continue\n    }\n    i++\n  }\n  // Push final cell\n  var lastCell = hasEscape\n    ? (parts.push(s.slice(cellStart, rEnd)), parts.join(''))\n    : s.slice(cellStart, rEnd)\n  cells.push(lastCell.trim())\n\n  return cells.map(function(cell) {\n    // Replace remaining \\| with | (pipe escapes inside code spans are kept during splitting)\n    var processed = cell.indexOf('\\\\|') !== -1 ? cell.replace(/\\\\\\|/g, '|') : cell\n    return parseInline(processed, 0, processed.length, state, opts)\n  })\n}\n\n/** Scan GFM table */\nfunction scanTable(s: string, p: number, state: MarkdownToJSX.State, opts: ParseOptions): ScanResult {\n  const firstEnd = lineEnd(s, p)\n\n  // Must have at least one | — check without slicing\n  var pipeIdx = s.indexOf('|', p)\n  if (pipeIdx < 0 || pipeIdx >= firstEnd) return null\n\n  // Check for delimiter row\n  const secondStart = nextLine(s, firstEnd)\n  if (secondStart >= s.length) return null\n\n  const secondEnd = lineEnd(s, secondStart)\n  // Delimiter row must match pattern: |? :?-+:? (| :?-+:?)* |?\n  if (!isDelimiterRow(s, secondStart, secondEnd)) return null\n\n  // Only slice firstLine after delimiter check passes (most | chars aren't tables)\n  const firstLine = s.slice(p, firstEnd)\n  const delimLine = s.slice(secondStart, secondEnd)\n\n  // Parse alignment from delimiter row — single pass, no split/map/trim\n  var align: (null | 'left' | 'right' | 'center')[] = []\n  var di = 0, dLen = delimLine.length\n  // skip leading whitespace + optional pipe\n  while (di < dLen && (delimLine.charCodeAt(di) === $.CHAR_SPACE || delimLine.charCodeAt(di) === $.CHAR_TAB)) di++\n  if (di < dLen && delimLine.charCodeAt(di) === $.CHAR_PIPE) di++\n  while (di < dLen) {\n    // skip whitespace before cell\n    while (di < dLen && (delimLine.charCodeAt(di) === $.CHAR_SPACE || delimLine.charCodeAt(di) === $.CHAR_TAB)) di++\n    if (di >= dLen) break\n    // trailing pipe — done\n    if (delimLine.charCodeAt(di) === $.CHAR_PIPE) break\n    // check leading colon\n    var hasLeft = delimLine.charCodeAt(di) === $.CHAR_COLON\n    if (hasLeft) di++\n    // skip dashes\n    while (di < dLen && delimLine.charCodeAt(di) === $.CHAR_DASH) di++\n    // check trailing colon\n    var hasRight = di < dLen && delimLine.charCodeAt(di) === $.CHAR_COLON\n    if (hasRight) di++\n    align.push(hasLeft && hasRight ? 'center' : hasRight ? 'right' : hasLeft ? 'left' : null)\n    // skip whitespace + pipe\n    while (di < dLen && (delimLine.charCodeAt(di) === $.CHAR_SPACE || delimLine.charCodeAt(di) === $.CHAR_TAB)) di++\n    if (di < dLen && delimLine.charCodeAt(di) === $.CHAR_PIPE) di++\n  }\n\n  // Parse header\n  const header = parseTableRow(firstLine, state, opts)\n\n  // Delimiter column count must match header\n  if (align.length !== header.length) return null\n\n  // Parse body cells\n  const cells: MarkdownToJSX.ASTNode[][][] = []\n  let end = nextLine(s, secondEnd)\n\n  while (end < s.length) {\n    const le = lineEnd(s, end)\n    const line = s.slice(end, le)\n\n    if (isBlank(s, end, le)) break\n    // Check if line starts a block element that should end the table\n    indent(s, end, le)\n    if (_indentSpaces < 4) {\n      var tc = s.charCodeAt(end + _indentChars)\n      // Blockquote, heading, thematic break, fenced code, HTML block all end the table\n      if (tc === $.CHAR_GT || tc === $.CHAR_HASH) break // > or #\n      if ((tc === $.CHAR_DASH || tc === $.CHAR_ASTERISK || tc === $.CHAR_UNDERSCORE) && scanThematic(s, end)) break\n      if ((tc === $.CHAR_BACKTICK || tc === $.CHAR_TILDE)) {\n        var tfp = end + _indentChars, tfc = 0\n        while (tfp < le && s.charCodeAt(tfp) === tc) { tfc++; tfp++ }\n        if (tfc >= 3) break\n      }\n    }\n    // Per GFM, body rows don't require | — they can be pipeless (single-cell)\n\n    cells.push(parseTableRow(line, state, opts))\n    end = nextLine(s, le)\n  }\n\n  // For streaming mode: suppress tables with header + separator but no data rows\n  // (data rows might be coming in a later stream chunk)\n  if ((opts.streaming || opts.optimizeForStreaming) && cells.length === 0) {\n    return null\n  }\n\n  // Normalize: pad/trim rows to match header column count\n  var colCount = header.length\n  for (var ri = 0; ri < cells.length; ri++) {\n    if (cells[ri].length < colCount) {\n      while (cells[ri].length < colCount) cells[ri].push([])\n    } else if (cells[ri].length > colCount) {\n      cells[ri].length = colCount\n    }\n  }\n\n  return {\n    node: {\n      type: RuleType.table,\n      header,\n      cells,\n      align,\n    } as MarkdownToJSX.TableNode,\n    end\n  }\n}\n\n/** Scan link reference definition [label]: url \"title\" */\nfunction scanRefDefinition(s: string, p: number, state: MarkdownToJSX.State): ScanResult {\n  var e = lineEnd(s, p)\n  indent(s, p, e)\n  if (_indentSpaces > 3) return null\n\n  var i = p + _indentChars\n  if (s.charCodeAt(i) !== $.CHAR_BRACKET_OPEN) return null // [\n\n  // Check for footnote [^\n  if (i + 1 < s.length && s.charCodeAt(i + 1) === $.CHAR_CARET) {\n    // Footnote definition - handle separately\n    var fnResult = parseFootnoteDefinition(s, i, state)\n    if (fnResult) return fnResult\n    return null\n  }\n\n  // Use parseRefDef which handles multi-line titles correctly\n  if (!state.refs) state.refs = {}\n  var result = parseRefDef(s, i, state.refs)\n  if (result === null) return null\n\n  return { node: { type: RuleType.refCollection } as MarkdownToJSX.ASTNode, end: result }\n}\n\nfunction parseFootnoteDefinition(s: string, p: number, state: MarkdownToJSX.State): ScanResult {\n  // Parse [^label]:\n  var len = s.length\n  if (s.charCodeAt(p) !== $.CHAR_BRACKET_OPEN || p + 1 >= len || s.charCodeAt(p + 1) !== $.CHAR_CARET) return null\n\n  var i = p + 2\n  var labelStart = i\n  while (i < len && s.charCodeAt(i) !== $.CHAR_BRACKET_CLOSE) {\n    if (s.charCodeAt(i) === $.CHAR_NEWLINE) return null\n    i++\n  }\n  if (i >= len) return null\n  var label = ('^' + s.slice(labelStart, i)).toLowerCase()\n  i++ // skip ]\n\n  if (i >= len || s.charCodeAt(i) !== $.CHAR_COLON) return null\n  i++ // skip :\n\n  // Skip whitespace\n  while (i < len && (s.charCodeAt(i) === $.CHAR_SPACE || s.charCodeAt(i) === $.CHAR_TAB)) i++\n  if (i < len && s.charCodeAt(i) === $.CHAR_NEWLINE) {\n    i++\n    while (i < len && (s.charCodeAt(i) === $.CHAR_SPACE || s.charCodeAt(i) === $.CHAR_TAB)) i++\n  }\n\n  // Collect content\n  var fnEnd = s.indexOf('\\n', i)\n  if (fnEnd < 0) fnEnd = len\n  var content = s.slice(i, fnEnd).trim()\n  var end = fnEnd < len ? fnEnd + 1 : len\n\n  // Multiline continuation (2+ space indent)\n  while (end < len) {\n    var nextLe = lineEnd(s, end)\n    indent(s, end, nextLe)\n    if (_indentSpaces >= 2 && !isBlank(s, end, nextLe)) {\n      content += '\\n' + s.slice(end, nextLe)\n      end = nextLine(s, nextLe)\n    } else if (isBlank(s, end, nextLe)) {\n      var afterBlank = nextLine(s, nextLe)\n      if (afterBlank < len) {\n        var afterBlankEnd = lineEnd(s, afterBlank)\n        indent(s, afterBlank, afterBlankEnd)\n        if (_indentSpaces >= 2) {\n          content += '\\n'\n          end = nextLine(s, nextLe)\n          continue\n        }\n      }\n      break\n    } else {\n      break\n    }\n  }\n\n  if (!state.refs[label]) state.refs[label] = { target: content, title: undefined }\n  return { node: { type: RuleType.footnote } as MarkdownToJSX.ASTNode, end }\n}\n\n/** Scan paragraph (fallback) */\nfunction scanParagraph(s: string, p: number, state: MarkdownToJSX.State, opts: ParseOptions): ScanResult {\n  let end = p\n  let setextLevel = 0\n  let textEnd = 0\n  let cachedLe = -1 // Cache lineEnd from previous iteration's next-line check\n\n  while (end < s.length) {\n    const le = cachedLe >= 0 ? cachedLe : lineEnd(s, end)\n    cachedLe = -1\n\n    // Check for blank line\n    if (isBlank(s, end, le)) break\n\n    // Check if this line is a setext underline\n    indent(s, end, le)\n    if (_indentSpaces < 4 && textEnd > 0 && !state._noSetext) {\n      const c = s.charCodeAt(end + _indentChars)\n      if (c === $.CHAR_EQ || c === $.CHAR_DASH) { // = or -\n        // Check if entire line is = or - (with optional spaces)\n        let i = end + _indentChars\n        while (i < le && s.charCodeAt(i) === c) i++\n        while (i < le && (s.charCodeAt(i) === $.CHAR_SPACE || s.charCodeAt(i) === $.CHAR_TAB)) i++\n        if (i >= le) {\n          setextLevel = c === $.CHAR_EQ ? 1 : 2\n          end = nextLine(s, le)\n          break\n        }\n      }\n    }\n\n    textEnd = le\n\n    // Check if next line starts a new block\n    const nextStart = nextLine(s, le)\n    if (nextStart < s.length) {\n      // \\u001E prefix marks lazy continuation — never break paragraph here\n      if (s.charCodeAt(nextStart) === $.CHAR_RECORD_SEP) {\n        var lazyLe = lineEnd(s, nextStart)\n        end = nextLine(s, lazyLe)\n        textEnd = lazyLe\n        continue\n      }\n      const nextLe = lineEnd(s, nextStart)\n      cachedLe = nextLe // Cache for next iteration (nextStart becomes end)\n      indent(s, nextStart, nextLe)\n      if (_indentSpaces < 4) {\n        const c = s.charCodeAt(nextStart + _indentChars)\n        // Check for block starters that interrupt paragraphs\n        if (c === $.CHAR_GT) { // > blockquote\n          end = nextStart\n          break\n        }\n        if (c === $.CHAR_HASH) { // # heading - must be valid ATX heading\n          if (scanHeading(s, nextStart, state, opts)) {\n            end = nextStart\n            break\n          }\n        }\n        if (c === $.CHAR_BACKTICK || c === $.CHAR_TILDE) { // ` or ~ fenced code - need 3+\n          var fenceCheck = nextStart + _indentChars\n          var fenceCheckCount = 0\n          while (fenceCheck < nextLe && s.charCodeAt(fenceCheck) === c) { fenceCheckCount++; fenceCheck++ }\n          if (fenceCheckCount >= 3) {\n            end = nextStart\n            break\n          }\n        }\n        // HTML blocks can interrupt paragraphs, but only types 1-6\n        // Type 7 (generic tags) cannot interrupt paragraphs\n        // Pre-check tag name before calling expensive scanHTMLBlock\n        if (c === $.CHAR_LT) {\n          var afterLT = nextStart + _indentChars + 1\n          var hc = afterLT < nextLe ? s.charCodeAt(afterLT) : 0\n          var canInterrupt =\n            hc === $.CHAR_EXCLAMATION || // ! (comment <!--, <!DOCTYPE, <![CDATA[)\n            hc === $.CHAR_QUESTION    // ? (processing instruction <?)\n          if (!canInterrupt && hc === $.CHAR_SLASH) {\n            // Closing tag — extract tag name and check if block-level\n            var closeTagStart = afterLT + 1\n            var closeTagEnd = closeTagStart\n            while (closeTagEnd < nextLe && ((s.charCodeAt(closeTagEnd) >= $.CHAR_A && s.charCodeAt(closeTagEnd) <= $.CHAR_Z) || (s.charCodeAt(closeTagEnd) >= $.CHAR_a && s.charCodeAt(closeTagEnd) <= $.CHAR_z) || (s.charCodeAt(closeTagEnd) >= $.CHAR_DIGIT_0 && s.charCodeAt(closeTagEnd) <= $.CHAR_DIGIT_9) || s.charCodeAt(closeTagEnd) === $.CHAR_DASH)) closeTagEnd++\n            if (closeTagEnd > closeTagStart) canInterrupt = BLOCK_TAGS.has(s.slice(closeTagStart, closeTagEnd).toLowerCase())\n          } else if (!canInterrupt) {\n            // Opening tag — extract tag name and check if block-level (type 1 or 6)\n            var tagEndHC = afterLT\n            while (tagEndHC < nextLe && ((s.charCodeAt(tagEndHC) >= $.CHAR_A && s.charCodeAt(tagEndHC) <= $.CHAR_Z) || (s.charCodeAt(tagEndHC) >= $.CHAR_a && s.charCodeAt(tagEndHC) <= $.CHAR_z) || (s.charCodeAt(tagEndHC) >= $.CHAR_DIGIT_0 && s.charCodeAt(tagEndHC) <= $.CHAR_DIGIT_9) || s.charCodeAt(tagEndHC) === $.CHAR_DASH)) tagEndHC++\n            if (tagEndHC > afterLT) {\n              var tagNameLC = s.slice(afterLT, tagEndHC).toLowerCase()\n              canInterrupt = BLOCK_TAGS.has(tagNameLC) || TYPE1_TAGS.has(tagNameLC)\n            }\n          }\n          // Only call expensive scanHTMLBlock if pre-check passes\n          if (canInterrupt && scanHTMLBlock(s, nextStart, state, opts)) {\n            end = nextStart\n            break\n          }\n        }\n        // List items can interrupt paragraphs (- * + or digit followed by . or ))\n        // But empty list items CANNOT interrupt paragraphs per CommonMark\n        if (c === $.CHAR_DASH || c === $.CHAR_ASTERISK || c === $.CHAR_PLUS) {\n          // - * + followed by space/tab (must have content — not empty)\n          const next = nextStart + _indentChars + 1\n          if (next < nextLe && (s.charCodeAt(next) === $.CHAR_SPACE || s.charCodeAt(next) === $.CHAR_TAB)) {\n            // Has content after space — check it's not all whitespace (empty item)\n            var contentAfterMarker = skipWS(s, next, nextLe)\n            if (contentAfterMarker < nextLe) {\n              // Only interrupt if not a thematic break\n              if (!scanThematic(s, nextStart)) {\n                end = nextStart\n                break\n              }\n            }\n          }\n        }\n        if (c >= $.CHAR_DIGIT_0 && c <= $.CHAR_DIGIT_9) {\n          // Digit - check for ordered list\n          // Per CommonMark, only \"1.\" or \"1)\" can interrupt a paragraph\n          // And empty items cannot interrupt paragraphs\n          let i = nextStart + _indentChars\n          while (i < nextLe && s.charCodeAt(i) >= $.CHAR_DIGIT_0 && s.charCodeAt(i) <= $.CHAR_DIGIT_9) i++\n          if (i < nextLe && (s.charCodeAt(i) === $.CHAR_PERIOD || s.charCodeAt(i) === $.CHAR_PAREN_CLOSE)) {\n            if (i - (nextStart + _indentChars) === 1 && s.charCodeAt(nextStart + _indentChars) === 49) {\n              var afterMarker = i + 1\n              if (afterMarker < nextLe && (s.charCodeAt(afterMarker) === $.CHAR_SPACE || s.charCodeAt(afterMarker) === $.CHAR_TAB)) {\n                var contentAfterOrd = skipWS(s, afterMarker, nextLe)\n                if (contentAfterOrd < nextLe) {\n                  end = nextStart\n                  break\n                }\n              }\n            }\n          }\n        }\n        // Tables can interrupt paragraphs if the line starts with |\n        if (c === $.CHAR_PIPE) { // |\n          // Check if this could be a table (need to verify there's a delimiter row)\n          const thirdStart = nextLine(s, nextLe)\n          if (thirdStart < s.length) {\n            const thirdEnd = lineEnd(s, thirdStart)\n            if (isDelimiterRow(s, thirdStart, thirdEnd)) {\n              end = nextStart\n              break\n            }\n          }\n        }\n        // Thematic break (but not setext underline)\n        if ((c === $.CHAR_DASH || c === $.CHAR_ASTERISK || c === $.CHAR_UNDERSCORE) && scanThematic(s, nextStart)) {\n          // For dashes, only break if it's really a thematic break not setext\n          if (c !== $.CHAR_DASH) {\n            end = nextStart\n            break\n          }\n          // Check if it could be setext (need at least 1 dash)\n          let dashCount = 0\n          let i = nextStart + _indentChars\n          while (i < nextLe && s.charCodeAt(i) === $.CHAR_DASH) { dashCount++; i++ }\n          while (i < nextLe && (s.charCodeAt(i) === $.CHAR_SPACE || s.charCodeAt(i) === $.CHAR_TAB)) i++\n          // If whole line is dashes, it could be setext - let loop continue to check\n          if (i < nextLe) {\n            end = nextStart\n            break // Not setext, it's thematic break\n          }\n        }\n      }\n    }\n\n    end = nextLine(s, le)\n  }\n\n  // If setext, use textEnd as the content end\n  var contentEnd = setextLevel ? textEnd : end\n  // Trim trailing newlines and whitespace via index adjustment (avoid slice+replace+trim chain)\n  while (contentEnd > p && (s.charCodeAt(contentEnd - 1) === $.CHAR_NEWLINE || s.charCodeAt(contentEnd - 1) === $.CHAR_CR || s.charCodeAt(contentEnd - 1) === $.CHAR_SPACE || s.charCodeAt(contentEnd - 1) === $.CHAR_TAB)) contentEnd--\n  var textStart = p\n  while (textStart < contentEnd && (s.charCodeAt(textStart) === $.CHAR_SPACE || s.charCodeAt(textStart) === $.CHAR_TAB)) textStart++\n  if (textStart >= contentEnd) return null\n  // Check for \\u001E markers only within [textStart, contentEnd) — bounded scan\n  // avoids O(n) indexOf over the entire remaining document per paragraph\n  var hasMarker = false\n  for (var mi = textStart; mi < contentEnd; mi++) {\n    if (s.charCodeAt(mi) === $.CHAR_RECORD_SEP) { hasMarker = true; break }\n  }\n  var text = hasMarker\n    ? s.slice(textStart, contentEnd).replace(/\\u001E/g, '')\n    : s.slice(textStart, contentEnd)\n  if (!text) return null\n\n  // Inline parser handles hard line breaks directly (two+ spaces or \\ before newline)\n  const children = parseInlineWithBreaks(text, 0, text.length, state, opts)\n\n  if (setextLevel) {\n    // Setext heading\n    const slugify = opts?.slugify || util.slugify\n    const id = slugify(text)\n    return {\n      node: {\n        type: RuleType.heading,\n        level: setextLevel,\n        children,\n        id,\n      } as MarkdownToJSX.HeadingNode,\n      end\n    }\n  }\n\n  return {\n    node: {\n      type: RuleType.paragraph,\n      children,\n    } as MarkdownToJSX.ParagraphNode,\n    end\n  }\n}\n\n/** Parse inline with hard line break support */\nfunction parseInlineWithBreaks(s: string, p: number, e: number, state: MarkdownToJSX.State, opts: ParseOptions): MarkdownToJSX.ASTNode[] {\n  // Fast path: if no newlines in range, skip break processing entirely\n  // Use indexOf bounded to [p, e) — faster than a charCode loop for this check\n  var firstNL = s.indexOf('\\n', p)\n  if (firstNL < 0 || firstNL >= e) {\n    return parseInline(s, p, e, state, opts)\n  }\n\n  // Rope concat (faster in JSC than array-push + join for small/medium segments)\n  var out = ''\n  var segStart = p\n  var i = p\n\n  while (i < e) {\n    var ch = s.charCodeAt(i)\n\n    // Skip code spans\n    if (ch === $.CHAR_BACKTICK) {\n      var csEnd = skipCodeSpan(s, i, e)\n      if (csEnd > i) {\n        // Check if code span contains newlines that need replacing\n        var hasCSNewline = false\n        for (var ci = i; ci < csEnd; ci++) {\n          if (s.charCodeAt(ci) === $.CHAR_NEWLINE) { hasCSNewline = true; break }\n        }\n        if (hasCSNewline) {\n          out += s.slice(segStart, i)\n          out += s.slice(i, csEnd).replace(/\\n/g, ' ')\n          segStart = csEnd\n        }\n        i = csEnd\n        continue\n      }\n    }\n\n    // Skip HTML tags\n    if (ch === $.CHAR_LT) {\n      var htmlEnd = skipInlineHTMLElement(s, i, e)\n      if (htmlEnd > i) {\n        i = htmlEnd\n        continue\n      }\n    }\n\n    // Check for newline\n    if (ch === $.CHAR_NEWLINE) {\n      var isHard = false\n      var trimBack = 0\n\n      if (i > p && s.charCodeAt(i - 1) === $.CHAR_BACKSLASH) {\n        isHard = true\n        trimBack = 1\n      } else {\n        var spCount = 0\n        var j = i - 1\n        while (j >= p && s.charCodeAt(j) === $.CHAR_SPACE) { spCount++; j-- }\n        if (spCount >= 2) {\n          isHard = true\n          trimBack = spCount\n        }\n      }\n\n      if (isHard) {\n        out += s.slice(segStart, i - trimBack)\n        out += '\\u001F'\n      } else {\n        out += s.slice(segStart, i + 1)\n      }\n      // Skip leading whitespace on next line\n      i++\n      while (i < e && s.charCodeAt(i) === $.CHAR_SPACE) i++\n      segStart = i\n      continue\n    }\n\n    i++\n  }\n\n  // Flush remaining segment\n  if (segStart < e) {\n    out += s.slice(segStart, e)\n  }\n\n  return parseInline(out, 0, out.length, state, opts)\n}\n\n// ============================================================================\n// INLINE SCANNERS\n// ============================================================================\n\n/** Scan inline code span */\nfunction scanCodeSpan(s: string, p: number, e: number): ScanResult {\n  if (s.charCodeAt(p) !== $.CHAR_BACKTICK) return null\n\n  // Count opening backticks\n  const openLen = countChar(s, p, e, 96)\n  let i = p + openLen\n\n  // Find matching closing backticks (bounded to [i, e))\n  while (i < e) {\n    const j = s.indexOf('`', i)\n    if (j < 0 || j >= e) return null\n\n    const closeLen = countChar(s, j, e, 96)\n    if (closeLen === openLen) {\n      // Found matching close\n      let content = s.slice(p + openLen, j)\n      // Normalize whitespace\n      content = content.replace(/\\n/g, ' ')\n      // Strip one space from each end if both ends have space and there's non-space content\n      if (content.length > 0 && content[0] === ' ' && content[content.length - 1] === ' ' &&\n          content.trim().length > 0) {\n        content = content.slice(1, -1)\n      }\n\n      return {\n        node: {\n          type: RuleType.codeInline,\n          text: content,\n        } as MarkdownToJSX.CodeInlineNode,\n        end: j + closeLen\n      }\n    }\n    i = j + closeLen\n  }\n\n  return null\n}\n\n/** Skip over a code span starting at position i, return position after code span or i if not a code span */\nfunction skipCodeSpan(s: string, i: number, e: number): number {\n  if (s.charCodeAt(i) !== $.CHAR_BACKTICK) return i\n  const openLen = countChar(s, i, e, 96)\n  let j = i + openLen\n  while (j < e) {\n    const k = s.indexOf('`', j)\n    if (k < 0 || k >= e) return i // no close found within range\n    const closeLen = countChar(s, k, e, 96)\n    if (closeLen === openLen) return k + closeLen // return position after code span\n    j = k + closeLen\n  }\n  return i // no valid close\n}\n\n/** Skip over an inline HTML element (including content and closing tag) starting at position i */\nfunction skipInlineHTMLElement(s: string, i: number, e: number): number {\n  if (s.charCodeAt(i) !== $.CHAR_LT) return i // <\n\n  // Check for closing tag or comment\n  if (i + 1 < e && s.charCodeAt(i + 1) === $.CHAR_SLASH) { // </\n    // Closing tag - just skip to >\n    let j = i + 2\n    while (j < e && s.charCodeAt(j) !== $.CHAR_GT) j++\n    return j < e ? j + 1 : i\n  }\n\n  if (i + 3 < e && s.charCodeAt(i + 1) === $.CHAR_EXCLAMATION && s.charCodeAt(i + 2) === $.CHAR_DASH && s.charCodeAt(i + 3) === $.CHAR_DASH) {\n    // HTML comment <!-- -->\n    const closeIdx = s.indexOf('-->', i + 4)\n    return closeIdx >= 0 ? closeIdx + 3 : i\n  }\n\n  // Get tag name\n  let j = i + 1\n  const tagStart = j\n  while (j < e) {\n    const c = s.charCodeAt(j)\n    if ((c >= $.CHAR_A && c <= $.CHAR_Z) || (c >= $.CHAR_a && c <= $.CHAR_z) || (c >= $.CHAR_DIGIT_0 && c <= $.CHAR_DIGIT_9) || c === $.CHAR_DASH) {\n      j++\n    } else {\n      break\n    }\n  }\n  if (j === tagStart) return i // not a valid tag\n  const tag = s.slice(tagStart, j).toLowerCase()\n\n  // Skip to end of opening tag (newlines allowed inside quoted attributes per CommonMark)\n  let selfClosing = false\n  while (j < e) {\n    const c = s.charCodeAt(j)\n    if (c === $.CHAR_GT) { // >\n      j++\n      break\n    }\n    if (c === $.CHAR_SLASH && j + 1 < e && s.charCodeAt(j + 1) === $.CHAR_GT) { // />\n      j += 2\n      selfClosing = true\n      break\n    }\n    // Allow newlines inside quoted attribute values\n    if (c === $.CHAR_DOUBLE_QUOTE || c === $.CHAR_SINGLE_QUOTE) { // \" or '\n      var q = c\n      j++\n      while (j < e && s.charCodeAt(j) !== q) j++\n      if (j < e) j++ // skip closing quote\n      continue\n    }\n    if (c === $.CHAR_NEWLINE) return i // newline outside quoted attribute\n    j++\n  }\n\n  if (selfClosing) return j\n\n  // Void elements don't have closing tags\n  if (util.isVoidElement(tag)) return j\n\n  // Find matching closing tag\n  let depth = 1\n  while (j < e && depth > 0) {\n    if (s.charCodeAt(j) === $.CHAR_LT) { // <\n      if (j + 1 < e && s.charCodeAt(j + 1) === $.CHAR_SLASH) { // </\n        // Check if it's closing our tag\n        const closeTagStart = j + 2\n        let k = closeTagStart\n        while (k < e && ((s.charCodeAt(k) >= $.CHAR_A && s.charCodeAt(k) <= $.CHAR_Z) || (s.charCodeAt(k) >= $.CHAR_a && s.charCodeAt(k) <= $.CHAR_z))) k++\n        const closeTag = s.slice(closeTagStart, k).toLowerCase()\n        if (closeTag === tag) {\n          // Skip to end of closing tag\n          while (k < e && s.charCodeAt(k) !== $.CHAR_GT) k++\n          if (k < e) k++ // skip >\n          depth--\n          if (depth === 0) return k\n        }\n        j = k\n      } else {\n        // Opening tag - check if same tag\n        const nextTagStart = j + 1\n        let k = nextTagStart\n        while (k < e && ((s.charCodeAt(k) >= $.CHAR_A && s.charCodeAt(k) <= $.CHAR_Z) || (s.charCodeAt(k) >= $.CHAR_a && s.charCodeAt(k) <= $.CHAR_z))) k++\n        const nextTag = s.slice(nextTagStart, k).toLowerCase()\n        if (nextTag === tag) depth++\n        j++\n      }\n    } else {\n      j++\n    }\n  }\n\n  return j\n}\n\n/** Skip over a link [text](url) or [text][ref] starting at position i */\nfunction skipLinkOrImage(s: string, i: number, e: number): number {\n  // Check for ![\n  const isImage = s.charCodeAt(i) === $.CHAR_EXCLAMATION\n  const start = isImage ? i + 1 : i\n\n  if (s.charCodeAt(start) !== $.CHAR_BRACKET_OPEN) return i // [\n\n  // Find closing ]\n  let depth = 1\n  let j = start + 1\n  while (j < e && depth > 0) {\n    const c = s.charCodeAt(j)\n    if (c === $.CHAR_BACKSLASH && j + 1 < e) { j += 2; continue } // escape\n    if (c === $.CHAR_BRACKET_OPEN) depth++\n    else if (c === $.CHAR_BRACKET_CLOSE) depth--\n    j++\n  }\n  if (depth !== 0) return i\n\n  // j is now past the ]\n  if (j >= e) return j // just [text]\n\n  const nextChar = s.charCodeAt(j)\n\n  // Inline link: [text](url)\n  if (nextChar === $.CHAR_PAREN_OPEN) { // (\n    let parenDepth = 1\n    j++\n    while (j < e && parenDepth > 0) {\n      const c = s.charCodeAt(j)\n      if (c === $.CHAR_BACKSLASH && j + 1 < e) { j += 2; continue }\n      if (c === $.CHAR_PAREN_OPEN) parenDepth++\n      else if (c === $.CHAR_PAREN_CLOSE) parenDepth--\n      j++\n    }\n    return j\n  }\n\n  // Reference link: [text][ref]\n  if (nextChar === $.CHAR_BRACKET_OPEN) { // [\n    let depth2 = 1\n    j++\n    while (j < e && depth2 > 0) {\n      const c = s.charCodeAt(j)\n      if (c === $.CHAR_BRACKET_OPEN) depth2++\n      else if (c === $.CHAR_BRACKET_CLOSE) depth2--\n      j++\n    }\n    return j\n  }\n\n  return j // shortcut link [text]\n}\n\n/** Scan strikethrough ~~text~~ */\nfunction scanStrikethrough(s: string, p: number, e: number, state: MarkdownToJSX.State, opts: ParseOptions): ScanResult {\n  if (s.charCodeAt(p) !== $.CHAR_TILDE || p + 1 >= e || s.charCodeAt(p + 1) !== $.CHAR_TILDE) return null // ~~\n\n  // Find closing ~~, skipping over code spans\n  let i = p + 2\n  while (i + 1 < e) {\n    const c = s.charCodeAt(i)\n    // Skip code spans - they take precedence\n    if (c === $.CHAR_BACKTICK) {\n      const afterCode = skipCodeSpan(s, i, e)\n      if (afterCode > i) { i = afterCode; continue }\n    }\n    if (c === $.CHAR_TILDE && s.charCodeAt(i + 1) === $.CHAR_TILDE) {\n      const content = s.slice(p + 2, i)\n      const children = parseInline(content, 0, content.length, state, opts)\n      return {\n        node: {\n          type: RuleType.textFormatted,\n          tag: 'del',\n          children,\n        } as MarkdownToJSX.TextFormattedNode,\n        end: i + 2\n      }\n    }\n    if (c === $.CHAR_BACKSLASH && i + 1 < e) i++ // escape\n    i++\n  }\n\n  return null\n}\n\n/** Scan marked text ==text== */\nfunction scanMarked(s: string, p: number, e: number, state: MarkdownToJSX.State, opts: ParseOptions): ScanResult {\n  if (s.charCodeAt(p) !== $.CHAR_EQ || p + 1 >= e || s.charCodeAt(p + 1) !== $.CHAR_EQ) return null // ==\n\n  // Find closing ==, skipping over code spans\n  let i = p + 2\n  while (i + 1 < e) {\n    const c = s.charCodeAt(i)\n    // Skip code spans - they take precedence\n    if (c === $.CHAR_BACKTICK) {\n      const afterCode = skipCodeSpan(s, i, e)\n      if (afterCode > i) { i = afterCode; continue }\n    }\n    if (c === $.CHAR_EQ && s.charCodeAt(i + 1) === $.CHAR_EQ) {\n      // Require non-empty content between == delimiters\n      if (i > p + 2) {\n        const content = s.slice(p + 2, i)\n        const children = parseInline(content, 0, content.length, state, opts)\n        return {\n          node: {\n            type: RuleType.textFormatted,\n            tag: 'mark',\n            children,\n          } as MarkdownToJSX.TextFormattedNode,\n          end: i + 2\n        }\n      }\n    }\n    if (c === $.CHAR_BACKSLASH && i + 1 < e) i++ // escape\n    i++\n  }\n\n  return null\n}\n\n// Unicode punctuation regex for non-ASCII chars (matches \\p{P} and \\p{S} per CommonMark/GFM)\nvar UNICODE_PUNCT_R = /[\\p{P}\\p{S}]/u\n\n/** Check if a character (code or string) is Unicode/ASCII punctuation */\nfunction isUPunct(code: number, s: string, pos: number): boolean {\n  if (code < $.CHAR_ASCII_BOUNDARY) return !!(cc(code) & C_PUNCT)\n  return UNICODE_PUNCT_R.test(s[pos])\n}\n\n/** Check if a character code is Unicode whitespace */\nfunction isUWS(code: number, s: string, pos: number): boolean {\n  if (code < $.CHAR_ASCII_BOUNDARY) return !!(cc(code) & C_WS)\n  // Unicode Zs category\n  return /\\p{Zs}/u.test(s[pos])\n}\n\n/** Delimiter entry for emphasis processing */\ninterface DelimEntry {\n  idx: number     // index in nodes array\n  ch: number      // char code (* or _ or ~ or =)\n  len: number     // original delimiter run length\n  canOpen: boolean\n  canClose: boolean\n  active: boolean\n}\n\n/** Collect delimiter run info without consuming - returns null if not a valid delimiter */\nfunction collectDelimiter(s: string, p: number, e: number): { len: number; canOpen: boolean; canClose: boolean } | null {\n  var ch = s.charCodeAt(p)\n  if (ch !== $.CHAR_ASTERISK && ch !== $.CHAR_UNDERSCORE) return null\n\n  var len = countChar(s, p, e, ch)\n  if (len === 0) return null\n\n  var beforeCode = p > 0 ? s.charCodeAt(p - 1) : 32\n  var afterCode = p + len < e ? s.charCodeAt(p + len) : 32\n\n  var beforeWS = isUWS(beforeCode, s, p - 1)\n  var afterWS = isUWS(afterCode, s, p + len)\n  var beforePunct = p > 0 ? isUPunct(beforeCode, s, p - 1) : false\n  var afterPunct = p + len < e ? isUPunct(afterCode, s, p + len) : false\n\n  // CommonMark flanking rules\n  var leftFlanking = !afterWS && (!afterPunct || beforeWS || beforePunct)\n  var rightFlanking = !beforeWS && (!beforePunct || afterWS || afterPunct)\n\n  var canOpen: boolean, canClose: boolean\n  if (ch === $.CHAR_ASTERISK) {\n    canOpen = leftFlanking\n    canClose = rightFlanking\n  } else {\n    // Underscore: stricter rules\n    canOpen = leftFlanking && (!rightFlanking || beforePunct)\n    canClose = rightFlanking && (!leftFlanking || afterPunct)\n  }\n\n  return { len: len, canOpen: canOpen, canClose: canClose }\n}\n\n/** Process emphasis delimiters using CommonMark algorithm */\nfunction processEmphasis(\n  nodes: MarkdownToJSX.ASTNode[],\n  delims: DelimEntry[],\n  state: MarkdownToJSX.State,\n  opts: ParseOptions\n): void {\n  if (delims.length === 0) return\n\n  // openers_bottom indexed by: type(0=*,1=_) * 6 + (closerLen%3) * 2 + (canOpen?1:0)\n  var openersBottom: number[] = []\n  for (var oi = 0; oi < 12; oi++) openersBottom[oi] = -1\n\n  // Process from left to right looking for closers\n  var ci = 0\n  while (ci < delims.length) {\n    var closer = delims[ci]\n    if (!closer.active || !closer.canClose) { ci++; continue }\n\n    var typeCode = closer.ch === $.CHAR_ASTERISK ? 0 : 1\n    var obKey = typeCode * 6 + (closer.len % 3) * 2 + (closer.canOpen ? 1 : 0)\n    var bottomIdx = openersBottom[obKey] !== undefined ? openersBottom[obKey] : -1\n\n    // Search backwards for matching opener\n    var openerIdx = -1\n    for (var oi2 = ci - 1; oi2 > bottomIdx; oi2--) {\n      var candidate = delims[oi2]\n      if (!candidate.active || candidate.ch !== closer.ch || !candidate.canOpen) continue\n\n      // \"Sum of lengths\" rule: if either can both open and close,\n      // sum of lengths must not be multiple of 3 unless both are multiples of 3\n      if ((closer.canOpen || candidate.canClose) &&\n          (candidate.len + closer.len) % 3 === 0 &&\n          candidate.len % 3 !== 0) continue\n\n      openerIdx = oi2\n      break\n    }\n\n    if (openerIdx < 0) {\n      // No opener found - update openers_bottom\n      openersBottom[obKey] = ci - 1\n      if (!closer.canOpen) {\n        closer.active = false\n      }\n      ci++\n      continue\n    }\n\n    var opener = delims[openerIdx]\n    var isStrong = opener.len >= 2 && closer.len >= 2\n    var useLen = isStrong ? 2 : 1\n\n    // Update delimiter lengths\n    opener.len -= useLen\n    closer.len -= useLen\n\n    // Update text nodes for opener/closer\n    var openerNode = nodes[opener.idx] as MarkdownToJSX.TextNode\n    var closerNode = nodes[closer.idx] as MarkdownToJSX.TextNode\n    openerNode.text = openerNode.text.slice(0, openerNode.text.length - useLen)\n    closerNode.text = closerNode.text.slice(useLen)\n\n    // Collect content nodes between opener and closer\n    var contentStart = opener.idx + 1\n    var contentEnd = closer.idx\n    var contentNodes = nodes.slice(contentStart, contentEnd)\n\n    // Create emphasis node - recursively process content for nested emphasis\n    var emphNode: MarkdownToJSX.TextFormattedNode = {\n      type: RuleType.textFormatted,\n      tag: isStrong ? 'strong' : 'em',\n      children: contentNodes,\n    }\n\n    // Replace content nodes with emphasis node\n    nodes.splice(contentStart, contentEnd - contentStart, emphNode as MarkdownToJSX.FormattedTextNode)\n\n    // Fix up indices in delimiter stack\n    var removed = contentEnd - contentStart - 1\n    for (var di = 0; di < delims.length; di++) {\n      if (delims[di].idx > opener.idx) {\n        delims[di].idx -= removed\n      }\n    }\n\n    // Deactivate delimiters between opener and closer\n    for (var di2 = openerIdx + 1; di2 < ci; di2++) {\n      delims[di2].active = false\n    }\n\n    // If opener is empty, deactivate\n    if (opener.len === 0) {\n      opener.active = false\n      // Remove empty text node\n      if (openerNode.text === '') {\n        nodes.splice(opener.idx, 1)\n        for (var di3 = 0; di3 < delims.length; di3++) {\n          if (delims[di3].idx > opener.idx) delims[di3].idx--\n          else if (delims[di3].idx === opener.idx) delims[di3].idx = -1\n        }\n      }\n    }\n\n    // If closer is empty, deactivate\n    if (closer.len === 0) {\n      closer.active = false\n      // Remove empty text node\n      var closerNewIdx = closer.idx\n      if (closerNode.text === '') {\n        nodes.splice(closerNewIdx, 1)\n        for (var di4 = 0; di4 < delims.length; di4++) {\n          if (delims[di4].idx > closerNewIdx) delims[di4].idx--\n          else if (delims[di4].idx === closerNewIdx) delims[di4].idx = -1\n        }\n      }\n    } else {\n      // Closer still has delimiters - don't advance, try matching again\n      continue\n    }\n    ci++\n  }\n\n  // Merge adjacent text nodes and remove empty ones\n  var wi = 0\n  for (var ni = 0; ni < nodes.length; ni++) {\n    var n = nodes[ni]\n    if (n.type === RuleType.text) {\n      var tn = n as MarkdownToJSX.TextNode\n      if (tn.text === '') continue\n      if (wi > 0 && nodes[wi - 1].type === RuleType.text) {\n        ;(nodes[wi - 1] as MarkdownToJSX.TextNode).text += tn.text\n        continue\n      }\n    }\n    nodes[wi++] = n\n  }\n  nodes.length = wi\n}\n\n/** Scan link [text](url) or ![alt](url) or [text][ref] or [text] */\nfunction scanLink(s: string, p: number, e: number, state: MarkdownToJSX.State, opts: ParseOptions): ScanResult {\n  const isImage = s.charCodeAt(p) === $.CHAR_EXCLAMATION // !\n  const start = isImage ? p + 1 : p\n\n  if (s.charCodeAt(start) !== $.CHAR_BRACKET_OPEN) return null // [\n\n  // Fast rejection: if no ] in range, no valid link possible\n  var closeBracket = s.indexOf(']', start + 1)\n  if (closeBracket < 0 || closeBracket >= e) return null\n\n  // Find closing ] - skip code spans, HTML tags, and autolinks\n  // Per CommonMark spec, we match brackets but don't nest them for link detection\n  var i = start + 1\n  var bracketEnd = -1\n  var depth = 1\n  while (i < e && depth > 0) {\n    var c = s.charCodeAt(i)\n    if (c === $.CHAR_BACKSLASH && i + 1 < e) { i += 2; continue }\n    // Code spans take precedence over link brackets\n    if (c === $.CHAR_BACKTICK) {\n      var after = skipCodeSpan(s, i, e)\n      if (after > i) { i = after; continue }\n    }\n    // HTML tags take precedence\n    if (c === $.CHAR_LT) {\n      // Check for autolink first\n      var autoResult = scanAutolink(s, i, e)\n      if (autoResult) { i = autoResult.end; continue }\n      var afterHTML = skipInlineHTMLElement(s, i, e)\n      if (afterHTML > i) { i = afterHTML; continue }\n    }\n    if (c === $.CHAR_BRACKET_OPEN) depth++\n    else if (c === $.CHAR_BRACKET_CLOSE) depth--\n    i++\n  }\n  if (depth !== 0) return null\n\n  var textEnd = i - 1\n  var text = s.slice(start + 1, textEnd)\n\n  // Check what follows the ]\n  var nextChar = i < e ? s.charCodeAt(i) : 0\n\n  // Inline link: [text](url)\n  var inlineLinkFailed = false\n  if (nextChar === $.CHAR_PAREN_OPEN) { // (\n    var inlineOk = true\n    i++\n\n    // Skip whitespace\n    while (i < e && (s.charCodeAt(i) === $.CHAR_SPACE || s.charCodeAt(i) === $.CHAR_NEWLINE)) i++\n\n    // Parse URL (can be in angle brackets or bare)\n    var url = '', urlEnd = i\n    if (i < e && s.charCodeAt(i) === $.CHAR_LT) { // <url>\n      i++\n      urlEnd = i\n      while (urlEnd < e && s.charCodeAt(urlEnd) !== $.CHAR_GT) {\n        if (s.charCodeAt(urlEnd) === $.CHAR_BACKSLASH && urlEnd + 1 < e) { urlEnd += 2; continue }\n        if (s.charCodeAt(urlEnd) === $.CHAR_NEWLINE) { inlineOk = false; break } // no newlines in angle URLs\n        urlEnd++\n      }\n      if (inlineOk && (urlEnd >= e || s.charCodeAt(urlEnd) !== $.CHAR_GT)) inlineOk = false\n      if (inlineOk) {\n        url = s.slice(i, urlEnd)\n        urlEnd++ // skip >\n      }\n    } else if (inlineOk) {\n      // Bare URL - count parens\n      var parenDepth = 0\n      while (urlEnd < e) {\n        var c2 = s.charCodeAt(urlEnd)\n        if (c2 === $.CHAR_BACKSLASH && urlEnd + 1 < e) { urlEnd += 2; continue }\n        if (c2 === $.CHAR_PAREN_OPEN) parenDepth++\n        else if (c2 === $.CHAR_PAREN_CLOSE) {\n          if (parenDepth === 0) break\n          parenDepth--\n        }\n        else if (c2 === $.CHAR_SPACE || c2 === $.CHAR_NEWLINE) break\n        urlEnd++\n      }\n      url = s.slice(i, urlEnd)\n    }\n\n    if (inlineOk) {\n      i = urlEnd\n      // Skip whitespace\n      while (i < e && (s.charCodeAt(i) === $.CHAR_SPACE || s.charCodeAt(i) === $.CHAR_NEWLINE)) i++\n\n      // Optional title\n      var title: string | undefined\n      if (i < e) {\n        var tc = s.charCodeAt(i)\n        if (tc === $.CHAR_DOUBLE_QUOTE || tc === $.CHAR_SINGLE_QUOTE || tc === $.CHAR_PAREN_OPEN) { // \" ' (\n          var closeChar = tc === $.CHAR_PAREN_OPEN ? 41 : tc\n          i++\n          var titleStart = i\n          while (i < e && s.charCodeAt(i) !== closeChar) {\n            if (s.charCodeAt(i) === $.CHAR_BACKSLASH && i + 1 < e) i++\n            i++\n          }\n          if (i >= e) inlineOk = false\n          else {\n            title = s.slice(titleStart, i)\n            i++ // skip close quote\n          }\n        }\n      }\n\n      if (inlineOk) {\n        // Skip whitespace and find closing )\n        while (i < e && (s.charCodeAt(i) === $.CHAR_SPACE || s.charCodeAt(i) === $.CHAR_NEWLINE)) i++\n        if (i >= e || s.charCodeAt(i) !== $.CHAR_PAREN_CLOSE) inlineOk = false\n      }\n    }\n\n    if (inlineOk) {\n      i++\n\n      // Unescape backslashes in URL and title\n      url = unescapeString(url)\n      if (title !== undefined) title = util.decodeEntityReferences(unescapeString(title))\n\n      // Sanitize URL - remove dangerous protocols\n      var sanitizer = opts?.sanitizer || util.sanitizer\n      var sanitizedUrl = sanitizer(url, isImage ? 'img' : 'a', isImage ? 'src' : 'href')\n      var safeUrl = sanitizedUrl === null ? null : url\n\n      if (isImage) {\n        // Parse inline content and flatten to plain text for alt attribute\n        var altNodes = parseInline(text, 0, text.length, state, opts)\n        var altText = extractText(altNodes)\n        return {\n          node: {\n            type: RuleType.image,\n            target: safeUrl,\n            alt: altText,\n            title: title,\n          } as MarkdownToJSX.ImageNode,\n          end: i\n        }\n      } else {\n        var savedAnchor = state.inAnchor; state.inAnchor = true\n        var children = savedAnchor ? [{ type: RuleType.text, text: text } as MarkdownToJSX.TextNode]\n          : parseInline(text, 0, text.length, state, opts)\n        state.inAnchor = savedAnchor\n        // Per CommonMark, links cannot contain other links\n        // If children contain a link, the outer link is invalid\n        if (!state.inAnchor && containsLink(children)) {\n          return null\n        }\n        return {\n          node: {\n            type: RuleType.link,\n            target: safeUrl,\n            title: title,\n            children: children,\n          } as MarkdownToJSX.LinkNode,\n          end: i\n        }\n      }\n    } else {\n      // Inline link failed - fall through to try shortcut reference\n      i = textEnd + 1 // reset i to after ]\n      inlineLinkFailed = true\n    }\n  }\n\n  // Reference link: [text][ref] or [text][] or [text]\n  var label = ''\n  var refEnd = i\n\n  if (!inlineLinkFailed && nextChar === $.CHAR_BRACKET_OPEN) { // [\n    // Full reference [text][ref] or collapsed [text][]\n    var refStart = i + 1\n    refEnd = refStart\n    var hasNestedBracket = false\n    while (refEnd < e && s.charCodeAt(refEnd) !== $.CHAR_BRACKET_CLOSE) {\n      if (s.charCodeAt(refEnd) === $.CHAR_BACKSLASH && refEnd + 1 < e) { refEnd += 2; continue }\n      if (s.charCodeAt(refEnd) === $.CHAR_BRACKET_OPEN) { hasNestedBracket = true; break }\n      refEnd++\n    }\n    if (hasNestedBracket || refEnd >= e) return null\n    var ref = s.slice(refStart, refEnd)\n    if (ref.trim()) {\n      // Full reference: [text][ref]\n      label = normalizeLabel(ref)\n    } else {\n      // Collapsed reference: [text][]\n      // Per CommonMark, labels cannot contain unescaped brackets\n      if (hasUnescapedBracket(text)) return null\n      label = normalizeLabel(text)\n    }\n    refEnd = refEnd + 1\n  } else {\n    // Shortcut reference: [text]\n    // Per CommonMark, labels cannot contain unescaped brackets\n    if (hasUnescapedBracket(text)) return null\n    label = normalizeLabel(text)\n  }\n\n  // Look up reference\n  var refData = state.refs[label]\n  if (!refData) return null\n\n  if (isImage) {\n    return {\n      node: {\n        type: RuleType.image,\n        target: refData.target,\n        alt: extractText(parseInline(text, 0, text.length, state, opts)),\n        title: refData.title,\n      } as MarkdownToJSX.ImageNode,\n      end: refEnd\n    }\n  } else {\n    var savedAnchor2 = state.inAnchor; state.inAnchor = true\n    var children = savedAnchor2 ? [{ type: RuleType.text, text: text } as MarkdownToJSX.TextNode]\n      : parseInline(text, 0, text.length, state, opts)\n    state.inAnchor = savedAnchor2\n    // Per CommonMark, links cannot contain other links\n    if (!state.inAnchor && containsLink(children)) {\n      return null\n    }\n    return {\n      node: {\n        type: RuleType.link,\n        target: refData.target,\n        title: refData.title,\n        children: children,\n      } as MarkdownToJSX.LinkNode,\n      end: refEnd\n    }\n  }\n}\n\n/** Scan autolink <url> or <email> */\nfunction scanAutolink(s: string, p: number, e: number): ScanResult {\n  if (s.charCodeAt(p) !== $.CHAR_LT) return null\n\n  var i = p + 1\n  // Find closing > - autolinks cannot contain spaces or newlines\n  while (i < e) {\n    var cc = s.charCodeAt(i)\n    if (cc === $.CHAR_GT) break\n    // Per CommonMark: autolinks cannot contain spaces, newlines, or < chars\n    if (cc === $.CHAR_SPACE || cc === $.CHAR_NEWLINE || cc === $.CHAR_CR || cc === $.CHAR_LT) return null\n    i++\n  }\n  if (i >= e || s.charCodeAt(i) !== $.CHAR_GT) return null\n\n  var content = s.slice(p + 1, i)\n\n  // Check for URL autolink: scheme must be 2-32 chars [a-zA-Z][a-zA-Z0-9+.-]{1,31}\n  // followed by : and the rest of the URI (no spaces already guaranteed above)\n  var schemeMatch = content.match(/^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^\\x00-\\x20]*)$/)\n  if (schemeMatch) {\n    return {\n      node: {\n        type: RuleType.link,\n        target: content,\n        children: [{ type: RuleType.text, text: content } as MarkdownToJSX.TextNode],\n      } as MarkdownToJSX.LinkNode,\n      end: i + 1\n    }\n  }\n\n  // Check for email autolink per CommonMark spec\n  if (content.indexOf('@') !== -1 && /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(content)) {\n    return {\n      node: {\n        type: RuleType.link,\n        target: 'mailto:' + content,\n        children: [{ type: RuleType.text, text: content } as MarkdownToJSX.TextNode],\n      } as MarkdownToJSX.LinkNode,\n      end: i + 1\n    }\n  }\n\n  return null\n}\n\n/** Scan footnote reference [^id] */\nfunction scanFootnoteRef(s: string, p: number, e: number, state: MarkdownToJSX.State): ScanResult {\n  // Must start with [^\n  if (s.charCodeAt(p) !== $.CHAR_BRACKET_OPEN || p + 1 >= e || s.charCodeAt(p + 1) !== $.CHAR_CARET) return null\n\n  let i = p + 2\n  // Find closing ]\n  while (i < e && s.charCodeAt(i) !== $.CHAR_BRACKET_CLOSE && s.charCodeAt(i) !== $.CHAR_NEWLINE) i++\n  if (i >= e || s.charCodeAt(i) !== $.CHAR_BRACKET_CLOSE) return null\n\n  const id = s.slice(p + 2, i)\n  if (!id) return null\n\n  // Return footnote reference regardless of whether ref exists\n  // (refs get populated during first pass)\n  return {\n    node: {\n      type: RuleType.footnoteReference,\n      target: '#' + util.slugify(id),\n      text: id,\n    } as MarkdownToJSX.FootnoteReferenceNode,\n    end: i + 1\n  }\n}\n\n/** Scan bare URL (https://..., http://..., or www.) */\nfunction scanBareUrl(s: string, p: number, e: number, opts: ParseOptions): ScanResult {\n  if (opts.disableBareUrls) return null\n\n  // Check for http://, https://, ftp://, or www. via charCode to avoid slice allocations\n  var prefix = ''\n  var isWww = false\n  var c0 = s.charCodeAt(p)\n  if (c0 === $.CHAR_H || c0 === 72) { // h/H\n    if (p + 8 <= e && s.charCodeAt(p+1) === $.CHAR_t && s.charCodeAt(p+2) === $.CHAR_t && s.charCodeAt(p+3) === $.CHAR_p) { // ttp\n      if (s.charCodeAt(p+4) === $.CHAR_s && s.charCodeAt(p+5) === $.CHAR_COLON && s.charCodeAt(p+6) === $.CHAR_SLASH && s.charCodeAt(p+7) === $.CHAR_SLASH) prefix = 'https://'\n      else if (s.charCodeAt(p+4) === $.CHAR_COLON && s.charCodeAt(p+5) === $.CHAR_SLASH && s.charCodeAt(p+6) === $.CHAR_SLASH) prefix = 'http://'\n    }\n  } else if (c0 === $.CHAR_f || c0 === 70) { // f/F\n    if (p + 6 <= e && s.charCodeAt(p+1) === $.CHAR_t && s.charCodeAt(p+2) === $.CHAR_p && s.charCodeAt(p+3) === $.CHAR_COLON && s.charCodeAt(p+4) === $.CHAR_SLASH && s.charCodeAt(p+5) === $.CHAR_SLASH) prefix = 'ftp://'\n  } else if (c0 === $.CHAR_W || c0 === 87) { // w/W\n    if (p + 4 <= e && s.charCodeAt(p+1) === $.CHAR_W && s.charCodeAt(p+2) === $.CHAR_W && s.charCodeAt(p+3) === $.CHAR_PERIOD) { prefix = 'www.'; isWww = true }\n  }\n  if (!prefix) return null\n\n  // Find end of URL (stop at whitespace or common punctuation at end)\n  let i = p + prefix.length\n  while (i < e) {\n    const c = s.charCodeAt(i)\n    // Stop at whitespace\n    if (c === $.CHAR_SPACE || c === $.CHAR_NEWLINE || c === $.CHAR_TAB || c === $.CHAR_CR) break\n    // Stop at certain characters that are unlikely to be part of URL\n    if (c === $.CHAR_LT || c === $.CHAR_GT) break // < >\n    i++\n  }\n\n  // Pre-count parens to avoid O(n²) slice+match in trimming loop\n  var openParens = 0, closeParens = 0\n  for (var pi = p; pi < i; pi++) {\n    var pc = s.charCodeAt(pi)\n    if (pc === $.CHAR_PAREN_OPEN) openParens++\n    else if (pc === $.CHAR_PAREN_CLOSE) closeParens++\n  }\n\n  // Trim trailing punctuation that's not part of URL\n  let end = i\n  while (end > p + prefix.length) {\n    const c = s.charCodeAt(end - 1)\n    if (c === $.CHAR_PERIOD || c === $.CHAR_COMMA || c === $.CHAR_COLON || // . , :\n        c === $.CHAR_EXCLAMATION || c === $.CHAR_QUESTION || c === $.CHAR_PAREN_CLOSE) { // ! ? )\n      // But keep ) if there's a matching (\n      if (c === $.CHAR_PAREN_CLOSE) {\n        if (openParens >= closeParens) break\n        closeParens--\n      }\n      end--\n    } else if (c === $.CHAR_SEMICOLON) { // ; — check for entity reference &word;\n      var ampPos = end - 2\n      while (ampPos > p && ((s.charCodeAt(ampPos) >= $.CHAR_A && s.charCodeAt(ampPos) <= $.CHAR_Z) || (s.charCodeAt(ampPos) >= $.CHAR_a && s.charCodeAt(ampPos) <= $.CHAR_z) || (s.charCodeAt(ampPos) >= $.CHAR_DIGIT_0 && s.charCodeAt(ampPos) <= $.CHAR_DIGIT_9))) ampPos--\n      if (ampPos >= p && s.charCodeAt(ampPos) === $.CHAR_AMPERSAND) { // &\n        end = ampPos // exclude &entity;\n      } else {\n        end-- // regular trailing ;\n      }\n    } else {\n      break\n    }\n  }\n\n  if (end <= p + prefix.length) return null\n\n  // Validate domain using charCode scan on original string (avoid slice/split)\n  // Domain runs from p+prefixLen to the first / or end\n  var dStart = p + (isWww ? 4 : prefix.length)\n  var dEnd = s.indexOf('/', dStart)\n  if (dEnd < 0 || dEnd > end) dEnd = end\n  // For www. links, need at least one dot in domain\n  if (isWww && s.indexOf('.', dStart) === -1) return null\n  // Check last two segments for underscores (GFM rule)\n  // Find last two dot positions by scanning backwards\n  var lastDotU = -1, prevDotU = -1\n  for (var di = dEnd - 1; di >= dStart; di--) {\n    if (s.charCodeAt(di) === $.CHAR_PERIOD) {\n      if (lastDotU < 0) lastDotU = di\n      else { prevDotU = di; break }\n    }\n  }\n  // segCheckStart = start of second-to-last segment (or domain start if <2 dots)\n  var segCheckStart = prevDotU >= 0 ? prevDotU + 1 : dStart\n  for (var di = segCheckStart; di < dEnd; di++) {\n    if (s.charCodeAt(di) === $.CHAR_UNDERSCORE) return null // underscore in last two segments\n  }\n\n  var url = s.slice(p, end)\n  // For www. links, prepend http:// for the target URL\n  var target = isWww ? 'http://' + url : url\n\n  return {\n    node: {\n      type: RuleType.link,\n      target: target,\n      children: [{ type: RuleType.text, text: url } as MarkdownToJSX.TextNode],\n    } as MarkdownToJSX.LinkNode,\n    end\n  }\n}\n\n/** Scan bare email autolink (GFM extension) */\nfunction scanBareEmail(s: string, p: number, e: number, opts: ParseOptions): ScanResult {\n  if (opts.disableBareUrls) return null\n  // Email local part: [a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+\n  var i = p\n  var localStart = i\n  while (i < e) {\n    var c = s.charCodeAt(i)\n    if ((c >= $.CHAR_A && c <= $.CHAR_Z) || (c >= $.CHAR_a && c <= $.CHAR_z) || (c >= $.CHAR_DIGIT_0 && c <= $.CHAR_DIGIT_9) ||\n        c === $.CHAR_PERIOD || c === $.CHAR_EXCLAMATION || c === $.CHAR_HASH || c === 36 || c === $.CHAR_PERCENT || c === $.CHAR_AMPERSAND ||\n        c === $.CHAR_SINGLE_QUOTE || c === $.CHAR_ASTERISK || c === $.CHAR_PLUS || c === $.CHAR_SLASH || c === $.CHAR_EQ || c === $.CHAR_QUESTION ||\n        c === $.CHAR_CARET || c === $.CHAR_UNDERSCORE || c === $.CHAR_BACKTICK || c === $.CHAR_BRACE_OPEN || c === $.CHAR_PIPE || c === $.CHAR_BRACE_CLOSE ||\n        c === $.CHAR_TILDE || c === $.CHAR_DASH) {\n      i++\n    } else break\n  }\n  if (i === localStart) return null\n  if (i >= e || s.charCodeAt(i) !== $.CHAR_AT) return null // @\n  i++ // skip @\n  // Domain: alphanumeric, hyphens, underscores, separated by dots\n  // Per GFM: last two segments can't have underscore, last char can't be - or _\n  var domainStart = i\n  var lastDot = -1\n  var labelStart = i\n  while (i < e) {\n    var c = s.charCodeAt(i)\n    if ((c >= $.CHAR_A && c <= $.CHAR_Z) || (c >= $.CHAR_a && c <= $.CHAR_z) || (c >= $.CHAR_DIGIT_0 && c <= $.CHAR_DIGIT_9)) {\n      i++\n    } else if ((c === $.CHAR_DASH || c === $.CHAR_UNDERSCORE) && i > domainStart) { // hyphen or underscore (not at start)\n      i++\n    } else if (c === $.CHAR_PERIOD) { // dot\n      if (i === domainStart) break\n      var prev = s.charCodeAt(i - 1)\n      if (prev === $.CHAR_DASH || prev === $.CHAR_UNDERSCORE) break // hyphen/underscore before dot invalid\n      if (i - labelStart > 63) break // DNS label max 63 chars (RFC 1035)\n      // Only consume dot if followed by alphanumeric (valid domain continuation)\n      if (i + 1 < e) {\n        var nextDC = s.charCodeAt(i + 1)\n        if ((nextDC >= $.CHAR_A && nextDC <= $.CHAR_Z) || (nextDC >= $.CHAR_a && nextDC <= $.CHAR_z) || (nextDC >= $.CHAR_DIGIT_0 && nextDC <= $.CHAR_DIGIT_9)) {\n          lastDot = i\n          labelStart = i + 1\n          i++\n        } else break // trailing dot — don't consume\n      } else break // dot at end — don't consume\n    } else break\n  }\n  if (i - labelStart > 63) return null // final label exceeds DNS limit\n  if (lastDot < 0) return null // need at least one dot\n  // Last char of domain must be alphanumeric (not hyphen, underscore, or dot)\n  var lastDomainChar = s.charCodeAt(i - 1)\n  if (!((lastDomainChar >= $.CHAR_A && lastDomainChar <= $.CHAR_Z) || (lastDomainChar >= $.CHAR_a && lastDomainChar <= $.CHAR_z) || (lastDomainChar >= $.CHAR_DIGIT_0 && lastDomainChar <= $.CHAR_DIGIT_9))) return null\n  if (i <= lastDot + 1) return null // need content after last dot\n  // Check last two domain segments don't have underscores (charCode scan, no slice/split)\n  // Walk from lastDot backwards to find second-to-last dot\n  var prevDot = -1\n  for (var di = lastDot - 1; di >= domainStart; di--) {\n    if (s.charCodeAt(di) === $.CHAR_PERIOD) { prevDot = di; break }\n  }\n  var segCheckStart = prevDot >= 0 ? prevDot + 1 : domainStart\n  for (var di = segCheckStart; di < i; di++) {\n    if (s.charCodeAt(di) === $.CHAR_UNDERSCORE) return null // underscore in last two segments\n  }\n  var email = s.slice(p, i)\n  return {\n    node: {\n      type: RuleType.link,\n      target: 'mailto:' + email,\n      children: [{ type: RuleType.text, text: email } as MarkdownToJSX.TextNode],\n    } as MarkdownToJSX.LinkNode,\n    end: i\n  }\n}\n\n/** Check if nodes contain a link (for no-nested-links rule) */\nfunction containsLink(nodes: MarkdownToJSX.ASTNode[]): boolean {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].type === RuleType.link) return true\n    if ('children' in nodes[i] && Array.isArray((nodes[i] as ASTNodeWithChildren).children)) {\n      if (containsLink((nodes[i] as ASTNodeWithChildren).children)) return true\n    }\n  }\n  return false\n}\n\nfunction extractText(nodes: MarkdownToJSX.ASTNode[]): string {\n  var result = ''\n  for (var ni = 0; ni < nodes.length; ni++) {\n    var n = nodes[ni]\n    if (n.type === RuleType.text) result += (n as MarkdownToJSX.TextNode).text\n    else if (n.type === RuleType.breakLine) result += ' '\n    else if (n.type === RuleType.codeInline) result += (n as MarkdownToJSX.CodeInlineNode).text\n    else if ('children' in n && Array.isArray((n as ASTNodeWithChildren).children)) result += extractText((n as ASTNodeWithChildren).children)\n    else if (n.type === RuleType.image) result += (n as MarkdownToJSX.ImageNode).alt || ''\n    else if (n.type === RuleType.link) result += extractText((n as MarkdownToJSX.LinkNode).children)\n  }\n  return result\n}\n\n/** Create a text node with entity decoding */\nfunction textNode(text: string): MarkdownToJSX.TextNode {\n  // Decode HTML entities if present\n  const decoded = text.includes('&') ? util.decodeEntityReferences(text) : text\n  return { type: RuleType.text, text: decoded } as MarkdownToJSX.TextNode\n}\n\n/** Scan inline HTML element - CommonMark types 1-7 */\nfunction scanInlineHTML(s: string, p: number, e: number, state: MarkdownToJSX.State, opts: ParseOptions): ScanResult {\n  if (s.charCodeAt(p) !== $.CHAR_LT) return null\n\n  var i = p + 1\n  if (i >= e) return null\n  var ch = s.charCodeAt(i)\n\n  // Type 2: HTML comment <!-- ... -->\n  if (ch === $.CHAR_EXCLAMATION && i + 1 < e && s.charCodeAt(i + 1) === $.CHAR_DASH && i + 2 < e && s.charCodeAt(i + 2) === $.CHAR_DASH) {\n    var commentStart = i + 3\n    // Special case: <!--> (empty comment)\n    if (commentStart < e && s.charCodeAt(commentStart) === $.CHAR_GT) {\n      return {\n        node: { type: RuleType.htmlComment, text: '', endsWithGreaterThan: true } as HTMLCommentNodeExt,\n        end: commentStart + 1\n      }\n    }\n    // Special case: <!---> (comment with single dash)\n    if (commentStart + 1 < e && s.charCodeAt(commentStart) === $.CHAR_DASH && s.charCodeAt(commentStart + 1) === $.CHAR_GT) {\n      return {\n        node: { type: RuleType.htmlComment, text: '-', endsWithGreaterThan: true } as HTMLCommentNodeExt,\n        end: commentStart + 2\n      }\n    }\n    // Regular comment: scan for -->\n    var endComment = s.indexOf('-->', commentStart)\n    if (endComment !== -1 && endComment <= e - 3) {\n      return {\n        node: {\n          type: RuleType.htmlComment,\n          text: s.slice(p + 4, endComment),\n        } as MarkdownToJSX.HTMLCommentNode,\n        end: endComment + 3\n      }\n    }\n    return null\n  }\n\n  // Type 3: Processing instruction <?...?>\n  if (ch === $.CHAR_QUESTION) {\n    var endPI = s.indexOf('?>', i + 1)\n    if (endPI !== -1 && endPI < e) {\n      return {\n        node: { type: RuleType.htmlSelfClosing, tag: '?', attrs: {}, _rawText: s.slice(p, endPI + 2) } as MarkdownToJSX.HTMLSelfClosingNode,\n        end: endPI + 2\n      }\n    }\n    return null\n  }\n\n  // Type 4/5: Declaration <!LETTER...> or CDATA <![CDATA[...]]>\n  if (ch === $.CHAR_EXCLAMATION && i + 1 < e) {\n    var nextCh = s.charCodeAt(i + 1)\n    // CDATA: <![CDATA[...]]>\n    if (nextCh === $.CHAR_BRACKET_OPEN && s.slice(i + 1, i + 8) === '[CDATA[') {\n      var endCDATA = s.indexOf(']]>', i + 8)\n      if (endCDATA !== -1 && endCDATA < e) {\n        return {\n          node: { type: RuleType.htmlSelfClosing, tag: '![CDATA[', attrs: {}, _rawText: s.slice(p, endCDATA + 3) } as MarkdownToJSX.HTMLSelfClosingNode,\n          end: endCDATA + 3\n        }\n      }\n      return null\n    }\n    // Declaration: <!LETTER ...>\n    if (nextCh >= $.CHAR_A && nextCh <= $.CHAR_Z) {\n      var endDecl = s.indexOf('>', i + 2)\n      if (endDecl !== -1 && endDecl < e) {\n        return {\n          node: { type: RuleType.htmlSelfClosing, tag: '!' + s.slice(i + 1, endDecl), attrs: {}, _rawText: s.slice(p, endDecl + 1) } as MarkdownToJSX.HTMLSelfClosingNode,\n          end: endDecl + 1\n        }\n      }\n      return null\n    }\n  }\n\n  // Type 6: Closing tag </tagname optional-whitespace>\n  if (ch === $.CHAR_SLASH) {\n    var j = i + 1\n    if (j >= e) return null\n    var c0 = s.charCodeAt(j)\n    if (!((c0 >= $.CHAR_A && c0 <= $.CHAR_Z) || (c0 >= $.CHAR_a && c0 <= $.CHAR_z))) return null\n    j++\n    while (j < e) {\n      var cc = s.charCodeAt(j)\n      if ((cc >= $.CHAR_A && cc <= $.CHAR_Z) || (cc >= $.CHAR_a && cc <= $.CHAR_z) || (cc >= $.CHAR_DIGIT_0 && cc <= $.CHAR_DIGIT_9) || cc === $.CHAR_DASH) {\n        j++\n      } else break\n    }\n    // Skip optional whitespace\n    while (j < e && (s.charCodeAt(j) === $.CHAR_SPACE || s.charCodeAt(j) === $.CHAR_TAB || s.charCodeAt(j) === $.CHAR_NEWLINE)) j++\n    if (j < e && s.charCodeAt(j) === $.CHAR_GT) {\n      var closeTagName = s.slice(i + 1, j).trim()\n      return {\n        node: { type: RuleType.htmlSelfClosing, tag: closeTagName, attrs: {}, _rawText: s.slice(p, j + 1), _isClosingTag: true } as MarkdownToJSX.HTMLSelfClosingNode,\n        end: j + 1\n      }\n    }\n    return null\n  }\n\n  // Type 1/7: Open tag - must start with letter\n  if (!((ch >= $.CHAR_A && ch <= $.CHAR_Z) || (ch >= $.CHAR_a && ch <= $.CHAR_z))) return null\n\n  // Try parsing as a structured HTML tag first (for tags with closing tags in scope)\n  var tagResult = __parseHTMLTag(s, p)\n  if (!tagResult) return null\n\n  var tagName = tagResult.tag\n  var tagNameLower = tagName.toLowerCase()\n  var selfClosing = tagResult.selfClosing\n\n  // Self-closing tag or void element - preserve raw text for HTML compiler\n  if (selfClosing || util.isVoidElement(tagName)) {\n    return {\n      node: {\n        type: RuleType.htmlSelfClosing,\n        tag: tagName,\n        attrs: processHTMLAttributes(tagResult.attrs, tagName, opts),\n        _rawText: s.slice(p, tagResult.end),\n      } as MarkdownToJSX.HTMLSelfClosingNode,\n      end: tagResult.end\n    }\n  }\n\n  // Verbatim tags (script, style, pre, textarea)\n  var isVerbatim = TYPE1_TAGS.has(tagNameLower)\n\n  // Find closing tag (within the inline scope)\n  var closeEnd = findClosingTag(s.slice(0, e), tagResult.end, tagName)\n  if (closeEnd === -1) {\n    // No closing tag found - pass through as raw HTML open tag (CommonMark spec)\n    return {\n      node: { type: RuleType.htmlSelfClosing, tag: tagName, attrs: processHTMLAttributes(tagResult.attrs, tagName, opts), _rawText: s.slice(p, tagResult.end) } as MarkdownToJSX.HTMLSelfClosingNode,\n      end: tagResult.end\n    }\n  }\n\n  // Find where closing tag starts\n  var closeTagStart = lastIndexOfCI(s, '</' + tagNameLower, closeEnd)\n  var innerContent = s.slice(tagResult.end, closeTagStart)\n\n  var children: MarkdownToJSX.ASTNode[] = []\n\n  if (isVerbatim) {\n    if (innerContent.trim()) {\n      children = [{\n        type: RuleType.text,\n        text: innerContent,\n      } as MarkdownToJSX.TextNode]\n    }\n  } else {\n    var trimmed = innerContent.trim()\n    if (trimmed) {\n      var savedAnchorH = state.inAnchor, savedInlineH = state.inline\n      if (tagNameLower === 'a') state.inAnchor = true\n      var hasBlocks = trimmed.indexOf('\\n\\n') !== -1 || /^#{1,6}\\s/.test(trimmed)\n      if (hasBlocks) {\n        state.inline = false\n        children = parseBlocks(trimmed, state, opts)\n      } else {\n        children = parseInline(trimmed, 0, trimmed.length, state, opts)\n      }\n      state.inAnchor = savedAnchorH; state.inline = savedInlineH\n    }\n  }\n\n  return {\n    node: {\n      type: RuleType.htmlBlock,\n      tag: tagName,\n      attrs: processHTMLAttributes(tagResult.attrs, tagName, opts),\n      _rawAttrs: tagResult.rawAttrs,\n      children,\n      text: innerContent,\n      _verbatim: false,\n    } as MarkdownToJSX.HTMLNode,\n    end: closeEnd\n  }\n}\n\n/** Parse inline content */\n// Maximum inline recursion depth\nconst MAX_INLINE_DEPTH = 200\n\n// Reusable state object to avoid allocations - use counter for depth tracking\nlet _globalInlineDepth = 0\n\nfunction parseInline(s: string, p: number, e: number, state: MarkdownToJSX.State, opts: ParseOptions): MarkdownToJSX.ASTNode[] {\n  // Track inline depth using global counter for stack overflow protection\n  _globalInlineDepth++\n  if (_globalInlineDepth > MAX_INLINE_DEPTH) {\n    _globalInlineDepth--\n    // Return content as plain text to prevent stack overflow\n    return [{ type: RuleType.text, text: s.slice(p, e) }]\n  }\n\n  // Use state directly to avoid object spread allocation\n  const childState = state\n\n  // If streaming mode, preprocess to strip incomplete markers BEFORE parsing\n  // This prevents bare URLs inside incomplete links from being autolinked\n  if (opts.streaming || opts.optimizeForStreaming) {\n    let content = s.slice(p, e)\n    const original = content\n    // Strip incomplete emphasis/strikethrough by counting delimiter pairs\n    // in a single charCode scan. For each delimiter type, if the count is\n    // odd (unmatched opener), find and strip from the last unmatched one.\n    var starDbl = 0, starSgl = 0, undDbl = 0, undSgl = 0, tilDbl = 0\n    var lastStarDbl = -1, lastStarSgl = -1, lastUndDbl = -1, lastUndSgl = -1, lastTilDbl = -1\n    for (var ei = 0; ei < content.length; ei++) {\n      var ec = content.charCodeAt(ei)\n      if (ec === $.CHAR_ASTERISK) {\n        if (ei + 1 < content.length && content.charCodeAt(ei + 1) === $.CHAR_ASTERISK) {\n          starDbl++; lastStarDbl = ei; ei++\n        } else {\n          starSgl++; lastStarSgl = ei\n        }\n      } else if (ec === $.CHAR_UNDERSCORE) {\n        if (ei + 1 < content.length && content.charCodeAt(ei + 1) === $.CHAR_UNDERSCORE) {\n          undDbl++; lastUndDbl = ei; ei++\n        } else {\n          undSgl++; lastUndSgl = ei\n        }\n      } else if (ec === $.CHAR_TILDE) {\n        if (ei + 1 < content.length && content.charCodeAt(ei + 1) === $.CHAR_TILDE) {\n          tilDbl++; lastTilDbl = ei; ei++\n        } else {\n          // single ~ is not a delimiter, skip\n        }\n      }\n    }\n    // Remove the last unmatched delimiter (just the marker chars, keep content).\n    // Collect removals sorted right-to-left to avoid index shifts.\n    var removals: [number, number][] = []\n    if (tilDbl % 2 === 1 && lastTilDbl >= 0) removals.push([lastTilDbl, 2])\n    if (undDbl % 2 === 1 && lastUndDbl >= 0) removals.push([lastUndDbl, 2])\n    if (undSgl % 2 === 1 && lastUndSgl >= 0) removals.push([lastUndSgl, 1])\n    if (starDbl % 2 === 1 && lastStarDbl >= 0) removals.push([lastStarDbl, 2])\n    if (starSgl % 2 === 1 && lastStarSgl >= 0) removals.push([lastStarSgl, 1])\n    // Sort descending by position so earlier splices don't shift later ones\n    removals.sort(function (a, b) { return b[0] - a[0] })\n    for (var ri = 0; ri < removals.length; ri++) {\n      var rPos = removals[ri][0], rLen = removals[ri][1]\n      content = content.slice(0, rPos) + content.slice(rPos + rLen)\n    }\n    // Strip incomplete inline code - count backticks to detect unmatched\n    // Only strip if there's an unmatched opening backtick\n    let backtickCount = 0\n    let lastBacktickPos = -1\n    for (let bi = 0; bi < content.length; bi++) {\n      if (content.charCodeAt(bi) === $.CHAR_BACKTICK) { // `\n        backtickCount++\n        lastBacktickPos = bi\n      }\n    }\n    if (backtickCount % 2 === 1 && lastBacktickPos !== -1) {\n      // Find the last unmatched opening backtick and strip from there\n      // Work backwards to find where the incomplete code span starts\n      let inCode = false\n      let codeStart = -1\n      let i = 0\n      while (i < content.length) {\n        if (content.charCodeAt(i) === $.CHAR_BACKTICK) {\n          if (!inCode) {\n            codeStart = i\n            inCode = true\n          } else {\n            inCode = false\n            codeStart = -1\n          }\n        }\n        i++\n      }\n      if (inCode && codeStart !== -1) {\n        content = content.slice(0, codeStart)\n      }\n    }\n    // Strip incomplete link/image markers using charCode scan.\n    // Handles nested constructs like [![alt](img)](link).\n    // Find matching ] for a [ at position pos, respecting bracket nesting.\n    function findMatchingClose(str: string, pos: number): number {\n      var depth = 1\n      for (var fi = pos + 1; fi < str.length; fi++) {\n        var fc = str.charCodeAt(fi)\n        if (fc === $.CHAR_BRACKET_OPEN) depth++\n        else if (fc === $.CHAR_BRACKET_CLOSE) { depth--; if (depth === 0) return fi }\n      }\n      return -1\n    }\n    // Loop to handle nested constructs (e.g. [![alt](img-url being typed)\n    // First pass strips outer [, second pass strips inner ![\n    var linkDidStrip = true\n    while (linkDidStrip) {\n      linkDidStrip = false\n      var linkStripPos = -1\n      var linkTextStart = -1\n      var linkTextEnd = -1\n      var linkIsImage = false\n      for (var li = 0; li < content.length; li++) {\n        var lc = content.charCodeAt(li)\n        if (lc === $.CHAR_BRACKET_OPEN && (li === 0 || content.charCodeAt(li - 1) !== $.CHAR_BACKSLASH)) {\n          var imgPrefix = li > 0 && content.charCodeAt(li - 1) === $.CHAR_EXCLAMATION\n          var lStart = imgPrefix ? li - 1 : li\n          var lClose = findMatchingClose(content, li)\n          if (lClose === -1) {\n            // [text... — no matching ]\n            linkStripPos = lStart; linkIsImage = imgPrefix\n            linkTextStart = li + 1\n            linkTextEnd = content.length\n          } else {\n            var lAfter = lClose + 1\n            if (lAfter >= content.length) {\n              // [text] at end — no destination yet\n              linkStripPos = lStart; linkIsImage = imgPrefix\n              linkTextStart = li + 1\n              linkTextEnd = lClose\n            } else if (content.charCodeAt(lAfter) === $.CHAR_PAREN_OPEN) {\n              var lParen = content.indexOf(')', lAfter + 1)\n              if (lParen === -1) {\n                // [text](url — incomplete\n                linkStripPos = lStart; linkIsImage = imgPrefix\n                linkTextStart = li + 1\n                linkTextEnd = lClose\n                li = content.length\n              } else {\n                // [text](url) — complete, skip past\n                li = lParen\n              }\n            } else if (content.charCodeAt(lAfter) === $.CHAR_BRACKET_OPEN) {\n              var lRef = content.indexOf(']', lAfter + 1)\n              if (lRef === -1) {\n                // [text][ref — incomplete ref\n                linkStripPos = lStart; linkIsImage = imgPrefix\n                linkTextStart = li + 1\n                linkTextEnd = lClose\n                li = content.length\n              } else {\n                // [text][ref] — complete ref, skip past\n                li = lRef\n              }\n            } else {\n              // [text] followed by non-link char — not a link, skip\n              li = lClose\n            }\n          }\n        }\n      }\n      if (linkStripPos >= 0) {\n        // For images, suppress entirely (alt text is metadata, not content).\n        // For links, show the link text as plain text.\n        var linkText = linkIsImage ? '' : content.slice(linkTextStart, linkTextEnd)\n        content = content.slice(0, linkStripPos) + linkText\n        linkDidStrip = true\n      }\n    }\n    // Strip incomplete HTML/JSX tags - <Tag>content but no closing </Tag>\n    // Match <TagName...>content at end without corresponding closing tag\n    // But skip if the tag is inside a code span (backticks)\n    const tagMatch = content.match(/<([A-Z][A-Za-z0-9]*)(?:\\s[^>]*)?>([^<]*)$/)\n    if (tagMatch && tagMatch.index !== undefined) {\n      // Check if the match position is inside backtick code spans\n      var inCodeSpan = false\n      var btCount = 0\n      for (var ci = 0; ci < tagMatch.index; ci++) {\n        if (content.charCodeAt(ci) === $.CHAR_BACKTICK) btCount++\n      }\n      inCodeSpan = btCount % 2 === 1\n      if (!inCodeSpan) {\n        const tagName = tagMatch[1]\n        // Only strip if there's no closing tag for this tag\n        if (indexOfCI(content, '</' + tagName, 0) === -1) {\n          // Strip the unclosed tag but keep the inner content\n          content = content.replace(/<[A-Z][A-Za-z0-9]*(?:\\s[^>]*)?>([^<]*)$/, '$1')\n        }\n      }\n    }\n\n    if (content !== original) {\n      s = s.slice(0, p) + content\n      e = p + content.length\n    }\n  }\n\n  const nodes: MarkdownToJSX.ASTNode[] = []\n  var delimStack: DelimEntry[] = []\n  let textStart = p\n  // Pre-scan for @ position to avoid calling scanBareEmail on positions far before any @\n  // Skip scan entirely when autolinks are disabled or when in anchor context\n  var nextAtPos = (opts.disableAutoLink || opts.disableBareUrls || childState.inAnchor) ? -1 : s.indexOf('@', p)\n  if (nextAtPos >= e) nextAtPos = -1\n\n  while (p < e) {\n    const c = s.charCodeAt(p)\n    let result: ScanResult = null\n\n    // Try inline scanners\n    if (c === $.CHAR_BACKTICK) {\n      result = scanCodeSpan(s, p, e)\n      if (!result) {\n        // Skip entire backtick run as text (per CommonMark, unmatched backtick strings are literal)\n        var btLen = countChar(s, p, e, $.CHAR_BACKTICK)\n        p += btLen - 1 // -1 because p++ at end of loop\n      }\n    } else if (c === $.CHAR_ASTERISK || c === $.CHAR_UNDERSCORE) { // * or _\n      // Collect delimiter for two-phase emphasis processing\n      var dinfo = collectDelimiter(s, p, e)\n      if (dinfo) {\n        if (dinfo.canOpen || dinfo.canClose) {\n          // Flush text before delimiter\n          if (p > textStart) {\n            nodes.push(textNode(s.slice(textStart, p)))\n          }\n          var delimText = s.slice(p, p + dinfo.len)\n          var delimNode = textNode(delimText)\n          delimStack.push({\n            idx: nodes.length,\n            ch: c,\n            len: dinfo.len,\n            canOpen: dinfo.canOpen,\n            canClose: dinfo.canClose,\n            active: true,\n          })\n          nodes.push(delimNode)\n          p += dinfo.len\n          textStart = p\n          continue\n        }\n        // Not a valid delimiter - skip entire run as text\n        p += dinfo.len - 1 // -1 because p++ at end of loop\n      }\n      // Fall through to regular text handling\n    } else if (c === $.CHAR_TILDE) { // ~\n      result = scanStrikethrough(s, p, e, childState, opts)\n    } else if (c === $.CHAR_EQ) { // = - potential ==marked==\n      result = scanMarked(s, p, e, childState, opts)\n    } else if (c === $.CHAR_BRACKET_OPEN) { // [\n      // Check for footnote reference [^id] first\n      if (p + 1 < e && s.charCodeAt(p + 1) === $.CHAR_CARET) { // ^\n        result = scanFootnoteRef(s, p, e, childState)\n      }\n      if (!result) {\n        result = scanLink(s, p, e, childState, opts)\n      }\n    } else if (c === $.CHAR_EXCLAMATION && p + 1 < e && s.charCodeAt(p + 1) === $.CHAR_BRACKET_OPEN) { // ![\n      result = scanLink(s, p, e, childState, opts)\n    } else if (c === $.CHAR_LT) { // < - autolink or HTML\n      // Try angle-bracket autolinks first (per CommonMark spec, autolinks take priority)\n      result = scanAutolink(s, p, e)\n      if (!result && !opts.disableParsingRawHTML && !opts.ignoreHTMLBlocks) {\n        result = scanInlineHTML(s, p, e, childState, opts)\n      }\n    } else if ((c === $.CHAR_H || c === $.CHAR_W || c === $.CHAR_f) && !childState.inAnchor && !opts.disableAutoLink) {\n      // h, w, f - potential http://, https://, www., or ftp://\n      if (p === 0 || s.charCodeAt(p - 1) !== $.CHAR_LT) {\n        result = scanBareUrl(s, p, e, opts)\n      }\n    }\n    // Email autolink: try when we see alphanumeric that could be local part of email\n    // nextAtPos tracks next @ position — only attempt email scan within 64 chars of @\n    if (!result && nextAtPos >= 0 && nextAtPos - p <= 64 && !childState.inAnchor && !opts.disableAutoLink && !opts.disableBareUrls &&\n        ((c >= $.CHAR_A && c <= $.CHAR_Z) || (c >= $.CHAR_a && c <= $.CHAR_z) || (c >= $.CHAR_DIGIT_0 && c <= $.CHAR_DIGIT_9))) {\n      result = scanBareEmail(s, p, e, opts)\n      // If we passed the @, advance to next one (bounded to [p+1, e))\n      if (!result && p >= nextAtPos) {\n        nextAtPos = s.indexOf('@', p + 1)\n        if (nextAtPos >= e) nextAtPos = -1\n      }\n    }\n\n    // Handle hard break marker from parseInlineWithBreaks\n    if (c === $.CHAR_UNIT_SEP) { // \\u001F break marker\n      if (p > textStart) {\n        nodes.push(textNode(s.slice(textStart, p)))\n      }\n      nodes.push({ type: RuleType.breakLine } as MarkdownToJSX.BreakLineNode)\n      p++\n      textStart = p\n      continue\n    }\n\n    if (result) {\n      // Flush text before this\n      if (p > textStart) {\n        nodes.push(textNode(s.slice(textStart, p)))\n      }\n      nodes.push(result.node)\n      p = result.end\n      textStart = p\n    } else {\n      // Handle escapes\n      if (c === $.CHAR_BACKSLASH && p + 1 < e) {\n        const next = s.charCodeAt(p + 1)\n        if (cc(next) & C_PUNCT) {\n          if (p > textStart) {\n            nodes.push(textNode(s.slice(textStart, p)))\n          }\n          nodes.push(textNode(s[p + 1]))\n          p += 2\n          textStart = p\n          continue\n        }\n      }\n      // Skip ahead through plain text to next special character\n      p++\n      // Only skip when not near an @ (email detection needs alphanumeric chars)\n      if (nextAtPos < 0 || nextAtPos - p > 64) {\n        while (p < e) {\n          var nc = s.charCodeAt(p)\n          if (nc < $.CHAR_ASCII_BOUNDARY && !INLINE_SPECIAL[nc]) p++\n          else break\n        }\n      }\n    }\n  }\n\n  // Flush remaining text\n  if (e > textStart) {\n    let remainingText = s.slice(textStart, e)\n\n    // If streaming mode is enabled, strip incomplete markers from end of text\n    if (opts.streaming || opts.optimizeForStreaming) {\n      // Strip incomplete bold markers **text\n      remainingText = remainingText.replace(/\\*\\*([^*]+)$/, '$1')\n      // Strip incomplete italic markers *text (but not after stripping bold)\n      if (remainingText.match(/\\*[^*]+$/)) {\n        remainingText = remainingText.replace(/\\*([^*]+)$/, '$1')\n      }\n      // Strip incomplete underscore bold markers __text\n      remainingText = remainingText.replace(/__([^_]+)$/, '$1')\n      // Strip incomplete underscore italic markers _text\n      if (remainingText.match(/_[^_]+$/)) {\n        remainingText = remainingText.replace(/_([^_]+)$/, '$1')\n      }\n      // Strip incomplete strikethrough markers ~~text\n      remainingText = remainingText.replace(/~~([^~]+)$/, '$1')\n      // Strip incomplete link markers [text (no ])\n      remainingText = remainingText.replace(/\\[([^\\]]+)$/, '$1')\n      // Strip [text]( without closing ) - partial inline link\n      remainingText = remainingText.replace(/\\[([^\\]]+)\\]\\([^)]*$/, '$1')\n    }\n\n    if (remainingText) {\n      nodes.push(textNode(remainingText))\n    }\n  }\n\n  // Phase 2: Process emphasis delimiters using CommonMark algorithm\n  if (delimStack.length > 0) {\n    processEmphasis(nodes, delimStack, state, opts)\n  }\n\n  _globalInlineDepth--\n  return nodes\n}\n\n// ============================================================================\n// BLOCK PARSER\n// ============================================================================\n\n/** Parse block-level content */\n// Maximum recursion depth to prevent stack overflow\nconst MAX_PARSE_DEPTH = 500\n\nfunction parseBlocks(s: string, state: MarkdownToJSX.State, opts: ParseOptions): MarkdownToJSX.ASTNode[] {\n  // Track depth in state for stack overflow protection (mutate in place, restore on exit)\n  var savedDepth = state._depth || 0\n\n  if (savedDepth > MAX_PARSE_DEPTH) {\n    return [{ type: RuleType.text, text: s }]\n  }\n\n  state._depth = savedDepth + 1\n  const childState = state\n\n  // For streaming mode: strip incomplete tables (header + separator without data rows)\n  // Only strip if the table is at the END of the input (might be incomplete during streaming)\n  if (opts.streaming || opts.optimizeForStreaming) {\n    // Pattern: table at end with only header + separator (no data rows after)\n    // Scan backwards to find last two lines; check if they form header + separator\n    var sEnd = s.length\n    // skip trailing newline\n    if (sEnd > 0 && s.charCodeAt(sEnd - 1) === $.CHAR_NEWLINE) sEnd--\n    // find start of last line (separator candidate)\n    var sepStart = sEnd\n    while (sepStart > 0 && s.charCodeAt(sepStart - 1) !== $.CHAR_NEWLINE) sepStart--\n    if (sepStart > 0 && s.charCodeAt(sepStart) === $.CHAR_PIPE) {\n      // validate separator line contains only [ \\t\\-:|]\n      var isSep = true\n      for (var vi = sepStart; vi < sEnd; vi++) {\n        var vc = s.charCodeAt(vi)\n        if (vc !== $.CHAR_SPACE && vc !== $.CHAR_TAB && vc !== $.CHAR_DASH && vc !== $.CHAR_COLON && vc !== $.CHAR_PIPE) {\n          isSep = false\n          break\n        }\n      }\n      if (isSep) {\n        // find start of header line\n        var hdrStart = sepStart - 1 // skip the \\n before separator\n        while (hdrStart > 0 && s.charCodeAt(hdrStart - 1) !== $.CHAR_NEWLINE) hdrStart--\n        if (s.charCodeAt(hdrStart) === $.CHAR_PIPE) {\n          s = s.slice(0, hdrStart).trimEnd()\n        }\n      }\n    }\n\n    // Also handle single-line incomplete table (header and partial separator on same line)\n    // Uses charCode scan instead of nested-quantifier regex to avoid ReDoS\n    var trimmedS = s.trim()\n    var lastNL = trimmedS.lastIndexOf('\\n')\n    var lastLine = lastNL === -1 ? trimmedS : trimmedS.slice(lastNL + 1)\n    if (lastLine.length > 0 && lastLine.charCodeAt(0) === $.CHAR_PIPE) {\n      // Check if last line has pipes and ends with delimiter-like content (dashes)\n      var hasPipe = false, hasDash = false\n      for (var si = 1; si < lastLine.length; si++) {\n        var sc = lastLine.charCodeAt(si)\n        if (sc === $.CHAR_PIPE) hasPipe = true\n        if (sc === $.CHAR_DASH) hasDash = true\n      }\n      if (hasPipe && hasDash) {\n        s = lastNL === -1 ? '' : s.slice(0, s.lastIndexOf(lastLine)).trimEnd()\n      }\n    }\n\n    // Strip incomplete HTML tags at end of input (unclosed block-level tags)\n    // Scan backwards for last '<', then parse tag name and find '>' in a single forward pass\n    var htmlTagPos = -1, htmlTagEnd = -1, htmlContentStart = -1\n    for (var hi = s.length - 1; hi >= 0; hi--) {\n      if (s.charCodeAt(hi) === $.CHAR_LT) {\n        // check next char is a letter (tag name start)\n        var hc = hi + 1 < s.length ? s.charCodeAt(hi + 1) : 0\n        if ((hc >= $.CHAR_A && hc <= $.CHAR_Z) || (hc >= $.CHAR_a && hc <= $.CHAR_z)) {\n          // find end of tag name\n          var hn = hi + 2\n          while (hn < s.length) {\n            var hnc = s.charCodeAt(hn)\n            if ((hnc >= $.CHAR_A && hnc <= $.CHAR_Z) || (hnc >= $.CHAR_a && hnc <= $.CHAR_z) || (hnc >= $.CHAR_DIGIT_0 && hnc <= $.CHAR_DIGIT_9)) hn++\n            else break\n          }\n          // find '>' after tag name\n          var hg = hn\n          while (hg < s.length && s.charCodeAt(hg) !== $.CHAR_GT) hg++\n          if (hg < s.length) {\n            // verify no '<' in content after '>'\n            var hasLt = false\n            for (var hk = hg + 1; hk < s.length; hk++) {\n              if (s.charCodeAt(hk) === $.CHAR_LT) { hasLt = true; break }\n            }\n            if (!hasLt) {\n              htmlTagPos = hi\n              htmlTagEnd = hn // end of tag name\n              htmlContentStart = hg + 1\n            }\n          }\n        }\n        break\n      }\n    }\n    if (htmlTagPos >= 0) {\n      // Check if the match is inside backtick code spans\n      var blockBtCount = 0\n      for (var bci = 0; bci < htmlTagPos; bci++) {\n        if (s.charCodeAt(bci) === $.CHAR_BACKTICK) blockBtCount++\n      }\n      if (blockBtCount % 2 === 0) {\n        var hTag = s.slice(htmlTagPos + 1, htmlTagEnd)\n        if (indexOfCI(s, '</' + hTag, 0) === -1) {\n          // Remove the unclosed tag but keep its content\n          s = s.slice(0, htmlTagPos) + s.slice(htmlContentStart)\n        }\n      }\n    }\n\n    // Strip incomplete list items at end of input\n    // A lone list marker (*, -, +, or digit./digit)) with no content or only whitespace\n    // should be suppressed since the content hasn't finished arriving\n    var sLen = s.length\n    if (sLen > 0) {\n      // Find last line\n      var lastNLPos = s.lastIndexOf('\\n')\n      var llStart = lastNLPos === -1 ? 0 : lastNLPos + 1\n      var llEnd = sLen\n      // Skip leading whitespace (up to 3 spaces for list indent)\n      var llp = llStart\n      var llSpaces = 0\n      while (llp < llEnd && s.charCodeAt(llp) === $.CHAR_SPACE && llSpaces < 3) { llp++; llSpaces++ }\n      if (llp < llEnd) {\n        var llc = s.charCodeAt(llp)\n        var isListMarker = false\n        // Unordered: *, -, +\n        if (llc === $.CHAR_ASTERISK || llc === $.CHAR_DASH || llc === $.CHAR_PLUS) {\n          // Check if followed by space/tab/end or nothing (empty item)\n          var afterM = llp + 1\n          if (afterM >= llEnd || s.charCodeAt(afterM) === $.CHAR_SPACE || s.charCodeAt(afterM) === $.CHAR_TAB) {\n            // Check if content after marker+space is empty/whitespace\n            var contentP = afterM\n            while (contentP < llEnd && (s.charCodeAt(contentP) === $.CHAR_SPACE || s.charCodeAt(contentP) === $.CHAR_TAB)) contentP++\n            if (contentP >= llEnd) isListMarker = true\n          }\n        }\n        // Ordered: digit(s) followed by . or )\n        else if (llc >= $.CHAR_DIGIT_0 && llc <= $.CHAR_DIGIT_9) {\n          var numP = llp\n          while (numP < llEnd && s.charCodeAt(numP) >= $.CHAR_DIGIT_0 && s.charCodeAt(numP) <= $.CHAR_DIGIT_9) numP++\n          if (numP < llEnd && (s.charCodeAt(numP) === $.CHAR_PERIOD || s.charCodeAt(numP) === $.CHAR_PAREN_CLOSE)) {\n            var afterOM = numP + 1\n            if (afterOM >= llEnd || s.charCodeAt(afterOM) === $.CHAR_SPACE || s.charCodeAt(afterOM) === $.CHAR_TAB) {\n              var oContentP = afterOM\n              while (oContentP < llEnd && (s.charCodeAt(oContentP) === $.CHAR_SPACE || s.charCodeAt(oContentP) === $.CHAR_TAB)) oContentP++\n              if (oContentP >= llEnd) isListMarker = true\n            }\n          }\n        }\n        if (isListMarker) {\n          s = s.slice(0, llStart).trimEnd()\n        }\n      }\n    }\n  }\n\n  // If inline mode, just parse as inline content directly\n  if (state.inline) {\n    return parseInline(s, 0, s.length, state, opts)\n  }\n\n  const nodes: MarkdownToJSX.ASTNode[] = []\n  let p = 0\n  const e = s.length\n\n  // Check for frontmatter at the start of the document (requires valid YAML)\n  if (p === 0 && s.startsWith('---')) {\n    const bounds = util.parseFrontmatterBounds(s)\n    if (bounds && bounds.hasValidYaml) {\n      // Output frontmatter by default, skip only if preserveFrontmatter === false\n      if (opts.preserveFrontmatter !== false) {\n        const frontmatterText = s.slice(0, bounds.endPos).trimEnd()\n        nodes.push({\n          type: RuleType.frontmatter,\n          text: frontmatterText,\n        } as MarkdownToJSX.FrontmatterNode)\n      }\n      // Skip past frontmatter\n      p = bounds.endPos\n    }\n  }\n\n  while (p < e) {\n    // Skip blank lines — inline lineEnd to avoid function call overhead on hot path\n    var _le = s.indexOf('\\n', p)\n    var le = _le < 0 ? e : _le\n    while (p < e) {\n      if (!isBlank(s, p, le)) break\n      p = le < e ? le + 1 : le\n      if (p < e) { _le = s.indexOf('\\n', p); le = _le < 0 ? e : _le }\n    }\n    if (p >= e) break\n\n    // Check for lazy continuation marker (\\u001E) — treat as paragraph text\n    if (s.charCodeAt(p) === $.CHAR_RECORD_SEP) {\n      // Strip marker and fall through to paragraph\n      // The paragraph scanner will handle \\u001E-prefixed continuation lines\n    }\n\n    indent(s, p, le)\n\n    let result: ScanResult = null\n\n    // Check for indented code block (4+ spaces) - skip when inside HTML blocks\n    if (s.charCodeAt(p) !== $.CHAR_RECORD_SEP && _indentSpaces >= 4 && !state.inHTML) {\n      result = scanIndented(s, p)\n    } else if (s.charCodeAt(p) !== $.CHAR_RECORD_SEP) {\n      const i = p + _indentChars\n      const c = s.charCodeAt(i)\n\n      // Try block scanners based on first character\n      if (c === $.CHAR_HASH) { // #\n        result = scanHeading(s, p, state, opts)\n      } else if (c === $.CHAR_GT) { // >\n        result = scanBlockquote(s, p, state, opts)\n      } else if (c === $.CHAR_BACKTICK || c === $.CHAR_TILDE) { // ` or ~\n        result = scanFenced(s, p, state)\n      } else if (c === $.CHAR_DASH || c === $.CHAR_ASTERISK || c === $.CHAR_UNDERSCORE) { // - * _\n        result = scanThematic(s, p)\n        if (!result) result = scanList(s, p, state, opts)\n      } else if (c === $.CHAR_PLUS || (c >= $.CHAR_DIGIT_0 && c <= $.CHAR_DIGIT_9)) { // + or digit\n        result = scanList(s, p, state, opts)\n      } else if (c === $.CHAR_LT) { // <\n        result = scanHTMLBlock(s, p, state, opts)\n      } else if (c === $.CHAR_PIPE) { // |\n        result = scanTable(s, p, state, opts)\n      } else if (c === $.CHAR_BRACKET_OPEN) { // [ - could be reference definition\n        result = scanRefDefinition(s, p, state)\n      }\n    }\n\n    // Try table if current line contains | (bounded scan to avoid O(n) per block)\n    if (!result) {\n      var hasPipeInLine = false\n      for (var pi = p; pi < le; pi++) {\n        if (s.charCodeAt(pi) === $.CHAR_PIPE) { hasPipeInLine = true; break }\n      }\n      if (hasPipeInLine) {\n        result = scanTable(s, p, state, opts)\n      }\n    }\n\n    // Fallback to paragraph\n    if (!result) {\n      result = scanParagraph(s, p, state, opts)\n    }\n\n    if (result) {\n      // Don't add refCollection nodes to output\n      if (result.node.type !== RuleType.refCollection) {\n        nodes.push(result.node)\n      }\n      p = result.end\n    } else {\n      // Skip line if nothing matched\n      var _skip = s.indexOf('\\n', p)\n      p = _skip < 0 ? e : _skip + 1\n    }\n  }\n\n  state._depth = savedDepth\n  return nodes\n}\n\n// ============================================================================\n// MAIN ENTRY POINT\n// ============================================================================\n\n/**\n * Main parser entry point - matches original parser interface\n */\nexport function parser(\n  source: string,\n  options?: MarkdownToJSX.Options\n): MarkdownToJSX.ASTNode[] {\n  // Reset global depth counter at the start of each parse\n  _globalInlineDepth = 0\n\n  // Strip BOM (U+FEFF) at document start per CommonMark spec\n  if (source.charCodeAt(0) === 0xfeff) {\n    source = source.slice(1)\n  }\n\n  // Normalize input: replace null bytes with U+FFFD per CommonMark spec\n  source = util.normalizeInput(source)\n\n  // Default state with refs object\n  const state: MarkdownToJSX.State = {\n    inline: false,\n    inAnchor: false,\n    inHTML: false,\n    inList: false,\n    inBlockQuote: false,\n    refs: {},\n  }\n\n  // Normalize options\n  const finalOptions = {\n    ...options,\n    slugify: options?.slugify\n      ? (input: string) => options.slugify!(input, util.slugify)\n      : util.slugify,\n    sanitizer: options?.sanitizer || util.sanitizer,\n    tagfilter: options?.tagfilter !== false,\n  }\n\n  // First pass: collect all reference definitions so they're available during inline parsing\n  collectReferenceDefinitions(source, state.refs!, finalOptions)\n\n  // Parse markdown\n  const nodes = parseBlocks(source, state, finalOptions)\n\n  // Add refCollection node at the start if there are refs\n  if (state.refs && Object.keys(state.refs).length > 0) {\n    return [\n      { type: RuleType.refCollection, refs: state.refs } as MarkdownToJSX.ReferenceCollectionNode,\n      ...nodes\n    ]\n  }\n\n  return nodes\n}\n\n// Export for testing\nexport { parseBlocks, parseInline }\nexport { scanHeading, scanThematic, scanBlockquote }\nexport function parseCodeFenced(s: string, p: number, state: MarkdownToJSX.State): { endPos: number; end: number; node: MarkdownToJSX.ASTNode; type: number; text: string; lang: string | undefined; attrs: Record<string, string> | undefined } | null {\n  var res = scanFenced(s, p, state)\n  if (!res) return null\n  var node = res.node as MarkdownToJSX.CodeBlockNode\n  return { ...res, endPos: res.end, end: res.end, node: res.node, type: RuleType.codeBlock, text: node.text, lang: node.lang, attrs: node.attrs as Record<string, string> | undefined }\n}\n\nexport function parseHTMLTag(s: string, p: number, _state?: MarkdownToJSX.State, _options?: unknown): {\n  tagName: string; tagLower: string; attrs: string; whitespaceBeforeAttrs: string;\n  isSelfClosing: boolean; hasSpaceBeforeSlash: boolean; isClosing: boolean; hasNewline: boolean; endPos: number\n} | null {\n  var res = __parseHTMLTag(s, p)\n  if (!res) return null\n  return {\n    tagName: res.tag,\n    tagLower: res.tag.toLowerCase(),\n    attrs: res.rawAttrs,\n    whitespaceBeforeAttrs: res.whitespaceBeforeAttrs,\n    isSelfClosing: res.selfClosing,\n    hasSpaceBeforeSlash: res.hasSpaceBeforeSlash,\n    isClosing: res.isClosing,\n    hasNewline: res.whitespaceBeforeAttrs.includes('\\n') || res.rawAttrs.includes('\\n'),\n    endPos: res.end\n  }\n}\n\nexport function calculateIndent(s: string, p: number, e: number, _state?: unknown): { indent: number; chars: number; spaceEquivalent: number; charCount: number } {\n  indent(s, p, e)\n  return { indent: _indentSpaces, chars: _indentChars, spaceEquivalent: _indentSpaces, charCount: _indentChars }\n}\nexport function parseDefinition(s: string, p: number, state: MarkdownToJSX.State, _opts: unknown, _isFootnote: boolean): { type: number; endPos: number; end: number } | null {\n  var end = parseRefDef(s, p, state.refs!)\n  if (end === null) return null\n  return { type: RuleType.ref, endPos: end, end: end }\n}\nexport function parseStyleAttribute(style: string): [string, string][] {\n  var result: [string, string][] = []\n  var decls = style.split(';')\n  for (var di = 0; di < decls.length; di++) {\n    var colonIdx = decls[di].indexOf(':')\n    if (colonIdx !== -1) {\n      var prop = decls[di].slice(0, colonIdx).trim()\n      var val = decls[di].slice(colonIdx + 1).trim()\n      if (prop && val) {\n        if ((val.startsWith('\"') && val.endsWith('\"')) || (val.startsWith(\"'\") && val.endsWith(\"'\"))) {\n          val = val.slice(1, -1)\n        }\n        result.push([prop, val])\n      }\n    }\n  }\n  return result\n}\n\n// Export parseMarkdown with refCollection node for react.tsx compatibility\nexport function parseMarkdown(\n  input: string,\n  state: MarkdownToJSX.State,\n  opts: ParseOptions\n): MarkdownToJSX.ASTNode[] {\n  // Reset global depth counter at the start of each parse\n  _globalInlineDepth = 0\n\n  // Normalize input (CRLF → LF, null bytes → U+FFFD)\n  input = util.normalizeInput(input)\n\n  // First pass: collect all reference definitions\n  if (!state.refs) state.refs = {}\n  collectReferenceDefinitions(input, state.refs, opts)\n\n  const nodes = parseBlocks(input, state, opts)\n\n  // Add refCollection node at the start if there are refs\n  if (state.refs && Object.keys(state.refs).length > 0) {\n    return [\n      { type: RuleType.refCollection, refs: state.refs } as MarkdownToJSX.ReferenceCollectionNode,\n      ...nodes\n    ]\n  }\n\n  return nodes\n}\n",
    "import * as $ from './constants'\nimport * as parse from './parse'\nimport { MarkdownToJSX, RuleType } from './types'\nimport * as util from './utils'\nvar hasKeys = util.hasKeys\n\n// Re-export parser, types, and utils for the /html entry point\nexport { parser } from './parse'\nexport { RuleType, type MarkdownToJSX } from './types'\nexport { sanitizer, slugify } from './utils'\n\n/**\n * Escape HTML entities for text content\n * Fast path: return early if no escaping needed\n */\nfunction escapeHtml(text: string): string {\n  if (!text) return text\n  // Use SIMD-accelerated indexOf to find earliest escapable char\n  var i = text.indexOf('&')\n  var lt = text.indexOf('<')\n  if (lt !== -1 && (i === -1 || lt < i)) i = lt\n  var gt = text.indexOf('>')\n  if (gt !== -1 && (i === -1 || gt < i)) i = gt\n  var qt = text.indexOf('\"')\n  if (qt !== -1 && (i === -1 || qt < i)) i = qt\n  if (i === -1) return text\n  // Build result from first escapable char with charCode replacement loop\n  var result = text.slice(0, i)\n  var last = i\n  var len = text.length\n  while (i < len) {\n    var code = text.charCodeAt(i)\n    if (code <= 62) {\n      if (code === $.CHAR_AMPERSAND) {\n        if (i > last) result += text.slice(last, i)\n        result += '&amp;'\n        last = i + 1\n      } else if (code === $.CHAR_LT) {\n        if (i > last) result += text.slice(last, i)\n        result += '&lt;'\n        last = i + 1\n      } else if (code === $.CHAR_GT) {\n        if (i > last) result += text.slice(last, i)\n        result += '&gt;'\n        last = i + 1\n      } else if (code === $.CHAR_DOUBLE_QUOTE) {\n        if (i > last) result += text.slice(last, i)\n        result += '&quot;'\n        last = i + 1\n      }\n    }\n    i++\n  }\n  if (last < len) result += text.slice(last)\n  return result\n}\n\n/**\n * Escape HTML for attribute values, preserving entity references\n * Only escapes bare & that are not part of valid entities\n */\nfunction escapeHtmlAttr(value: string): string {\n  // Fast-path: check if escaping is needed before regex\n  var needsEscape = false\n  var i = 0\n  var len = value.length\n  while (i < len) {\n    var code = value.charCodeAt(i)\n    if (\n      code === $.CHAR_AMPERSAND ||\n      code === $.CHAR_LT ||\n      code === $.CHAR_GT ||\n      code === $.CHAR_DOUBLE_QUOTE\n    ) {\n      needsEscape = true\n      break\n    }\n    i++\n  }\n  if (!needsEscape) return value\n\n  return value\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/&(?!([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+);)/g, '&amp;')\n}\n\nfunction formatAttributes(attrs: Record<string, any>): string {\n  var result = ''\n  for (var key in attrs) {\n    var value = attrs[key]\n    if (value === undefined || value === null) continue\n    result += ' '\n    if (value === true) {\n      result += key\n    } else if (value === '') {\n      result += key + '=\"\"'\n    } else if (key === 'style' && typeof value === 'object' && value !== null) {\n      var styleStr = ''\n      var styleFirst = true\n      for (var styleKey in value) {\n        var styleValue = value[styleKey]\n        if (styleValue != null) {\n          if (styleFirst) styleFirst = false\n          else styleStr += '; '\n          var cssKey = ''\n          for (var i = 0; i < styleKey.length; i++) {\n            var code = styleKey.charCodeAt(i)\n            if (code >= $.CHAR_A && code <= $.CHAR_Z) {\n              cssKey += '-' + String.fromCharCode(code + $.CHAR_CASE_OFFSET)\n            } else {\n              cssKey += styleKey[i]\n            }\n          }\n          styleStr += cssKey + ': ' + styleValue\n        }\n      }\n      if (styleStr) result += 'style=\"' + escapeHtmlAttr(styleStr) + '\"'\n    } else if (typeof value === 'string') {\n      result += key + '=\"' + escapeHtmlAttr(value) + '\"'\n    } else if (typeof value === 'number') {\n      result += key + '=\"' + value + '\"'\n    }\n  }\n  return result\n}\n\n/**\n * Override configuration for HTML tags or custom components in HTML output\n * @lang zh HTML 输出中 HTML 标签或自定义组件的覆盖配置\n * @lang hi HTML आउटपुट में HTML टैग्स या कस्टम कंपोनेंट्स के लिए ओवरराइड कॉन्फ़िगरेशन\n */\nexport type HTMLOverride =\n  | {\n      component?: string\n      props?: Record<string, string | number | boolean>\n    }\n  | string\n\n/**\n * Map of HTML tags and custom components to their override configurations\n * @lang zh HTML 标签和自定义组件到其覆盖配置的映射\n * @lang hi HTML टैग्स और कस्टम कंपोनेंट्स से उनकी ओवरराइड कॉन्फ़िगरेशन का मैप\n */\nexport type HTMLOverrides = {\n  [tag in MarkdownToJSX.HTMLTags]?: HTMLOverride\n} & {\n  [customComponent: string]: HTMLOverride\n}\n\n/**\n * HTML compiler options\n * @lang zh HTML 编译器选项\n * @lang hi HTML कंपाइलर विकल्प\n */\nexport type HTMLOptions = Omit<\n  MarkdownToJSX.Options,\n  'createElement' | 'wrapperProps' | 'overrides'\n> & {\n  /** Reference definitions for link resolution */\n  /** @lang zh 用于链接解析的引用定义 */\n  /** @lang hi लिंक रिज़ॉल्यूशन के लिए संदर्भ परिभाषाएं */\n  refs?: { [key: string]: { target: string; title: string | undefined } }\n  /** Custom rendering function for AST rules */\n  /** @lang zh AST 规则的自定义渲染函数 */\n  /** @lang hi AST नियमों के लिए कस्टम रेंडरिंग फ़ंक्शन */\n  renderRule?: (\n    next: () => string,\n    node: MarkdownToJSX.ASTNode,\n    renderChildren: (children: MarkdownToJSX.ASTNode[]) => string,\n    state: MarkdownToJSX.State\n  ) => string\n  /** Override configurations for HTML tags */\n  /** @lang zh HTML 标签的覆盖配置 */\n  /** @lang hi HTML टैग्स के लिए ओवरराइड कॉन्फ़िगरेशन */\n  overrides?: HTMLOverrides\n  /** Props for wrapper element */\n  /** @lang zh 包装元素的属性 */\n  /** @lang hi रैपर एलिमेंट के लिए props */\n  wrapperProps?: Record<string, string | number | boolean>\n  /** Internal flag for wrapper auto-detection */\n  /** @lang zh 包装器自动检测的内部标志 */\n  /** @lang hi रैपर ऑटो-डिटेक्शन के लिए आंतरिक फ़्लैग */\n  wrapperWasAutoSet?: boolean\n}\n\n// Render context — created once per astToHTML call, shared across all recursive renders\ninterface _Ctx {\n  sanitize: (url: string, tag: string, attr: string) => string | null\n  slug: (input: string, defaultFn: typeof util.slugify) => string\n  refs: { [key: string]: { target: string; title: string | undefined } }\n  overrides: HTMLOverrides\n  hasOverrides: boolean\n  preserveFrontmatter: boolean\n  tagfilter: boolean\n  forceInline: boolean\n  renderRule?: HTMLOptions['renderRule']\n}\n\nvar _emptyObj: Record<string, any> = {}\n\nfunction shouldSkipNode(\n  node: MarkdownToJSX.ASTNode,\n  preserveFrontmatter: boolean\n): boolean {\n  return (\n    node.type === RuleType.footnote ||\n    node.type === RuleType.ref ||\n    (node.type === RuleType.frontmatter && !preserveFrontmatter)\n  )\n}\n\nfunction _mergeAttrs(\n  base: Record<string, any> | undefined,\n  overrideProps: Record<string, any>\n): Record<string, any> {\n  if (!hasKeys(overrideProps)) return base || _emptyObj\n  var merged = base ? { ...base } : {}\n  for (var key in overrideProps) merged[key] = overrideProps[key]\n  return merged\n}\n\nfunction _renderTag(\n  defaultTag: string,\n  children: string,\n  ctx: _Ctx,\n  attrs?: Record<string, any>\n): string {\n  if (!ctx.hasOverrides) {\n    if (!attrs || !hasKeys(attrs)) {\n      return '<' + defaultTag + '>' + children + '</' + defaultTag + '>'\n    }\n    return '<' + defaultTag + formatAttributes(attrs) + '>' + children + '</' + defaultTag + '>'\n  }\n  var tag = util.getTag(defaultTag, ctx.overrides)\n  var overrideProps = util.getOverrideProps(defaultTag, ctx.overrides)\n  if (!attrs || !hasKeys(attrs)) {\n    return '<' + tag + formatAttributes(overrideProps) + '>' + children + '</' + tag + '>'\n  }\n  var finalAttrs = { ...overrideProps }\n  for (var aKey in attrs) finalAttrs[aKey] = attrs[aKey]\n  return '<' + tag + formatAttributes(finalAttrs) + '>' + children + '</' + tag + '>'\n}\n\nfunction _renderChildren(nodes: MarkdownToJSX.ASTNode[], ctx: _Ctx): string {\n  var result = ''\n  if (ctx.renderRule) {\n    for (var i = 0; i < nodes.length; i++) {\n      result += _renderNodeEntry(nodes[i], { key: i }, ctx)\n    }\n  } else {\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i]\n      if (node.type === RuleType.text) {\n        if (node.text) result += escapeHtml(node.text)\n      } else {\n        result += _renderNode(node, ctx)\n      }\n    }\n  }\n  return result\n}\n\nfunction _renderNodeEntry(\n  node: MarkdownToJSX.ASTNode,\n  state: MarkdownToJSX.State,\n  ctx: _Ctx\n): string {\n  if (!node || typeof node !== 'object') return ''\n\n  if (ctx.renderRule) {\n    return ctx.renderRule(\n      function () {\n        if (\n          node.type === RuleType.ref ||\n          node.type === RuleType.refCollection ||\n          shouldSkipNode(node, ctx.preserveFrontmatter)\n        )\n          return ''\n        return _renderNode(node, ctx)\n      },\n      node,\n      function (children: MarkdownToJSX.ASTNode[]) {\n        return _renderChildren(children, ctx)\n      },\n      state\n    )\n  }\n\n  if (\n    node.type === RuleType.ref ||\n    node.type === RuleType.refCollection ||\n    shouldSkipNode(node, ctx.preserveFrontmatter)\n  )\n    return ''\n\n  return _renderNode(node, ctx)\n}\n\nfunction _renderNode(\n  node: MarkdownToJSX.ASTNode,\n  ctx: _Ctx\n): string {\n  switch (node.type) {\n    case RuleType.blockQuote: {\n      var children = node.children\n        ? _renderChildren(node.children, ctx)\n        : ''\n      if (node.alert) {\n        children = '<header>' + escapeHtml(node.alert) + '</header>' + children\n        return _renderTag('blockquote', children, ctx, {\n          class:\n            'markdown-alert-' + ctx.slug(node.alert.toLowerCase(), util.slugify),\n        })\n      }\n      return _renderTag('blockquote', children, ctx)\n    }\n\n    case RuleType.breakLine: {\n      return '<br />\\n'\n    }\n    case RuleType.breakThematic: {\n      return '<hr />'\n    }\n\n    case RuleType.frontmatter: {\n      return '<pre>' + escapeHtml(node.text) + '</pre>'\n    }\n\n    case RuleType.codeBlock: {\n      var codeAttrs: Record<string, any> = node.attrs || {}\n      if (node.lang) {\n        codeAttrs = { ...codeAttrs }\n        var decodedLang = util.decodeEntityReferences(node.lang)\n        var existingClass =\n          (codeAttrs.class as string) || (codeAttrs.className as string) || ''\n        codeAttrs.class = existingClass\n          ? existingClass + ' language-' + decodedLang\n          : 'language-' + decodedLang\n        delete codeAttrs.className\n      }\n      var codeAttrStr = formatAttributes(codeAttrs)\n      var codeText = node.text || ''\n      return '<pre><code' + codeAttrStr + '>' + escapeHtml(codeText) + '</code></pre>'\n    }\n\n    case RuleType.codeInline: {\n      return '<code>' + escapeHtml(node.text || '') + '</code>'\n    }\n\n    case RuleType.footnoteReference: {\n      var href = ctx.sanitize(node.target || '', 'a', 'href') || ''\n      var text = escapeHtml(node.text || '')\n      return '<a href=\"' + escapeHtml(href) + '\"><sup>' + text + '</sup></a>'\n    }\n\n    case RuleType.gfmTask: {\n      return (\n        '<input' +\n        (node.completed ? ' checked=\"\"' : '') +\n        ' disabled=\"\" type=\"checkbox\">'\n      )\n    }\n\n    case RuleType.heading: {\n      var level = node.level || 1\n      var headingAttrs = node.id?.trim() ? { id: node.id } : undefined\n      return _renderTag(\n        'h' + level,\n        node.children ? _renderChildren(node.children, ctx) : '',\n        ctx,\n        headingAttrs\n      )\n    }\n\n    case RuleType.htmlComment: {\n      var htmlCommentNode = node as MarkdownToJSX.HTMLCommentNode & {\n        raw?: boolean\n        endsWithGreaterThan?: boolean\n      }\n      if (htmlCommentNode.raw) {\n        return htmlCommentNode.text\n      }\n      if (htmlCommentNode.endsWithGreaterThan) {\n        return '<!--' + node.text + '>'\n      }\n      return '<!--' + node.text + '-->'\n    }\n\n    case RuleType.htmlBlock: {\n      var htmlNode = node as MarkdownToJSX.HTMLNode & {\n        _rawAttrs?: string\n        _isClosingTag?: boolean\n      }\n      var defaultTag = htmlNode.tag || 'div'\n      var tag = ctx.hasOverrides ? util.getTag(defaultTag, ctx.overrides) : defaultTag\n      var overrideProps = ctx.hasOverrides ? util.getOverrideProps(defaultTag, ctx.overrides) : _emptyObj\n      var attrsStr: string\n      if (htmlNode._rawAttrs !== undefined) {\n        var rawAttrsValue = htmlNode._rawAttrs\n        var needsLeadingSpace = rawAttrsValue.length > 0 &&\n          rawAttrsValue.charCodeAt(0) > $.CHAR_SPACE\n        attrsStr =\n          (needsLeadingSpace ? ' ' : '') +\n          rawAttrsValue +\n          (hasKeys(overrideProps)\n            ? ' ' + formatAttributes(overrideProps).trim()\n            : '')\n      } else {\n        attrsStr = formatAttributes(_mergeAttrs(htmlNode.attrs, overrideProps))\n      }\n      if (ctx.tagfilter && util.shouldFilterTag(tag)) {\n        return htmlNode._isClosingTag\n          ? '&lt;/' + tag + '>'\n          : '&lt;' + tag + attrsStr + '>'\n      }\n      if (htmlNode._rawText) {\n        if (htmlNode._verbatim) {\n          var textContent = ctx.tagfilter\n            ? util.applyTagFilterToText(htmlNode._rawText)\n            : htmlNode._rawText\n          if (htmlNode._isClosingTag) return '</' + tag + '>' + textContent\n          var tagLower = tag.toLowerCase()\n          var isType1Block = parse.isType1Block(tagLower)\n          if (isType1Block) {\n            var textLen = htmlNode._rawText.length\n            var textStart = 0\n            while (\n              textStart < textLen &&\n              htmlNode._rawText.charCodeAt(textStart) === $.CHAR_SPACE\n            )\n              textStart++\n            if (\n              textStart < textLen &&\n              htmlNode._rawText.charCodeAt(textStart) === $.CHAR_LT\n            ) {\n              var openingTagEnd = htmlNode._rawText.indexOf('>', textStart)\n              if (openingTagEnd !== -1) {\n                var rawOpeningTag = htmlNode._rawText.slice(\n                  textStart,\n                  openingTagEnd + 1\n                )\n                if (\n                  rawOpeningTag.charCodeAt(1) >= $.CHAR_a &&\n                  rawOpeningTag.charCodeAt(1) <= $.CHAR_z\n                ) {\n                  var tagStart = 1\n                  var tagEnd = tagStart\n                  while (\n                    tagEnd < rawOpeningTag.length &&\n                    rawOpeningTag.charCodeAt(tagEnd) >= $.CHAR_a &&\n                    rawOpeningTag.charCodeAt(tagEnd) <= $.CHAR_z\n                  )\n                    tagEnd++\n                  var foundTag = rawOpeningTag\n                    .slice(tagStart, tagEnd)\n                    .toLowerCase()\n                  if (foundTag === tagLower) {\n                    var innerText = htmlNode._rawText.slice(openingTagEnd + 1)\n                    return (\n                      rawOpeningTag +\n                      (ctx.tagfilter\n                        ? util.applyTagFilterToText(innerText)\n                        : innerText)\n                    )\n                  }\n                }\n              }\n            }\n            var closingTag = '</' + tagLower + '>'\n            var hasClosingTag = htmlNode._rawText.indexOf(closingTag) !== -1\n            return hasClosingTag\n              ? '<' + tag + attrsStr + '>' + textContent\n              : '<' + tag + attrsStr + '>' + textContent + '</' + tag + '>'\n          }\n          var trimmed = htmlNode._rawText.trim()\n          if (trimmed.length > 0 && trimmed.charCodeAt(0) === $.CHAR_LT) {\n            var secondCharCode = trimmed.charCodeAt(1)\n            if (\n              (secondCharCode >= $.CHAR_a && secondCharCode <= $.CHAR_z) ||\n              (secondCharCode >= $.CHAR_A && secondCharCode <= $.CHAR_Z)\n            ) {\n              var tagStart = 1\n              var tagEnd = tagStart\n              while (tagEnd < trimmed.length) {\n                var code = trimmed.charCodeAt(tagEnd)\n                if (\n                  (code >= $.CHAR_a && code <= $.CHAR_z) ||\n                  (code >= $.CHAR_A && code <= $.CHAR_Z) ||\n                  (code >= $.CHAR_DIGIT_0 && code <= $.CHAR_DIGIT_9) ||\n                  code === $.CHAR_DASH\n                ) {\n                  tagEnd++\n                } else {\n                  break\n                }\n              }\n              var foundTag = trimmed.slice(tagStart, tagEnd).toLowerCase()\n              if (foundTag === tagLower) {\n                return textContent\n              }\n            }\n          }\n          var trimmedStart = 0\n          while (\n            trimmedStart < textContent.length &&\n            textContent.charCodeAt(trimmedStart) === $.CHAR_SPACE\n          )\n            trimmedStart++\n          return '<' + tag + attrsStr + '>' + (trimmedStart > 0 ? textContent.slice(trimmedStart) : trimmed ? textContent : '')\n        }\n        var textContent = ctx.tagfilter\n          ? util.applyTagFilterToText(htmlNode._rawText)\n          : htmlNode._rawText\n        return '<' + tag + attrsStr + '>' + textContent + '</' + tag + '>'\n      }\n      // For multi-line attributes (rawAttrs contains newlines), preserve rawText formatting\n      if (htmlNode._rawAttrs && htmlNode._rawAttrs.indexOf('\\n') !== -1 && htmlNode._rawText) {\n        var rawTextContent = ctx.tagfilter\n          ? util.applyTagFilterToText(htmlNode._rawText)\n          : htmlNode._rawText\n        return '<' + tag + attrsStr + '>' + rawTextContent + '</' + tag + '>'\n      }\n      if (util.isVoidElement(tag)) {\n        return '<' + tag + attrsStr + '>'\n      }\n      var children = htmlNode.children\n        ? _renderChildren(htmlNode.children, ctx)\n        : ''\n      if (htmlNode._isClosingTag) return '</' + tag + '>' + children\n      // Check if children has non-whitespace content without allocating a trimmed string\n      var hasContent = false\n      for (var hci = 0; hci < children.length; hci++) {\n        var hcc = children.charCodeAt(hci)\n        if (hcc !== $.CHAR_SPACE && hcc !== $.CHAR_TAB && hcc !== $.CHAR_NEWLINE && hcc !== 13) {\n          hasContent = true\n          break\n        }\n      }\n      return hasContent\n        ? '<' + tag + attrsStr + '>' + children + '</' + tag + '>'\n        : '<' + tag + attrsStr + '>' + children\n    }\n\n    case RuleType.htmlSelfClosing: {\n      var scNode = node as MarkdownToJSX.HTMLSelfClosingNode & {\n        _rawText?: string\n        _isClosingTag?: boolean\n      }\n      var scDefaultTag = scNode.tag || 'div'\n      var scTag = ctx.hasOverrides ? util.getTag(scDefaultTag, ctx.overrides) : scDefaultTag\n      if (scNode._rawText) {\n        return ctx.tagfilter && util.shouldFilterTag(scTag)\n          ? scNode._rawText.replace(/^</, '&lt;')\n          : scNode._rawText\n      }\n      if (scNode._isClosingTag) return '</' + scTag + '>'\n      var scOverrideProps = ctx.hasOverrides ? util.getOverrideProps(scDefaultTag, ctx.overrides) : _emptyObj\n      var scMergedAttrs = _mergeAttrs(scNode.attrs, scOverrideProps)\n      var scAttrsStr = formatAttributes(scMergedAttrs)\n      if (ctx.tagfilter && util.shouldFilterTag(scTag)) {\n        return '&lt;' + scTag + scAttrsStr + ' />'\n      }\n      return '<' + scTag + scAttrsStr + ' />'\n    }\n\n    case RuleType.image: {\n      var imgTag = ctx.hasOverrides ? util.getTag('img', ctx.overrides) : 'img'\n      var imgOverrideProps = ctx.hasOverrides ? util.getOverrideProps('img', ctx.overrides) : _emptyObj\n      var src = ctx.sanitize(node.target || '', 'img', 'src') || ''\n      var imgAttrs: Record<string, any> = {\n        ...imgOverrideProps,\n        alt: node.alt || '',\n      }\n      if (node.title) imgAttrs.title = node.title\n      return '<' + imgTag + ' src=\"' + escapeHtml(src) + '\"' + formatAttributes(imgAttrs) + ' />'\n    }\n\n    case RuleType.link: {\n      var linkTag = ctx.hasOverrides ? util.getTag('a', ctx.overrides) : 'a'\n      var linkOverrideProps = ctx.hasOverrides ? util.getOverrideProps('a', ctx.overrides) : _emptyObj\n      var linkAttrs: Record<string, any> = hasKeys(linkOverrideProps) ? { ...linkOverrideProps } : {}\n      if (node.target != null) {\n        var encodedTarget = util.encodeUrlTarget(util.decodeEntityReferences(node.target))\n        var sanitized = ctx.sanitize(encodedTarget, 'a', 'href')\n        if (sanitized !== null) {\n          linkAttrs.href = sanitized === encodedTarget\n            ? sanitized\n            : util.encodeUrlTarget(sanitized)\n        }\n      }\n      if (node.title) linkAttrs.title = util.decodeEntityReferences(node.title)\n      return '<' + linkTag + formatAttributes(linkAttrs) + '>' + (node.children ? _renderChildren(node.children, ctx) : '') + '</' + linkTag + '>'\n    }\n\n    case RuleType.table: {\n      var tableNode = node as MarkdownToJSX.TableNode\n      var alignments = tableNode.align || []\n      var header = ''\n      var headerCells = tableNode.header || []\n      for (var hi = 0; hi < headerCells.length; hi++) {\n        var align = alignments[hi]\n        header +=\n          '<th' +\n          (align ? ' align=\"' + align + '\"' : '') +\n          '>' +\n          _renderChildren(headerCells[hi], ctx) +\n          '</th>'\n      }\n      var rows = ''\n      var tableRows = tableNode.cells || []\n      for (var ri = 0; ri < tableRows.length; ri++) {\n        var row = tableRows[ri] || []\n        rows += '<tr>'\n        for (var ci = 0; ci < row.length; ci++) {\n          var align = alignments[ci]\n          rows +=\n            '<td' +\n            (align ? ' align=\"' + align + '\"' : '') +\n            '>' +\n            _renderChildren(row[ci], ctx) +\n            '</td>'\n        }\n        rows += '</tr>'\n      }\n      if (ctx.hasOverrides) {\n        var tblTag = util.getTag('table', ctx.overrides)\n        var tblAttrStr = formatAttributes(util.getOverrideProps('table', ctx.overrides))\n        return '<' + tblTag + tblAttrStr + '><thead><tr>' + header + '</tr></thead>' + (rows ? '<tbody>' + rows + '</tbody>' : '') + '</' + tblTag + '>'\n      }\n      return '<table><thead><tr>' + header + '</tr></thead>' + (rows ? '<tbody>' + rows + '</tbody>' : '') + '</table>'\n    }\n\n    case RuleType.text:\n      return escapeHtml(node.text || '')\n\n    case RuleType.textFormatted: {\n      return _renderTag(\n        node.tag || 'strong',\n        node.children ? _renderChildren(node.children, ctx) : '',\n        ctx\n      )\n    }\n\n    case RuleType.orderedList:\n    case RuleType.unorderedList: {\n      var items = ''\n      var listItems = node.items || []\n      for (var li = 0; li < listItems.length; li++) {\n        items += '<li>' + _renderChildren(listItems[li], ctx) + '</li>'\n      }\n      var listTag = node.type === RuleType.orderedList ? 'ol' : 'ul'\n      var listAttrs =\n        node.type === RuleType.orderedList &&\n        node.start != null &&\n        node.start !== 1\n          ? { start: node.start }\n          : undefined\n      return _renderTag(listTag, items, ctx, listAttrs)\n    }\n\n    case RuleType.paragraph: {\n      if (ctx.forceInline) {\n        return node.children ? _renderChildren(node.children, ctx) : ''\n      }\n      var children = node.children\n        ? _renderChildren(node.children, ctx)\n        : ''\n      // Per CommonMark: collapse trailing spaces before newlines (soft line breaks)\n      // Use indexOf to jump between occurrences (SIMD) instead of scanning every char\n      // Track tag boundaries to avoid collapsing inside HTML attribute values\n      var result = ''\n      var segStart = 0\n      var searchFrom = 0\n      var inTag = false\n      var quoteCount = 0\n      var idx = 0\n      while ((idx = children.indexOf(' \\n', searchFrom)) !== -1) {\n        // Update tag tracking only in the gap since last search\n        for (var j = searchFrom; j < idx; j++) {\n          var code = children.charCodeAt(j)\n          if (code === $.CHAR_LT) { inTag = true; quoteCount = 0 }\n          else if (code === $.CHAR_GT) { inTag = false; quoteCount = 0 }\n          else if (inTag && code === $.CHAR_DOUBLE_QUOTE) { quoteCount++ }\n        }\n        if (inTag && quoteCount % 2 === 1) {\n          // Inside quoted attribute — preserve\n          searchFrom = idx + 2\n        } else {\n          result += children.slice(segStart, idx) + '\\n'\n          segStart = idx + 2\n          searchFrom = segStart\n        }\n      }\n      if (segStart > 0) {\n        if (segStart < children.length) result += children.slice(segStart)\n        children = result\n      }\n\n      if (!ctx.hasOverrides) {\n        return '<p>' + children + '</p>'\n      }\n      var attrsStr = formatAttributes(util.getOverrideProps('p', ctx.overrides))\n      var tag = util.getTag('p', ctx.overrides)\n      return '<' + tag + attrsStr + '>' + children + '</' + tag + '>'\n    }\n\n    default:\n      return ''\n  }\n}\n\n/**\n * Convert AST nodes to HTML string\n * @lang zh 将 AST 节点转换为 HTML 字符串\n * @lang hi AST नोड्स को HTML स्ट्रिंग में बदलें\n *\n * @param nodes - Array of AST nodes to render\n * @lang zh @param nodes - 要渲染的 AST 节点数组\n * @lang hi @param nodes - रेंडर करने के लिए AST नोड्स की सरणी\n * @param options - HTML compiler options\n * @lang zh @param options - HTML 编译器选项\n * @lang hi @param options - HTML कंपाइलर विकल्प\n * @returns HTML string\n * @lang zh @returns HTML 字符串\n * @lang hi @returns HTML स्ट्रिंग\n */\nexport function astToHTML(\n  nodes: MarkdownToJSX.ASTNode[],\n  options: HTMLOptions = {}\n): string {\n  var sanitize = options.sanitizer || util.sanitizer\n  var slug = options.slugify || util.slugify\n  var refs = options.refs || {}\n  var overrides = options.overrides || {}\n\n  // Extract refs from reference collection node and filter non-renderable nodes\n  var refsFromAST: {\n    [key: string]: { target: string; title: string | undefined }\n  } = {}\n  var nonRefCollectionNodes: MarkdownToJSX.ASTNode[] = []\n  var foundRefCollection = false\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i]\n    if (node.type === RuleType.refCollection && !foundRefCollection) {\n      refsFromAST = (node as MarkdownToJSX.ReferenceCollectionNode).refs || {}\n      foundRefCollection = true\n      continue\n    }\n    if (shouldSkipNode(node, !!options.preserveFrontmatter)) continue\n    nonRefCollectionNodes.push(node)\n  }\n  for (var key in refsFromAST) refs[key] = refsFromAST[key]\n\n  // Create render context once — shared across all recursive renders\n  var ctx: _Ctx = {\n    sanitize: sanitize,\n    slug: slug,\n    refs: refs,\n    overrides: overrides,\n    hasOverrides: hasKeys(overrides),\n    preserveFrontmatter: !!options.preserveFrontmatter,\n    tagfilter: !!options.tagfilter,\n    forceInline: !!options.forceInline,\n    renderRule: options.renderRule,\n  }\n\n  var content = ''\n  if (Array.isArray(nodes)) {\n    if (ctx.renderRule) {\n      for (var ci = 0; ci < nonRefCollectionNodes.length; ci++) {\n        content += _renderNodeEntry(nonRefCollectionNodes[ci], {\n          key: ci,\n          refs: refs,\n        }, ctx)\n      }\n    } else {\n      for (var ci = 0; ci < nonRefCollectionNodes.length; ci++) {\n        content += _renderNode(nonRefCollectionNodes[ci], ctx)\n      }\n    }\n  } else {\n    content = _renderNodeEntry(nodes, { refs: refs }, ctx)\n  }\n\n  // Extract and render footnotes\n  var footnoteFooter = ''\n  for (var key in refs) {\n    if (key.charCodeAt(0) === $.CHAR_CARET) {\n      if (!footnoteFooter) footnoteFooter = '<footer>'\n      var id = key.slice(1)\n      var parsed = parse.parseMarkdown(\n        refs[key].target,\n        { inline: true, refs },\n        {\n          overrides: overrides as MarkdownToJSX.Overrides,\n          sanitizer: sanitize,\n          slugify: function (i: string) { return slug(i, util.slugify) },\n          tagfilter: options.tagfilter !== false,\n        }\n      )\n      var filtered: MarkdownToJSX.ASTNode[] = []\n      for (var pi = 0; pi < parsed.length; pi++) {\n        if (parsed[pi].type !== RuleType.refCollection)\n          filtered.push(parsed[pi])\n      }\n      var footnoteCtx: _Ctx = {\n        sanitize: sanitize,\n        slug: slug,\n        refs: {},\n        overrides: overrides,\n        hasOverrides: ctx.hasOverrides,\n        preserveFrontmatter: ctx.preserveFrontmatter,\n        tagfilter: ctx.tagfilter,\n        forceInline: true,\n        renderRule: ctx.renderRule,\n      }\n      var footnoteContent = _renderChildren(filtered, footnoteCtx)\n      footnoteFooter += '<div id=\"' + escapeHtmlAttr(slug(id, util.slugify)) + '\">' + escapeHtml(id) + ': ' + footnoteContent + '</div>'\n    }\n  }\n  if (footnoteFooter) footnoteFooter += '</footer>'\n\n  // Handle wrapper options\n  if (options.wrapper === null) {\n    return content + footnoteFooter\n  }\n\n  // Determine if content should be wrapped (only when explicitly requested)\n  var hasMultipleChildren = nonRefCollectionNodes.length > 1\n  var hasExplicitWrapper = options.wrapper != null\n  var wrapperWasExplicit =\n    hasExplicitWrapper && typeof options.wrapper === 'string'\n  var shouldWrap =\n    options.forceWrapper ||\n    (options.forceInline && hasExplicitWrapper) ||\n    (hasMultipleChildren && hasExplicitWrapper)\n\n  if (!shouldWrap) {\n    return content + footnoteFooter\n  }\n\n  // Extract paragraph content when forceInline or forceWrapper with explicit wrapper\n  var contentToWrap = content\n  if (\n    options.forceInline ||\n    (options.forceWrapper && wrapperWasExplicit && !options.wrapperWasAutoSet)\n  ) {\n    if (\n      !hasMultipleChildren &&\n      nonRefCollectionNodes.length === 1 &&\n      nonRefCollectionNodes[0].type === RuleType.paragraph\n    ) {\n      var paragraphNode =\n        nonRefCollectionNodes[0] as MarkdownToJSX.ParagraphNode\n      if (paragraphNode.children) {\n        var inlineCtx: _Ctx = {\n          sanitize: sanitize,\n          slug: slug,\n          refs: {},\n          overrides: overrides,\n          hasOverrides: ctx.hasOverrides,\n          preserveFrontmatter: ctx.preserveFrontmatter,\n          tagfilter: ctx.tagfilter,\n          forceInline: true,\n          renderRule: ctx.renderRule,\n        }\n        contentToWrap = _renderChildren(paragraphNode.children, inlineCtx)\n      }\n    }\n  }\n\n  // Determine wrapper tag\n  var wrapperTag =\n    typeof options.wrapper === 'string'\n      ? options.wrapper\n      : options.forceInline\n        ? 'span'\n        : 'div'\n\n  var wrapperAttrs = ''\n  if (options.wrapperProps) {\n    var sanitizedProps: Record<string, string> = {}\n    for (var wpKey in options.wrapperProps) {\n      var wpValue = options.wrapperProps[wpKey]\n      if (wpValue != null) {\n        var sanitized = sanitize(String(wpValue), wrapperTag, wpKey)\n        if (sanitized !== null) sanitizedProps[wpKey] = sanitized\n      }\n    }\n    wrapperAttrs = formatAttributes(sanitizedProps)\n  }\n\n  return '<' + wrapperTag + wrapperAttrs + '>' + contentToWrap + footnoteFooter + '</' + wrapperTag + '>'\n}\n\n/**\n * Compiler function that parses markdown and renders to HTML string\n * Convenience function that combines parser() and html()\n * @lang zh 解析 Markdown 并渲染为 HTML 字符串的编译器函数\n * 结合 parser() 和 html() 的便捷函数\n * @lang hi Markdown को पार्स करने और HTML स्ट्रिंग में रेंडर करने वाला कंपाइलर फ़ंक्शन\n * parser() और html() को जोड़ने वाला सुविधाजनक फ़ंक्शन\n *\n * @param markdown - Markdown string to compile\n * @lang zh @param markdown - 要编译的 Markdown 字符串\n * @lang hi @param markdown - कंपाइल करने के लिए Markdown स्ट्रिंग\n * @param options - HTML compiler options\n * @lang zh @param options - HTML 编译器选项\n * @lang hi @param options - HTML कंपाइलर विकल्प\n * @returns HTML string\n * @lang zh @returns HTML 字符串\n * @lang hi @returns HTML स्ट्रिंग\n */\nexport function compiler(markdown: string, options?: HTMLOptions): string {\n  var inline = options?.forceInline || false\n  var parseOptions: parse.ParseOptions = {\n    ...options,\n    overrides: options?.overrides as MarkdownToJSX.Overrides,\n    sanitizer: options?.sanitizer,\n    slugify: options?.slugify\n      ? function (i: string) { return options.slugify!(i, util.slugify) }\n      : util.slugify,\n    tagfilter: options?.tagfilter !== false,\n  }\n  var ast = parse.parser(markdown, { ...parseOptions, forceInline: inline })\n  var htmlOptions: HTMLOptions = {\n    ...options,\n    forceInline: inline,\n  } as HTMLOptions\n  var wrapperWasAutoSet = false\n  if (options?.wrapper === undefined) {\n    var nonRefCount = 0\n    for (var ni = 0; ni < ast.length; ni++) {\n      var n = ast[ni]\n      if (\n        n.type !== RuleType.refCollection &&\n        n.type !== RuleType.footnote &&\n        n.type !== RuleType.ref &&\n        (n.type !== RuleType.frontmatter || !options?.preserveFrontmatter)\n      ) {\n        nonRefCount++\n      }\n    }\n    if (nonRefCount > 1 || options?.forceWrapper) {\n      htmlOptions.wrapper = 'div'\n      wrapperWasAutoSet = true\n    } else if (inline && nonRefCount > 0) {\n      htmlOptions.wrapper = 'span'\n      wrapperWasAutoSet = true\n    }\n  }\n  htmlOptions.wrapperWasAutoSet = wrapperWasAutoSet\n  return astToHTML(ast, htmlOptions)\n}\n"
  ],
  "mappings": "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",
  "debugId": "A77305067C35966B64756E2164756E21",
  "names": []
}